import { Router } from 'express'
import { asyncHandler } from '../middleware/errorHandler.js'
import { authenticate_token } from '../middleware/auth.js'
import { prisma } from '../lib/prisma.js'
import { z } from 'zod'
import { filterSensitiveFields } from '../utils/fieldConverter.js'
import {
  find_or_create_sku,
  create_sku_inventory_log,
  generate_material_signature
} from '../utils/skuUtils.js'

const router = Router()



// ÊµãËØïË∑ØÁî±ÔºàÊó†ÈúÄËÆ§ËØÅÔºâ- ÂøÖÈ°ªÂú®/:idË∑ØÁî±‰πãÂâçÂÆö‰πâ
router.get('/test', (req, res) => {
  console.log('üî• [TEST] ÊµãËØïË∑ØÁî±Ë¢´Ë∞ÉÁî®!')
  res.json({ success: true, message: 'ÊµãËØïË∑ØÁî±Ê≠£Â∏∏Â∑•‰Ωú' })
})

// ÊµãËØïË∑ØÁî±ÔºàÈúÄË¶ÅËÆ§ËØÅÔºâ- ÂøÖÈ°ªÂú®/:idË∑ØÁî±‰πãÂâçÂÆö‰πâ
router.get('/test-auth', authenticate_token, (req, res) => {
  console.log('üî• [TEST-AUTH] ËÆ§ËØÅÊµãËØïË∑ØÁî±Ë¢´Ë∞ÉÁî®!')
  res.json({ success: true, message: 'ËÆ§ËØÅÊµãËØïË∑ØÁî±Ê≠£Â∏∏Â∑•‰Ωú' })
})

// Ëé∑ÂèñÂèØÁî®ÂéüÊùêÊñôÂàóË°® - ÂøÖÈ°ªÂú®/:idË∑ØÁî±‰πãÂâçÂÆö‰πâ
router.get('/materials', authenticate_token, asyncHandler(async (req, res) => {
  console.log('üîç [Materials API] Êé•Âè£Ë¢´Ë∞ÉÁî®:', {
    query: req.query,
    user: req.user?.id,
    timestamp: new Date().toISOString()
  })
  
  const { 
    search, 
    material_types,
    available_only = 'true', 
    min_quantity = 1 
  } = req.query
  
  try {
    // ÊûÑÂª∫Êü•ËØ¢Êù°‰ª∂ÔºåÊîØÊåÅÊâÄÊúâ‰∫ßÂìÅÁ±ªÂûã
    let whereClause = 'WHERE 1=1'
    const params: any[] = []
    
    if (search) {
      whereClause += ' AND p.product_name LIKE ?'  // Êï∞ÊçÆÂ∫ìÂ≠óÊÆµ‰øùÊåÅ‰∏çÂèòÔºå‰ΩÜÊ¶ÇÂøµ‰∏äÊòØmaterialName
      params.push(`%${search}%`)
    }
    
    // ÂéüÊùêÊñôÁ±ªÂûãÁ≠õÈÄâ - Â§ÑÁêÜÂ≠óÁ¨¶‰∏≤ÊàñÊï∞ÁªÑÊ†ºÂºèÔºàÂåÖÊã¨ÂçäÊàêÂìÅmaterialÂíåÊàêÂìÅmaterialÔºâ
    let materialTypesArray: string[] = []
    if (material_types) {  // ÂâçÁ´Ø‰º†ÂÖ•ÁöÑÂèÇÊï∞Âêç‰øùÊåÅÂÖºÂÆπ
      if (typeof material_types === 'string') {
        // Â¶ÇÊûúÊòØÈÄóÂè∑ÂàÜÈöîÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÂàÜÂâ≤ÊàêÊï∞ÁªÑ
        material_typesArray = material_types.split(',').map(type => type.trim()).filter(Boolean)
      } else if (Array.isArray(material_types)) {
        material_typesArray = material_types as string[]
      }
    }
    
    if (materialTypesArray.length > 0) {
      const placeholders = material_typesArray.map(() => '?').join(',')
      whereClause += ` AND p.material_type IN (${placeholders})`  // Êï∞ÊçÆÂ∫ìÂ≠óÊÆµ‰øùÊåÅ‰∏çÂèò
      params.push(...materialTypesArray)
    }
    
    // ‰ΩøÁî®ÈÄöÁî®ÁöÑÂ∫ìÂ≠òËÆ°ÁÆóÈÄªËæëÔºåÊîØÊåÅÊâÄÊúâ‰∫ßÂìÅÁ±ªÂûã
    const materialsQuery = `
      SELECT 
        p.id,
        p.purchase_code as purchase_code,
    p.product_name as material_name,  -- ÂéüÊùêÊñôÂêçÁß∞ÔºàÊ¶ÇÂøµÁªü‰∏Ä‰∏∫materialÔºâ
    p.material_type as material_type,  -- ÂéüÊùêÊñôÁ±ªÂûãÔºàLOOSE_BEADS/BRACELET/ACCESSORIES‰∏∫ÂçäÊàêÂìÅmaterialÔºåFINISHED‰∏∫ÊàêÂìÅmaterialÔºâ
    p.bead_diameter as bead_diameter,
        p.specification,
        p.quality,
        p.total_beads,
        p.piece_count,
        p.quantity,
        p.beads_per_string,
        COALESCE(SUM(mu.quantity_used), 0) as used_beads,
        COALESCE(SUM(mu.quantity_used), 0) as usedPieces,
        -- Ê†πÊçÆÂéüÊùêÊñôÁ±ªÂûãËÆ°ÁÆóÂèØÁî®Êï∞ÈáèÔºàÂçäÊàêÂìÅmaterialÂíåÊàêÂìÅmaterialÔºâ
        CASE 
          WHEN p.material_type = 'LOOSE_BEADS' THEN  -- Êï£Áè†ÂçäÊàêÂìÅmaterial
            GREATEST(0, COALESCE(p.piece_count, 0) - COALESCE(SUM(mu.quantity_used), 0))
          WHEN p.material_type = 'BRACELET' THEN     -- Êâã‰∏≤ÂçäÊàêÂìÅmaterial
            GREATEST(0, COALESCE(p.total_beads, 0) - COALESCE(SUM(mu.quantity_used), 0))
          WHEN p.material_type = 'ACCESSORIES' THEN  -- È•∞ÂìÅÈÖç‰ª∂ÂçäÊàêÂìÅmaterial
            GREATEST(0, COALESCE(p.piece_count, 0) - COALESCE(SUM(mu.quantity_used), 0))
          WHEN p.material_type = 'FINISHED' THEN     -- ÊàêÂìÅmaterialÔºàÊàêÂìÅÂéüÊùêÊñôÔºâ
            GREATEST(0, COALESCE(p.piece_count, 0) - COALESCE(SUM(mu.quantity_used), 0))
          ELSE 0
        END as availableQuantity,
        -- Ê†πÊçÆÂéüÊùêÊñôÁ±ªÂûãËÆ°ÁÆóÂçï‰ΩçÊàêÊú¨
        CASE 
          WHEN p.material_type = 'LOOSE_BEADS' AND p.piece_count > 0 THEN 
            p.total_price / p.piece_count
          WHEN p.material_type = 'BRACELET' AND p.total_beads > 0 THEN 
            p.price_per_bead
          WHEN p.material_type IN ('ACCESSORIES', 'FINISHED') AND p.piece_count > 0 THEN 
            p.total_price / p.piece_count
          ELSE p.unit_price
        END as unitCost,
        p.price_per_bead as price_per_bead,
        p.price_per_gram as price_per_gram,
        p.total_price as total_price,
    p.unit_price as unit_price,
        p.weight,
        p.photos,
        s.name as supplier_name,
        p.created_at as created_at,
        p.updated_at as updated_at
      FROM purchases p
      LEFT JOIN material_usage mu ON p.id = mu.purchase_id
      LEFT JOIN suppliers s ON p.supplier_id = s.id
      ${whereClause}
      GROUP BY p.id, p.purchase_code, p.product_name, p.material_type, p.bead_diameter, p.specification, p.quality, 
               p.total_beads, p.piece_count, p.quantity, p.beads_per_string, p.price_per_bead, p.price_per_gram, 
               p.total_price, p.unit_price, p.weight, p.photos, s.name, p.created_at, p.updated_at
      -- Ê≥®ÔºöproductNameÂú®‰∏öÂä°Ê¶ÇÂøµ‰∏äÊòØmaterialNameÔºåmaterialTypeÂú®‰∏öÂä°Ê¶ÇÂøµ‰∏äÊòØmaterialType
      ${available_only === 'true' ? 'HAVING available_quantity >= ?' : ''}
      ORDER BY p.created_at DESC
    `
    
    if (available_only === 'true') {
      params.push(Number(min_quantity))
    }
    
    console.log('üîç [Materials API] ÊâßË°åSQLÊü•ËØ¢:', {
      query: materialsQuery.substring(0, 200) + '...',
      params,
      whereClause
    })
    
    const materialsResult = await prisma.$query_raw_unsafe(materialsQuery, ...(params || [])) as any[]
    
    console.log('üîç [Materials API] SQLÊü•ËØ¢ÁªìÊûú:', {
      resultCount: materialsResult.length,
      firstResult: materialsResult[0] || null
    })
    
    // Ê†ºÂºèÂåñÂéüÊùêÊñôÊï∞ÊçÆÔºàÁªü‰∏Ä‰ΩøÁî®materialÊ¶ÇÂøµÔºâ
    const formattedMaterials = materialsResult.map(material => {
      const converted = {
        ...material,
        purchase_id: material.id,
        material_name: material.material_name, // ÂéüÊùêÊñôÂêçÁß∞ÔºàÁªü‰∏ÄÊ¶ÇÂøµÔºâ
        material_type: material.material_type, // ÂéüÊùêÊñôÁ±ªÂûãÔºàÂçäÊàêÂìÅmaterialÊàñÊàêÂìÅmaterialÔºâ
        available_quantity: Number(material.available_quantity),
        unit_cost: Number(material.unit_cost) || 0
      }
      
      // SKUÂà∂‰ΩúÁõ∏ÂÖ≥Â≠óÊÆµÊò†Â∞ÑÔºàÊîØÊåÅ‰∏§ÁßçÂà∂‰ΩúÊ®°ÂºèÔºâ
      // 1. ÂçäÊàêÂìÅÁªÑÂêàÊ®°ÂºèÔºö‰ΩøÁî®LOOSE_BEADS„ÄÅBRACELET„ÄÅACCESSORIES
      // 2. Áõ¥Êé•ËΩ¨ÂåñÊ®°ÂºèÔºö‰ΩøÁî®FINISHEDÊàêÂìÅmaterial
      converted.quantity = material.quantity // ‰∏≤Êï∞ÔºàÊâã‰∏≤Á±ªÂûãÔºâ
      converted.beads_per_string = material.beads_per_string // ÊØè‰∏≤È¢óÊï∞
      converted.total_beads = material.total_beads // ÊÄªÈ¢óÊï∞
      converted.piece_count = material.piece_count // ÁâáÊï∞/‰ª∂Êï∞
      converted.used_beads = Number(material.used_beads) // Â∑≤Áî®È¢óÊï∞
      converted.usedPieces = Number(material.usedPieces) // Â∑≤Áî®ÁâáÊï∞/‰ª∂Êï∞
      
      // Ê†πÊçÆÂéüÊùêÊñôÁ±ªÂûãËÆ°ÁÆóÂâ©‰ΩôÊï∞Èáè
      if (material.material_type === 'LOOSE_BEADS' || material.material_type === 'BRACELET') {
        // ÂçäÊàêÂìÅmaterialÔºöÊï£Áè†ÂíåÊâã‰∏≤ÊåâÈ¢óÊï∞ËÆ°ÁÆó
        converted.remaining_beads = (material.total_beads || 0) - Number(material.used_beads)
      } else if (material.material_type === 'ACCESSORIES' || material.material_type === 'FINISHED') {
        // ÂçäÊàêÂìÅmaterialÔºàÈ•∞ÂìÅÈÖç‰ª∂ÔºâÂíåÊàêÂìÅmaterialÊåâÁâáÊï∞/‰ª∂Êï∞ËÆ°ÁÆó
        converted.remainingPieces = (material.piece_count || 0) - Number(material.usedPieces)
      }
      
      // Ê†πÊçÆÁî®Êà∑ÊùÉÈôêËøáÊª§ÊïèÊÑü‰ø°ÊÅØ
      if (req.user!.role === 'EMPLOYEE') {
        converted.price_per_bead = null
        converted.price_per_gram = null
        converted.total_price = null
        converted.unit_price = null
        converted.unit_cost = null
        converted.supplier_name = null
      }
      
      return converted
    })
    
    console.log('üîç [Materials API] ÂáÜÂ§áËøîÂõûÂìçÂ∫î:', {
      materialsCount: formattedMaterials.length,
      success: true
    })
    
    res.json({
      success: true,
      message: 'Ëé∑ÂèñÂèØÁî®ÂéüÊùêÊñôÊàêÂäü',
      data: {
        materials: formattedMaterials,
        total_count: formattedMaterials.length
      }
    })
  } catch (error) {
    console.error('Ëé∑ÂèñÂéüÊùêÊñôÂ§±Ë¥•:', error)
    res.status(500).json({
      success: false,
      message: 'Ëé∑ÂèñÂéüÊùêÊñôÂ§±Ë¥•',
      error: {
        code: 'MATERIALS_FETCH_ERROR',
        details: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
        stack: error instanceof Error ? error.stack : undefined
      }
    })
  }
}))

// ÊóßÁöÑÈ™åËØÅschemaÂ∑≤Âà†Èô§ÔºåÊñ∞ÁöÑÊé•Âè£‰ΩøÁî®ÊâãÂä®È™åËØÅ

// Ëé∑ÂèñSKUÈîÄÂîÆÂàóË°®
router.get('/', authenticate_token, asyncHandler(async (req, res) => {
  const { 
    page = 1, 
    limit = 10, 
    search, 
    status,
    sort_by = 'created_at',
    sort_order = 'desc'
  } = req.query
  
  const where: any = {}
  
  if (search) {
    where.name = {
      contains: search as string
    }
  }
  
  if (status) {
    // Â§ÑÁêÜÊï∞ÁªÑÊ†ºÂºèÁöÑstatusÂèÇÊï∞
    if (Array.isArray(status)) {
      where.status = {
        in: status
      }
    } else {
      where.status = status
    }
  }
  
  // Â≠óÊÆµÂêçÊò†Â∞ÑÔºöÂâçÁ´Øsnake_case -> Êï∞ÊçÆÂ∫ìsnake_case
  const fieldMapping: Record<string, string> = {
    'created_at': 'created_at',
    'updated_at': 'updated_at',
    'product_name': 'name',
    'productCode': 'productCode',
    'unit_price': 'unit_price',
    'total_value': 'total_value'
  }
  
  const dbSortField = fieldMapping[sort_by as string] || sort_by as string
  
  const products = await prisma.product.find_many({
    where,
    include: {
      user: {
        select: {
          id: true,
          name: true,
          user_name: true
        }
      },
      material_usages: {
        include: {
          purchase: {
            select: {
              id: true,
              product_name: true,
              bead_diameter: true,
              specification: true,
              quality: true
            }
          }
        }
      }
    },
    orderBy: {
      [dbSortField]: sort_order
    },
    skip: (Number(page) - 1) * Number(limit),
    take: Number(limit)
  })
  
  const total = await prisma.product.count({ where })
  
  // ËøáÊª§ÊïèÊÑü‰ø°ÊÅØ
  const filteredProducts = products.map((product, index) => {
    const converted = { ...product }
    
    if (req.user!.role === 'EMPLOYEE') {
      // ÈõáÂëò‰∏çËÉΩÊü•ÁúãÊàêÊú¨Áõ∏ÂÖ≥‰ø°ÊÅØ
      delete (converted as any).unit_price
      delete (converted as any).total_value
    }
    
    return converted
  })
  
  res.json({
    success: true,
    message: 'Ëé∑ÂèñSKUÈîÄÂîÆÂàóË°®ÊàêÂäü',
    data: {
      products: filteredProducts,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        pages: Math.ceil(total / Number(limit))
      }
    }
  })
  return
}))

// ÊóßÁöÑÂàõÂª∫ÊàêÂìÅËÆ∞ÂΩïÊé•Âè£Â∑≤Ë¢´‰∏ãÊñπÁöÑÂÆåÊï¥ÂÆûÁé∞Êõø‰ª£
// Ê≠§Êé•Âè£Â∑≤Ê≥®ÈáäÊéâ‰ª•ÈÅøÂÖçË∑ØÁî±ÂÜ≤Á™Å

// Ëé∑ÂèñÂçï‰∏™ÊàêÂìÅËÆ∞ÂΩï
router.get('/:id', authenticate_token, asyncHandler(async (req, res) => {
  const { id } = req.params
  
  const product = await prisma.product.find_unique({
    where: { id },
    include: {
      user: {
        select: {
          id: true,
          name: true,
          user_name: true
        }
      },
      material_usages: {
          include: {
            purchase: {
              select: {
                id: true,
                product_name: true,
                bead_diameter: true,
                specification: true,
                quality: true,
                price_per_bead: true
              }
            }
          }
        }
    }
  })
  
  if (!product) {
    return res.status(404).json({
      success: false,
      message: 'ÊàêÂìÅËÆ∞ÂΩï‰∏çÂ≠òÂú®'
    })
  }
  
  // ËøáÊª§ÊïèÊÑü‰ø°ÊÅØ
  const converted = { ...product }
  
  if (req.user!.role === 'EMPLOYEE') {
    delete (converted as any).unit_price
    delete (converted as any).total_value
  }
  
  res.json({
    success: true,
    message: 'Ëé∑ÂèñÊàêÂìÅËÆ∞ÂΩïÊàêÂäü',
    data: converted
  })
  return
}))

// ÊàêÂìÅÈîÄÊØÅÔºàÂê´Â∫ìÂ≠òÂõûÊªöÔºâ
router.delete('/:id/destroy', authenticate_token, asyncHandler(async (req, res) => {
  const { id } = req.params
  
  // ÂºÄÂêØ‰∫ãÂä°ËøõË°åÈîÄÊØÅÊìç‰Ωú
  const result = await prisma.$transaction(async (tx) => {
    // Êü•ËØ¢ÊàêÂìÅÂèäÂÖ∂ÂéüÊùêÊñô‰ΩøÁî®ËÆ∞ÂΩï
    const product = await tx.product.find_unique({
      where: { id },
      include: {
        material_usages: {
          include: {
            purchase: {
              select: {
                id: true,
                product_name: true,
                bead_diameter: true,
                quality: true
              }
            }
          }
        }
      }
    })
    
    if (!product) {
      throw new Error('ÊàêÂìÅËÆ∞ÂΩï‰∏çÂ≠òÂú®')
    }
    
    // ËÆ∞ÂΩïË¶ÅÂõûÊªöÁöÑÂéüÊùêÊñô‰ø°ÊÅØ
    const restored_materials: any[] = []
    
    // Âà†Èô§ÂéüÊùêÊñô‰ΩøÁî®ËÆ∞ÂΩïÔºàËá™Âä®ÂõûÊªöÂ∫ìÂ≠òÔºâ
    await tx.material_usage.delete_many({
      where: { product_id: id }
    })
    
    // Âà†Èô§ÊàêÂìÅËÆ∞ÂΩï
    await tx.product.delete({
      where: { id }
    })
    
    return {
      destroyedProductId: id,
      restored_materials: restoredMaterials
    }
  })
  
  res.json({
    success: true,
    message: 'ÊàêÂìÅÈîÄÊØÅÊàêÂäüÔºåÂéüÊùêÊñôÂ∑≤ÂõûÊªö',
    data: result
  })
}))

// Êõ¥Êñ∞ÊàêÂìÅËÆ∞ÂΩï
router.put('/:id', authenticate_token, asyncHandler(async (req, res) => {
  res.json({
    success: false,
    message: 'Êõ¥Êñ∞ÊàêÂìÅËÆ∞ÂΩïÂäüËÉΩÊ≠£Âú®ÂºÄÂèë‰∏≠...',
    error: {
      code: 'NOT_IMPLEMENTED',
      details: 'ËØ•ÂäüËÉΩÂ∞öÊú™ÂÆûÁé∞'
    }
  })
  return
}))

// ËÆ°ÁÆóÂà∂‰ΩúÊàêÊú¨È¢Ñ‰º∞
router.post('/cost', authenticate_token, asyncHandler(async (req, res) => {
  const { materials, labor_cost = 0, craft_cost = 0, profit_margin = 30 } = req.body
  
  if (!materials || !Array.isArray(materials) || materials.length === 0) {
    return res.status(400).json({
      success: false,
      message: 'ËØ∑Êèê‰æõÂéüÊùêÊñôÂàóË°®'
    })
  }
  
  let totalMaterialCost = 0
  const materialDetails = []
  
  // ËÆ°ÁÆóÂéüÊùêÊñôÊàêÊú¨
  for (const material of materials) {
    const purchase = await prisma.purchase.find_unique({
      where: { id: material.purchase_id }
    })
    
    if (!purchase) {
      return res.status(400).json({
        success: false,
        message: `ÈááË¥≠ËÆ∞ÂΩï ${material.purchase_id} ‰∏çÂ≠òÂú®`
      })
    }
    
    const used_beads = material.quantity_used_beads || 0
    const usedPieces = material.quantity_used_pieces || 0
    
    let material_cost = 0
    if (used_beads > 0 && purchase.price_per_bead) {
      material_cost += used_beads * Number(purchase.price_per_bead)
    }
    if (usedPieces > 0 && purchase.price_per_piece) {
      material_cost += usedPieces * Number(purchase.price_per_piece)
    }
    
    totalMaterialCost += materialCost
    materialDetails.push({
      purchase_id: material.purchase_id,
      product_name: purchase.product_name,
      used_beads: used_beads,
      usedPieces: usedPieces,
      unit_cost: purchase.price_per_bead || purchase.price_per_piece || 0,
      material_cost: material_cost
    })
  }
  
  // ËÆ°ÁÆóÊÄªÊàêÊú¨
  const total_cost = totalMaterialCost + Number(labor_cost) + Number(craft_cost)
  
  // ËÆ°ÁÆóÂª∫ËÆÆÂîÆ‰ª∑
  const profitMultiplier = 1 + (Number(profit_margin) / 100)
  const suggestedPrice = total_cost * profitMultiplier
  
  res.json({
    success: true,
    message: 'ÊàêÊú¨ËÆ°ÁÆóÊàêÂäü',
    data: {
      material_cost: totalMaterialCost,
      labor_cost: Number(labor_cost),
      craft_cost: Number(craft_cost),
      total_cost: total_cost,
      profit_margin: Number(profit_margin),
      pricingSuggestion: {
        suggestedPrice: Math.round(suggestedPrice * 100) / 100,
        minPrice: Math.round(total_cost * 1.1 * 100) / 100,
        maxPrice: Math.round(total_cost * 2 * 100) / 100
      },
      materialDetails: materialDetails
    }
  })
  return
}))

// ÂàõÂª∫ÊàêÂìÅËÆ∞ÂΩïÔºàÈáçÂÜôÂéüÊúâÁöÑPOST /Êé•Âè£Ôºâ
router.post('/', authenticate_token, asyncHandler(async (req, res) => {
  const {
    product_name,
    description,
    specification,
    materials,
    labor_cost = 0,
    craft_cost = 0,
    selling_price,
    profit_margin = 30,
    photos = []
  } = req.body
  
  // È™åËØÅÂøÖÂ°´Â≠óÊÆµ
  if (!product_name || !materials || !Array.isArray(materials) || materials.length === 0) {
    return res.status(400).json({
      success: false,
      message: 'ËØ∑Êèê‰æõÊàêÂìÅÂêçÁß∞ÂíåÂéüÊùêÊñôÂàóË°®'
    })
  }
  
  if (!selling_price || selling_price <= 0) {
    return res.status(400).json({
      success: false,
      message: 'ËØ∑ËÆæÁΩÆÊúâÊïàÁöÑÈîÄÂîÆ‰ª∑Ê†º'
    })
  }
  
  // ÂºÄÂêØ‰∫ãÂä°
  const result = await prisma.$transaction(async (tx) => {
    // È™åËØÅÂéüÊùêÊñôÂ∫ìÂ≠ò
    let totalMaterialCost = 0
    
    for (const material of materials) {
      const purchase = await tx.purchase.find_unique({
        where: { id: material.purchase_id },
        include: { material_usages: true }
      })
      
      if (!purchase) {
        throw new Error(`ÈááË¥≠ËÆ∞ÂΩï ${material.purchase_id} ‰∏çÂ≠òÂú®`)
      }
      
      // Ê†πÊçÆ‰∫ßÂìÅÁ±ªÂûãËÆ°ÁÆóÂ∑≤‰ΩøÁî®Êï∞ÈáèÂíåÂèØÁî®Â∫ìÂ≠ò
      let used_quantity = 0
      let available_quantity = 0
      let requiredQuantity = 0
      
      if (purchase.material_type === 'LOOSE_BEADS' || purchase.material_type === 'BRACELET') {// Êï£Áè†ÂíåÊâã‰∏≤ÊåâÈ¢óËÆ°ÁÆó
        usedQuantity = purchase.material_usages.reduce(
          (sum, usage) => sum + usage.quantity_used, 0
        )
        available_quantity = (purchase.total_beads || 0) - used_quantity
        requiredQuantity = material.quantity_used_beads || 0
      } else if (purchase.material_type === 'ACCESSORIES' || purchase.material_type === 'FINISHED') {// È•∞ÂìÅÈÖç‰ª∂ÂíåÊàêÂìÅÊåâÁâá/‰ª∂ËÆ°ÁÆó
        usedQuantity = purchase.material_usages.reduce(
          (sum, usage) => sum + usage.quantity_used, 0
        )
        available_quantity = (purchase.piece_count || 0) - used_quantity
        requiredQuantity = material.quantity_used_pieces || 0
      }
      
      if (available_quantity < requiredQuantity) {
        const unit = purchase.material_type === 'LOOSE_BEADS' || purchase.material_type === 'BRACELET' ? 'È¢ó' : 
                    purchase.material_type === 'ACCESSORIES' ? 'Áâá' : '‰ª∂'
        throw new Error(`ÂéüÊùêÊñô ${purchase.product_name} Â∫ìÂ≠ò‰∏çË∂≥ÔºåÂèØÁî®Ôºö${ available_quantity }${unit}ÔºåÈúÄË¶ÅÔºö${requiredQuantity}${unit}`)
      }
      
      // ËÆ°ÁÆóÂéüÊùêÊñôÊàêÊú¨ÔºàÊ†πÊçÆ‰∫ßÂìÅÁ±ªÂûãÂíå‰ΩøÁî®Êï∞ÈáèÔºâ
      let materialUnitCost = 0;
      let materialUsedQuantity = 0;
      
      if (purchase.material_type === 'LOOSE_BEADS' || purchase.material_type === 'BRACELET') {
        // Êï£Áè†ÂíåÊâã‰∏≤‰ΩøÁî®ÊØèÈ¢ó‰ª∑Ê†ºÂíåÈ¢óÊï∞
        materialUnitCost = Number(purchase.price_per_bead) || 0;
        materialUsedQuantity = material.quantity_used_beads || 0;
      } else if (purchase.material_type === 'ACCESSORIES' || purchase.material_type === 'FINISHED') {
        // È•∞ÂìÅÈÖç‰ª∂ÂíåÊàêÂìÅ‰ΩøÁî®ÊØèÁâá/ÊØè‰ª∂‰ª∑Ê†ºÂíåÁâáÊï∞/‰ª∂Êï∞
        materialUnitCost = Number(purchase.price_per_piece) || 0;
        materialUsedQuantity = material.quantity_used_pieces || 0;
      }
      
      // Â¶ÇÊûúÂçï‰ª∑‰∏∫0ÔºåÂ∞ùËØï‰ΩøÁî®ÂÖ∂‰ªñ‰ª∑Ê†ºÂ≠óÊÆµ‰Ωú‰∏∫Â§áÈÄâ
      if (materialUnitCost === 0) {
        materialUnitCost = Number(purchase.unit_price) || Number(purchase.total_price) || 0;
        // Â¶ÇÊûú‰ΩøÁî®ÊÄª‰ª∑ÔºåÈúÄË¶ÅÊ†πÊçÆÊÄªÊï∞ÈáèËÆ°ÁÆóÂçï‰ª∑
        if (materialUnitCost === Number(purchase.total_price) && (purchase.piece_count || 0) > 0) {
          materialUnitCost = materialUnitCost / (purchase.piece_count || 1);
        }
      }
      
      // Á¥ØÂä†ÊùêÊñôÊàêÊú¨Ôºö‰ΩøÁî®Êï∞Èáè √ó Âçï‰ª∑
      if (materialUsedQuantity > 0 && materialUnitCost > 0) {
        totalMaterialCost += materialUsedQuantity * materialUnitCost;
      }
    }
    
    // ËÆ°ÁÆóÊÄªÊàêÊú¨
    const total_cost = totalMaterialCost + Number(labor_cost) + Number(craft_cost)
    
    // ÂáÜÂ§áÂéüÊùêÊñô‰ΩøÁî®ËÆ∞ÂΩïÔºàÁî®‰∫éSKUÊ†áËØÜÁîüÊàêÔºâ
    const materialUsagesForSku = []
    for (const material of materials) {
      const purchase = await tx.purchase.find_unique({
        where: { id: material.purchase_id }
      })
      
      if (purchase) {
        material_usagesForSku.push({
          quantity_used: (material.quantity_used_beads || 0) + (material.quantity_used_pieces || 0),
          purchase: {
            product_name: purchase.product_name,
            material_type: purchase.material_type,
            quality: purchase.quality,
            bead_diameter: purchase.bead_diameter,
            specification: purchase.specification
          }
        })
      }
    }
    
    // Êü•ÊâæÊàñÂàõÂª∫SKU
    // ËÆ°ÁÆóSKUËßÑÊ†ºÔºà‰ªéÂéüÊùêÊñôÊé®ÂØºÔºâ
    let skuSpecification = null;
    if (materialUsagesForSku.length > 0) {
      const firstMaterial = material_usagesForSku[0].purchase;
      if (firstMaterial.material_type === 'LOOSE_BEADS' || firstMaterial.material_type === 'BRACELET') {
        // Êï£Áè†ÂíåÊâã‰∏≤‰ºòÂÖà‰ΩøÁî®bead_diameter
        if (firstMaterial.bead_diameter) {
          skuSpecification = `${firstMaterial.bead_diameter}mm`;
        } else if (firstMaterial.specification) {
          skuSpecification = `${firstMaterial.specification}mm`;
        }
      } else if (firstMaterial.material_type === 'ACCESSORIES' || firstMaterial.material_type === 'FINISHED') {
        // È•∞ÂìÅÈÖç‰ª∂ÂíåÊàêÂìÅ‰ºòÂÖà‰ΩøÁî®specification
        if (firstMaterial.specification) {
          skuSpecification = `${firstMaterial.specification}mm`;
        } else if (firstMaterial.bead_diameter) {
          skuSpecification = `${firstMaterial.bead_diameter}mm`;
        }
      }
    }

    const skuResult = await find_or_create_sku({
      material_usages: material_usagesForSku,
        product_name: product_name,
        selling_price: Number(selling_price),
      user_id: req.user!.id,
      tx: tx,
      additional_data: {
        photos: photos.length > 0 ? JSON.stringify(photos) : null,
        description: description,
        specification: skuSpecification,
        material_cost: totalMaterialCost,
            labor_cost: Number(labor_cost),
            craft_cost: Number(craft_cost),
        total_cost: total_cost,
        profit_margin: Number(selling_price) > 0 
              ? ((Number(selling_price) - total_cost) / Number(selling_price) * 100)
              : 0
      }
    })
    
    const sku = (skuResult as any).sku
     const is_new_sku = (skuResult as any).is_new_sku
    
    // ÂàõÂª∫ÊàêÂìÅËÆ∞ÂΩïÂπ∂ÂÖ≥ËÅîÂà∞SKU
    const product = await tx.product.create({
      data: {
        product_code: null, // ‰∏çÂÜç‰ΩøÁî®ÂçïÁã¨ÁöÑÊàêÂìÅÁºñÂè∑
        name: product_name,
        description: description || null,
        unit_price: Number(selling_price),
        total_value: total_cost,
        unit: '‰ª∂',
        quantity: 1,
        images: photos.length > 0 ? JSON.stringify(photos) : null,
        notes: description || null,
        user_id: req.user!.id,
        sku_id: sku.id // ÂÖ≥ËÅîÂà∞SKU
      }
    })
    
    // ÂàõÂª∫ÂéüÊùêÊñô‰ΩøÁî®ËÆ∞ÂΩï
    for (const material of materials) {
      const used_beads = material.quantity_used_beads || 0
      const usedPieces = material.quantity_used_pieces || 0
      
      if (used_beads > 0 || usedPieces > 0) {
        await tx.material_usage.create({
          data: {
            material_id: material.purchase_id,
            product_id: product.id,
            quantity_used: used_beads || usedPieces,
            action: 'USE'
          }
        })
        
        // Â∞ÜÈááË¥≠ËÆ∞ÂΩïÁä∂ÊÄÅÊõ¥Êñ∞‰∏∫USEDÔºàÂ∑≤‰ΩøÁî®Ôºâ
        await tx.purchase.update({
          where: { id: material.purchase_id },
          data: { status: 'USED' }
        })
      }
    }
    
    // ÂàõÂª∫SKUÂ∫ìÂ≠òÂèòÊõ¥Êó•Âøó
    await create_sku_inventory_log({ sku_id: sku.id,
      action: 'CREATE',
      quantity_change: 1,
      quantity_before: sku.total_quantity - 1,
      quantity_after: sku.total_quantity,
      reference_type: 'PRODUCT',
      reference_id: product.id,
      notes: `ÁªÑÂêàÂà∂‰ΩúÊ®°ÂºèÂàõÂª∫ÊàêÂìÅ: ${product_name}`,
      user_id: req.user!.id,
      tx: tx
    })
    
    return {
      id: product.id,
      product_name,
      sku_code: sku.sku_code,
      sku_id: sku.id,
      is_new_sku: is_new_sku,
      total_cost: total_cost,
      selling_price: Number(selling_price),
      profit: Number(selling_price) - total_cost,
      profit_margin: ((Number(selling_price) - total_cost) / Number(selling_price) * 100).toFixed(2),
      skuTotalQuantity: sku.total_quantity,
      skuAvailableQuantity: sku.available_quantity
    }
  })
  
  res.status(201).json({
    success: true,
    message: 'ÊàêÂìÅÂàõÂª∫ÊàêÂäü',
    data: result
  })
  return
}))

// ÊâπÈáèÂàõÂª∫ÊàêÂìÅËÆ∞ÂΩïÔºàÁõ¥Êé•ËΩ¨ÂåñÊ®°ÂºèÔºâ
router.post('/batch', authenticate_token, asyncHandler(async (req, res) => {
  const { products } = req.body
  
  // È™åËØÅËØ∑Ê±ÇÂèÇÊï∞
  if (!products || !Array.isArray(products) || products.length === 0) {
    return res.status(400).json({
      success: false,
      message: 'ËØ∑Êèê‰æõÊàêÂìÅÂàóË°®'
    })
  }
  
  // È™åËØÅÊØè‰∏™ÊàêÂìÅÁöÑÂøÖÂ°´Â≠óÊÆµ
  for (let i = 0; i < products.length; i++) {
    const product = products[i]
    if (!product.material_id || !product.product_name || !product.selling_price || product.selling_price <= 0) {
      return res.status(400).json({
        success: false,
        message: `Á¨¨${i + 1}‰∏™ÊàêÂìÅ‰ø°ÊÅØ‰∏çÂÆåÊï¥ÔºöÈúÄË¶ÅÂéüÊùêÊñôID„ÄÅÊàêÂìÅÂêçÁß∞ÂíåÊúâÊïàÁöÑÈîÄÂîÆ‰ª∑Ê†º`
      })
    }
  }
  
  const created_products = []
  const failed_products = []
  
  // ÈÄê‰∏™Â§ÑÁêÜÊØè‰∏™ÊàêÂìÅÂàõÂª∫ÔºàÈÅøÂÖç‰∫ãÂä°ËøáÂ§ßÔºâ
  for (let i = 0; i < products.length; i++) {
    const productData = products[i]
    
    try {
      // ÂºÄÂêØÂçï‰∏™ÊàêÂìÅÁöÑ‰∫ãÂä°
      const result = await prisma.$transaction(async (tx) => {
        // È™åËØÅÂéüÊùêÊñôÂ≠òÂú®ÊÄßÂíåÂ∫ìÂ≠ò
        const purchase = await tx.purchase.find_unique({
          where: { id: productData.material_id },
          include: { material_usages: true }
        })
        
        if (!purchase) {
          throw new Error(`ÂéüÊùêÊñôËÆ∞ÂΩï‰∏çÂ≠òÂú®`)
        }
        
        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊàêÂìÅÁ±ªÂûãÁöÑÂéüÊùêÊñô
        if (purchase.material_type !== 'FINISHED') {
          throw new Error(`Âè™ËÉΩ‰ΩøÁî®ÊàêÂìÅÁ±ªÂûãÁöÑÂéüÊùêÊñôËøõË°åÁõ¥Êé•ËΩ¨Âåñ`)
        }
        
        // ËÆ°ÁÆóÂ∑≤‰ΩøÁî®Êï∞ÈáèÂíåÂèØÁî®Â∫ìÂ≠òÔºàÊàêÂìÅÊåâ‰ª∂ËÆ°ÁÆóÔºâ
        const used_quantity = purchase.material_usages.reduce(
          (sum, usage) => sum + usage.quantity_used, 0
        )
        const available_quantity = (purchase.piece_count || 0) - used_quantity
        
        if (available_quantity < 1) {
          throw new Error(`ÂéüÊùêÊñôÂ∫ìÂ≠ò‰∏çË∂≥ÔºåÂèØÁî®Ôºö${ available_quantity }‰ª∂ÔºåÈúÄË¶ÅÔºö1‰ª∂`)
        }
        
        // ËÆ°ÁÆóÊùêÊñôÊàêÊú¨ÔºàÊ†πÊçÆ‰∫ßÂìÅÁ±ªÂûãÈÄâÊã©Ê≠£Á°ÆÁöÑ‰ª∑Ê†ºÂ≠óÊÆµÔºâ
        let material_cost = 0;
        if (purchase.material_type === 'FINISHED') {
          // ÊàêÂìÅ‰ΩøÁî®ÊØè‰ª∂‰ª∑Ê†º
          material_cost = Number(purchase.price_per_piece) || 0;
        } else if (purchase.material_type === 'FINISHED') {
          // È•∞ÂìÅÈÖç‰ª∂ÂíåÊàêÂìÅ‰ΩøÁî®ÊØèÁâá/ÊØè‰ª∂‰ª∑Ê†º
          material_cost = Number(purchase.price_per_piece) || 0;
        }
        
        // Â¶ÇÊûú‰∏äËø∞Â≠óÊÆµÈÉΩ‰∏∫Á©∫ÔºåÂ∞ùËØï‰ΩøÁî®ÂÖ∂‰ªñ‰ª∑Ê†ºÂ≠óÊÆµ‰Ωú‰∏∫Â§áÈÄâ
        if (material_cost === 0) {
          material_cost = Number(purchase.unit_price) || Number(purchase.total_price) || 0;
        }
        
        const labor_cost = productData.labor_cost || 0;
        const craft_cost = productData.craft_cost || 0;
        const total_cost = Number(material_cost) + Number(labor_cost) + Number(craft_cost);
        
        // Â§ÑÁêÜÂõæÁâáÁªßÊâøÈÄªËæëÔºàÁõ¥Êé•ËΩ¨ÂåñÊ®°ÂºèÔºâ
        let productImages = null;
        if (productData.photos && productData.photos.length > 0) {
          // Â¶ÇÊûúÂâçÁ´Ø‰º†ÈÄí‰∫ÜÂõæÁâáÔºå‰ΩøÁî®ÂâçÁ´ØÂõæÁâá
          productImages = JSON.stringify(productData.photos);
        } else if (purchase.photos) {
          // Â¶ÇÊûúÂâçÁ´ØÊ≤°ÊúâÂõæÁâáÔºå‰ªéÂéüÊùêÊñôÁªßÊâøÂõæÁâá
          // purchase.photos‰ªéÊï∞ÊçÆÂ∫ìÊü•ËØ¢Âá∫Êù•Â∑≤ÁªèÊòØÊï∞ÁªÑÂØπË±°ÔºåÁõ¥Êé•‰ΩøÁî®
          let photosArray = purchase.photos;
          
          // Á°Æ‰øùÊòØÊï∞ÁªÑÊ†ºÂºè
          if (!Array.isArray(photosArray)) {
            photosArray = [photosArray];
          }
          
          // ËøáÊª§Êó†ÊïàÁöÑURL
          photosArray = photosArray.filter(url => url && typeof url === 'string' && url.trim() !== '');
          
          if (photosArray.length > 0) {
            productImages = JSON.stringify(photosArray);
          }
        }
        
        // ÂáÜÂ§áÂéüÊùêÊñô‰ΩøÁî®ËÆ∞ÂΩïÔºàÁî®‰∫éSKUÊ†áËØÜÁîüÊàêÔºâ
        const materialUsagesForSku = [{
          quantity_used: 1,
          purchase: {
            material_name: purchase.product_name,  // ÈááË¥≠ÁöÑÂéüÊùêÊñôÂêçÁß∞
            material_type: purchase.material_type,  // ÈááË¥≠ÁöÑÂéüÊùêÊñôÁ±ªÂûã
            quality: purchase.quality,
            bead_diameter: purchase.bead_diameter,
            specification: purchase.specification
          }
        }]
        
        // ËÆ°ÁÆóSKUËßÑÊ†ºÔºà‰ªéÈááË¥≠ÁöÑÂéüÊùêÊñôÊé®ÂØºÔºâ
        let skuSpecification = null;
        if (purchase.material_type === 'FINISHED') {
          // ÊàêÂìÅÂéüÊñô‰ºòÂÖà‰ΩøÁî®specification
          if (purchase.specification) {
            skuSpecification = `${purchase.specification}mm`;
          } else if (purchase.bead_diameter) {
            skuSpecification = `${purchase.bead_diameter}mm`;
          }
        } else if (purchase.material_type === 'FINISHED') {
          // È•∞ÂìÅÈÖç‰ª∂ÂíåÊàêÂìÅÂéüÊñô‰ºòÂÖà‰ΩøÁî®specification
          if (purchase.specification) {
            skuSpecification = `${purchase.specification}mm`;
          } else if (purchase.bead_diameter) {
            skuSpecification = `${purchase.bead_diameter}mm`;
          }
        }

        // Êü•ÊâæÊàñÂàõÂª∫SKUÔºàÂ∫ìÂ≠òÁÆ°ÁêÜÂçï‰ΩçÔºâ
        const skuResult = await find_or_create_sku({
          material_usages: material_usagesForSku,
          product_name: productData.product_name,  // ÊàêÂìÅÂêçÁß∞
          selling_price: Number(productData.selling_price),
          user_id: req.user!.id,
          tx: tx,
          additional_data: {
            photos: productImages,
            description: productData.description,
            specification: skuSpecification,
            material_cost: material_cost,
            labor_cost: labor_cost,
            craft_cost: craft_cost,
            total_cost: total_cost,
            profit_margin: Number(productData.selling_price) > 0 
              ? ((Number(productData.selling_price) - total_cost) / Number(productData.selling_price) * 100)
              : 0
          }
        })
        
        const sku = (skuResult as any).sku
         const is_new_sku = (skuResult as any).is_new_sku
        
        // ÂàõÂª∫ÊàêÂìÅËÆ∞ÂΩïÂπ∂ÂÖ≥ËÅîÂà∞SKUÔºàÂ∫ìÂ≠òÁÆ°ÁêÜÂçï‰ΩçÔºâ
        const finishedProduct = await tx.product.create({
          data: {
            product_code: null, // ‰∏çÂÜç‰ΩøÁî®ÂçïÁã¨ÁöÑÊàêÂìÅÁºñÂè∑
            name: productData.product_name,
            description: productData.description || null,
            unit_price: Number(productData.selling_price),
            total_value: total_cost,
            unit: '‰ª∂',
            quantity: 1,
            images: productImages,
            notes: productData.description || null,
            user_id: req.user!.id,
            sku_id: sku.id // ÂÖ≥ËÅîÂà∞SKUÔºàÂ∫ìÂ≠òÁÆ°ÁêÜÂçï‰ΩçÔºâ
          }
        })
        
        // ÂàõÂª∫ÂéüÊùêÊñô‰ΩøÁî®ËÆ∞ÂΩï
        await tx.material_usage.create({
          data: {
            material_id: productData.material_id,
            product_id: finishedProduct.id,  // ÂÖ≥ËÅîÂà∞ÊàêÂìÅ
            quantity_used: 1,
            action: 'USE'
          }
        })
        
        // Â∞ÜÈááË¥≠ËÆ∞ÂΩïÁä∂ÊÄÅÊõ¥Êñ∞‰∏∫USEDÔºàÂ∑≤‰ΩøÁî®Ôºâ
        await tx.purchase.update({
          where: { id: productData.material_id },
          data: { status: 'USED' }
        })
        
        // ÂàõÂª∫SKUÂ∫ìÂ≠òÂèòÊõ¥Êó•Âøó
        await create_sku_inventory_log({ sku_id: sku.id,
          action: 'CREATE',
          quantity_change: 1,
          quantity_before: sku.total_quantity - 1,
          quantity_after: sku.total_quantity,
          reference_type: 'FINISHED_PRODUCT',  // ÊòéÁ°ÆÊåáÂêëÊàêÂìÅ
          reference_id: finishedProduct.id,
          notes: `Áõ¥Êé•ËΩ¨ÂåñÊ®°ÂºèÂàõÂª∫ÊàêÂìÅ: ${productData.product_name}`,
          user_id: req.user!.id,
          tx: tx
        })
        
        return {
          finishedProductId: finishedProduct.id,  // ÊàêÂìÅID
          sku_code: sku.sku_code,
          sku_id: sku.id,
          is_new_sku: is_new_sku,
          finishedProductName: productData.product_name,  // ÊàêÂìÅÂêçÁß∞
          material_cost: Number(material_cost),
          total_cost: total_cost,
          selling_price: Number(productData.selling_price),
          profit_margin: Number(productData.selling_price) > 0 
            ? ((Number(productData.selling_price) - total_cost) / Number(productData.selling_price) * 100).toFixed(1)
            : '0.0',
          status: 'AVAILABLE',
          skuTotalQuantity: sku.total_quantity,
          skuAvailableQuantity: sku.available_quantity
        }
      })
      
      created_products.push(result)
      
    } catch (error) {
      console.error(`ÊâπÈáèÂàõÂª∫Á¨¨${i + 1}‰∏™ÊàêÂìÅÂ§±Ë¥•:`, error)
      failed_products.push({
        material_id: productData.material_id,
        error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
        error_code: 'CREATION_FAILED'
      })
    }
  }
  
  const success_count = created_products.length
  const failed_count = failed_products.length
  
  // Ê†πÊçÆÁªìÊûúËøîÂõûÁõ∏Â∫îÁöÑÁä∂ÊÄÅÁ†ÅÂíåÊ∂àÊÅØ
  if (success_count === 0) {
    return res.status(400).json({
      success: false,
      message: 'ÊâπÈáèÂàõÂª∫ÂÖ®ÈÉ®Â§±Ë¥•',
      data: {
        success_count: 0,
        failed_count: failed_count,
        created_products: [],
        failed_products: failed_products
      }
    })
  }
  
  const message = failed_count > 0 
    ? `ÊâπÈáèÂàõÂª∫ÈÉ®ÂàÜÊàêÂäüÔºöÊàêÂäü${ success_count }‰∏™ÔºåÂ§±Ë¥•${ failed_count }‰∏™`
    : `ÊâπÈáèÂàõÂª∫ÂÖ®ÈÉ®ÊàêÂäüÔºöÂÖ±ÂàõÂª∫${ success_count }‰∏™ÊàêÂìÅ`
  
  res.status(201).json({
    success: true,
    message,
    data: {
      success_count: success_count,
      failed_count: failed_count,
      created_products: created_products,
      failed_products: failed_products
    }
  })
  return
}))

export default router