import { Router } from 'express'
import { authenticate_token } from '../middleware/auth.js'
import { asyncHandler } from '../middleware/errorHandler.js'
import { prisma } from '../lib/prisma.js'
import { z } from 'zod'
import { quality_schema, material_typeSchema } from '../utils/validation.js'

import { ErrorResponses, createSuccessResponse } from '../utils/errorResponse.js'

const router = Router()

// Â∫ìÂ≠òÊü•ËØ¢ÂèÇÊï∞È™åËØÅschema
const inventoryQuerySchema = z.object({
  page: z.string().regex(/^\d+$/, 'È°µÁ†ÅÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).refine(n => n >= 1, 'È°µÁ†ÅÂøÖÈ°ªÂ§ß‰∫é0').optional(),
  limit: z.string().regex(/^\d+$/, 'ÊØèÈ°µÊï∞ÈáèÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).refine(n => n >= 1 && n <= 100, 'ÊØèÈ°µÊï∞ÈáèÂøÖÈ°ªÂú®1-100‰πãÈó¥').optional(),
  search: z.string().max(100, 'ÊêúÁ¥¢ÂÖ≥ÈîÆËØç‰∏çËÉΩË∂ÖËøá100Â≠óÁ¨¶').optional(),
  material_types: z.union([
    z.string().transform(s => s.includes(',') ? s.split(',').map(t => t.trim()) : [s]),
    z.array(z.string())
  ]).optional(),
  quality: quality_schema.optional(),
  low_stock_only: z.string().transform(s => s === 'true').optional(),
  diameter_min: z.string().regex(/^\d+(\.\d+)?$/, 'ÊúÄÂ∞èÁõ¥ÂæÑÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).optional(),
  diameter_max: z.string().regex(/^\d+(\.\d+)?$/, 'ÊúÄÂ§ßÁõ¥ÂæÑÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).optional(),
  specification_min: z.string().regex(/^\d+(\.\d+)?$/, 'ÊúÄÂ∞èËßÑÊ†ºÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).optional(),
  specification_max: z.string().regex(/^\d+(\.\d+)?$/, 'ÊúÄÂ§ßËßÑÊ†ºÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).optional(),
  sort: z.enum(['asc', 'desc']).optional(),
  sort_by: z.enum(['total_quantity', 'material_type', 'crystalType']).optional()
}).refine((data) => {
  // È™åËØÅËåÉÂõ¥ÂèÇÊï∞
  if (data.diameter_min && data.diameter_max && data.diameter_min > data.diameter_max) {
    throw new Error('ÊúÄÂ∞èÁõ¥ÂæÑ‰∏çËÉΩÂ§ß‰∫éÊúÄÂ§ßÁõ¥ÂæÑ')
  }
  if (data.specification_min && data.specification_max && data.specification_min > data.specification_max) {
    throw new Error('ÊúÄÂ∞èËßÑÊ†º‰∏çËÉΩÂ§ß‰∫éÊúÄÂ§ßËßÑÊ†º')
  }
  return true
})

// ÂØºÂá∫Êü•ËØ¢ÂèÇÊï∞È™åËØÅschema
const exportQuerySchema = z.object({
  format: z.enum(['xlsx', 'csv']).optional(),
  material_types: z.union([
    z.string().transform(s => [s]),
    z.array(z.string())
  ]).optional(),
  quality: quality_schema.optional(),
  low_stock_only: z.string().transform(s => s === 'true').optional()
})

// Ê∑ªÂä†Ë∞ÉËØïÁ´ØÁÇπ
router.get('/debug', authenticate_token, asyncHandler(async (req, res) => {
  try {
    // Êü•ËØ¢ÈááË¥≠Êï∞ÊçÆÊÄªÊï∞
    const total_purchases = await prisma.purchase.count()
    
    // Êü•ËØ¢Ââç5Êù°ÈááË¥≠ËÆ∞ÂΩï
    const samplePurchases = await prisma.purchase.findMany({
      take: 5,
      select: {
        id: true,
        product_name: true,
        material_type: true,
        quantity: true,
        piece_count: true,
        bead_diameter: true,
        specification: true,
        quality: true,
        created_at: true
      }
    })
    
    // Êü•ËØ¢MaterialUsageÊï∞ÊçÆ
    const totalMaterialUsage = await prisma.material_usage.count()
    
    res.json({
      success: true,
      data: {total_purchases,
        totalMaterialUsage,
        samplePurchases,
        message: 'Êï∞ÊçÆÂ∫ìË∞ÉËØï‰ø°ÊÅØ'
      }
    })
  } catch (error) {
    console.error('‚ùå [Â∫ìÂ≠òË∞ÉËØï] Êü•ËØ¢Â§±Ë¥•:', error)
    res.status(500).json(
      ErrorResponses.internal('Êü•ËØ¢Â§±Ë¥•', error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ')
    )
  }
}))

// ‰∫ßÂìÅÂàÜÁ±ªËß£ÊûêÂáΩÊï∞
const parseProductClassification = (product_name: string) => {
  // ‰∏ÄÁ∫ßÂàÜÁ±ªÔºöÊ∞¥Êô∂Á±ªÂûã
  const crystalTypes = {
    'ÈªÑÊ∞¥Êô∂': ['ÈªÑÊ∞¥Êô∂', 'Â∑¥Ë•øÈªÑÊ∞¥Êô∂'],
    'Á¥´Ê∞¥Êô∂': ['Á¥´Ê∞¥Êô∂', 'ÁéªÂà©Áª¥‰∫öÁ¥´'],
    'ÁôΩÊ∞¥Êô∂': ['ÁôΩÊ∞¥Êô∂'],
    'Á≤âÊ∞¥Êô∂': ['Á≤âÊ∞¥Êô∂', 'Ë•øÊüöÁ≤âÊô∂'],
    'Ëå∂Êô∂': ['Ëå∂Êô∂'],
    'ÁªøÂπΩÁÅµ': ['ÁªøÂπΩÁÅµ', 'Èõ™Ëä±ÁôΩÂπΩÁÅµ'],
    'ËçâËéìÊô∂': ['ËçâËéìÊô∂', 'È∏ΩË°ÄÁ∫¢ËçâËéìÊô∂'],
    'ÂèëÊô∂': ['Èì∂ÂèëÊô∂', 'ÁôΩÂèëÊô∂'],
    'ÈùíÈáëÁü≥': ['ÈùíÈáëÁü≥'],
    'ËìùÊô∂': ['ËìùÊô∂', 'Áå´ÁúºËìùÊô∂'],
    'Ëê§Áü≥': ['ÁªøËê§Áü≥', 'Á¥´Ëê§Áü≥', 'ËìùËê§Áü≥', 'ÈªÑËê§Áü≥'],
    'ÊúàÂÖâÁü≥': ['ÁÅ∞ÊúàÂÖâ', 'Â•∂Ëå∂ÊúàÂÖâ'],
    'Á¥´ÈæôÊô∂': ['Á¥´ÈæôÊô∂'],
    'ËÉ∂Ëä±': ['ÈªÑËÉ∂Ëä±', 'ËÉ∂Ëä±', 'Ê≤πÁîªËÉ∂Ëä±'],
    'ÂÖîÊØõ': ['ÂΩ©ÂÖîÊØõ'],
    'ÈªëÈáëË∂Ö‰∏É': ['ÈªëÈáëË∂Ö', 'ÈªëÈáëË∂Ö‰∏É'],
    'Èó™ÁÅµ': ['ÈªëÈó™ÁÅµ'],
    'ËôéÁúºÁü≥': ['ËìùËôéÁúº', 'Á∫¢Ëâ≤ËôéÁ∫πÁü≥'],
    'ÁéõÁëô': ['Á∫¢ÁéõÁëô', 'Ëå∂ÈæôÁ∫πÁéõÁëô', 'Á∫¢ÈæôÁ∫πÁéõÁëô', 'Ëå∂Ëâ≤ÈæôÁ∫πÁéõÁëô'],
    'ÂçóÁ∫¢': ['ÂçóÁ∫¢', 'Â§©ÁÑ∂ÂÜ∞È£òÂçóÁ∫¢'],
    'ÁªøÊùæÁü≥': ['ÁªøÊùæÁü≥', 'Â§©ÁÑ∂ÁªøÊùæÁü≥'],
    'Èì∂ÊõúÁü≥': ['Èì∂ÊõúÁü≥', 'Èì∂ËÄÄÁü≥', 'Â§©ÁÑ∂Èì∂ÊõúÁü≥', 'Â§©ÁÑ∂Èì∂ËÄÄÁü≥'],
    'Â≤´Áéâ': ['Â≤´Áéâ'],
    'ÁªøÈì∂Áü≥': ['ÁªøÈì∂Áü≥'],
    'ËìùÁ∫πÁü≥': ['ËìùÁ∫πÁü≥'],
    'ÁôΩÈòøÂ°û': ['ÁôΩÈòøÂ°û'],
    'ÈÖçÈ•∞': ['ÈöîÁè†', 'ÈöîÁâá', 'DIYÈ•∞ÂìÅ', 'Ë∑ëÁéØ']
  }
  
  // ‰∫åÁ∫ßÂàÜÁ±ªÔºöÂΩ¢Áä∂Á±ªÂûã
  const shapeTypes = {
    'ÂúÜÁè†': ['Êâã‰∏≤', 'ÂúÜÁè†'],
    'ÈöèÂΩ¢': ['ÈöèÂΩ¢'],
    'Êï£Áè†': ['Êï£Áè†', 'Áè†Â≠ê'],
    'ÊñπÁ≥ñ': ['ÊñπÁ≥ñ'],
    'Èïø‰∏≤': ['Èïø‰∏≤'],
    'ÈÖçÈ•∞': ['ÈöîÁè†', 'ÈöîÁâá', 'DIYÈ•∞ÂìÅ', 'Ë∑ëÁéØ']
  }
  
  let crystalType = 'ÂÖ∂‰ªñ'
  let shapeType = 'ÂúÜÁè†' // ÈªòËÆ§‰∏∫ÂúÜÁè†
  
  // ËØÜÂà´Ê∞¥Êô∂Á±ªÂûã
  for (const [type, keywords] of Object.entries(crystalTypes)) {
    if (keywords.some(keyword => product_name.includes(keyword))) {
      crystalType = type
      break
    }
  }
  
  // ËØÜÂà´ÂΩ¢Áä∂Á±ªÂûã
  for (const [shape, keywords] of Object.entries(shapeTypes)) {
    if (keywords.some(keyword => product_name.includes(keyword))) {
      shapeType = shape
      break
    }
  }
  
  // ÁâπÊÆäÂ§ÑÁêÜÔºöÂ¶ÇÊûúÂåÖÂê´"ÈöèÂΩ¢"Âàô‰ºòÂÖàËÆæ‰∏∫ÈöèÂΩ¢
  if (product_name.includes('ÈöèÂΩ¢')) {
    shapeType = 'ÈöèÂΩ¢'
  }
  
  // ÁâπÊÆäÂ§ÑÁêÜÔºöÈÖçÈ•∞Á±ª‰∫ßÂìÅ
  if (crystalType === 'ÈÖçÈ•∞') {
    shapeType = 'ÈÖçÈ•∞'
  }
  
  return {
    crystalType,
    shapeType
  }
}

// routerÂíåprismaÂ∑≤Âú®Êñá‰ª∂ÂºÄÂ§¥Â£∞Êòé

import { convertToApiFormat, convertFromApiFormat, filterSensitiveFields } from '../utils/fieldConverter.js'

// ÊùÉÈôêÊéßÂà∂ÔºöËøáÊª§ÊïèÊÑüÊï∞ÊçÆÂπ∂ËΩ¨Êç¢BigInt
const filterInventoryData = (inventory: any[], userRole: string) => {
  const convertBigIntToNumber = (item: any) => {
    const converted = convertToApiFormat({ ...item })
    
    // ËΩ¨Êç¢ÊâÄÊúâÂèØËÉΩÁöÑBigIntÂ≠óÊÆµ‰∏∫Number
    const bigIntFields = [
      'purchase_id', 'originalBeads', 'usedBeads', 'remainingBeads',
      'min_stock_alert', 'is_low_stock', 'bead_diameter'
    ]
    
    bigIntFields.forEach(field => {
      if (converted[field] !== null && converted[field] !== undefined) {
        converted[field] = Number(converted[field])
      }
    })
    
    // ËΩ¨Êç¢‰ª∑Ê†ºÁõ∏ÂÖ≥ÁöÑBigIntÂ≠óÊÆµ
    const priceFields = ['price_per_bead', 'price_per_gram', 'total_price', 'weight']
    priceFields.forEach(field => {
      if (converted[field] !== null && converted[field] !== undefined) {
        converted[field] = Number(converted[field])
      }
    })
    
    return converted
  }
  
  const convertedInventory = inventory.map(convertBigIntToNumber)
  
  if (userRole === 'BOSS') {
    return convertedInventory
  }
  
  // ÈõáÂëò‰∏çËÉΩÊü•ÁúãÊàêÊú¨Áõ∏ÂÖ≥‰ø°ÊÅØ
  return convertedInventory.map(item => ({
    ...item,
    price_per_bead: null,
    price_per_gram: null,
    supplier_name: null
  }))
}

// Ëé∑ÂèñÂ±ÇÁ∫ßÂºèÂ∫ìÂ≠òÂàóË°®ÔºàÊåâ‰∫ßÂìÅÁ±ªÂûãÂàÜÁ±ªÔºö‰∫ßÂìÅÁ±ªÂûã‚ÜíËßÑÊ†º‚ÜíÂìÅÁõ∏Ôºâ
router.get('/hierarchical', authenticate_token, asyncHandler(async (req, res) => {// È™åËØÅÊü•ËØ¢ÂèÇÊï∞
  const validatedQuery = inventoryQuerySchema.parse(req.query)
  const {
    page = 1,
    limit = 20,
    search,
    material_types,
    quality,
    low_stock_only,
    diameter_min,
    diameter_max,
    specification_min,
    specification_max,
    sort = 'desc',
    sort_by = 'total_quantity'
  } = validatedQuery

  // ‰ΩøÁî®materialTypes‰Ωú‰∏∫Á≠õÈÄâÊù°‰ª∂
  const finalMaterialTypes = material_types

  const page_num = parseInt(String(page))
  const limitNum = Math.min(parseInt(String(limit)), 100)
  const offset = (page_num - 1) * limitNum

  console.log('üîç [Â±ÇÁ∫ßÂºèÂ∫ìÂ≠òÊü•ËØ¢] ËØ∑Ê±ÇÂèÇÊï∞:', {page: page_num,
    limit: limitNum,
    search,
    material_types,
    finalMaterialTypes,
    quality,
    low_stock_only
  })

  try {// Êü•ËØ¢ÊâÄÊúâÂ∫ìÂ≠òÊï∞ÊçÆ
    const inventoryQuery = `
      SELECT 
        p.id as purchaseId,
        p.purchase_code as purchase_code,
    p.product_name as product_name,
        p.material_type as material_type,
        p.unit_type as unit_type,
        p.bead_diameter as bead_diameter,
        p.specification,
        p.quality,
        p.photos,
        CASE 
          WHEN p.material_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
          WHEN p.material_type = 'BRACELET' THEN COALESCE(p.total_beads, p.piece_count, 0)
          WHEN p.material_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
          WHEN p.material_type = 'FINISHED' THEN COALESCE(p.piece_count, 0)
          ELSE COALESCE(p.quantity, 0)
        END as original_quantity,
        COALESCE(mu.used_quantity, 0) as usedQuantity,
        (CASE 
          WHEN p.material_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
          WHEN p.material_type = 'BRACELET' THEN COALESCE(p.total_beads, p.piece_count, 0)
          WHEN p.material_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
          WHEN p.material_type = 'FINISHED' THEN COALESCE(p.piece_count, 0)
          ELSE COALESCE(p.quantity, 0)
        END - COALESCE(mu.used_quantity, 0)) as remaining_quantity,
        CASE WHEN p.min_stock_alert IS NOT NULL AND 
                 (CASE 
                   WHEN p.material_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
                   WHEN p.material_type = 'BRACELET' THEN COALESCE(p.total_beads, p.piece_count, 0)
                   WHEN p.material_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
                   WHEN p.material_type = 'FINISHED' THEN COALESCE(p.piece_count, 0)
                   ELSE COALESCE(p.quantity, 0)
                 END - COALESCE(mu.used_quantity, 0)) <= p.min_stock_alert 
            THEN 1 ELSE 0 END as is_low_stock,
        CASE 
          WHEN p.material_type = 'LOOSE_BEADS' THEN p.price_per_bead
          WHEN p.material_type = 'BRACELET' THEN 
            CASE 
              WHEN p.price_per_bead IS NOT NULL THEN p.price_per_bead
              WHEN p.total_price IS NOT NULL AND p.total_beads IS NOT NULL AND p.total_beads > 0 
                THEN p.total_price / p.total_beads
              ELSE NULL
            END
          WHEN p.material_type = 'ACCESSORIES' THEN 
            CASE 
              WHEN p.unit_price IS NOT NULL THEN p.unit_price
              WHEN p.total_price IS NOT NULL AND p.piece_count IS NOT NULL AND p.piece_count > 0 
                THEN p.total_price / p.piece_count
              ELSE NULL
            END
          WHEN p.material_type = 'FINISHED' THEN 
            CASE 
              WHEN p.unit_price IS NOT NULL THEN p.unit_price
              WHEN p.total_price IS NOT NULL AND p.piece_count IS NOT NULL AND p.piece_count > 0 
                THEN p.total_price / p.piece_count
              ELSE NULL
            END
          ELSE p.price_per_bead
        END as price_per_unit,
        p.price_per_gram as price_per_gram,
        p.purchase_date as purchase_date,
        s.name as supplier_name
      FROM purchases p
      LEFT JOIN (
        SELECT purchase_id, SUM(quantity_used) as used_quantity
        FROM material_usage
        GROUP BY purchase_id
      ) mu ON p.id = mu.purchase_id
      LEFT JOIN suppliers s ON p.supplier_id = s.id
      WHERE 1=1
      ORDER BY p.material_type, p.product_name, 
               COALESCE(p.bead_diameter, p.specification), p.quality, p.purchase_date
    `
    
    const allInventory = await prisma.$query_raw_unsafe(inventoryQuery) as any[]
    
    console.log('üìä [Â±ÇÁ∫ßÂºèÂ∫ìÂ≠òÊü•ËØ¢] ÂéüÂßãÊü•ËØ¢ÁªìÊûú:', {
      inventoryLength: allInventory.length,
      firstItem: allInventory[0]
    })
    
    // ÊûÑÂª∫Â±ÇÁ∫ßÁªìÊûÑ
    const hierarchicalData = new Map()
    
    allInventory.forEach((item: any) => {
      const material_type = item.material_type
      const diameter = item.bead_diameter ? Number(item.bead_diameter) : null
      const specification = item.specification ? Number(item.specification) : null
      const quality = item.quality || 'Êú™Áü•'
      
      // Â∫îÁî®Á≠õÈÄâÊù°‰ª∂
      if (search && !item.product_name.toLowerCase().includes(search.toLowerCase())) return
      
      // ÊùêÊñôÁ±ªÂûãÁ≠õÈÄâÔºàÂ§öÈÄâÔºâ
      if (finalMaterialTypes) {
        const materialTypesArray = Array.isArray(finalMaterialTypes) ? finalMaterialTypes : [finalMaterialTypes]
        if (!material_typesArray.includes(material_type)) return
      }
      
      // ÂìÅÁõ∏Á≠õÈÄâÔºöÂ¶ÇÊûúÊåáÂÆö‰∫ÜÂìÅÁõ∏Êù°‰ª∂ÔºåÂàôÊ£ÄÊü•ÊòØÂê¶ÂåπÈÖç
      if (quality) {
        const itemQuality = item.quality || 'Êú™Áü•'
        if (itemQuality !== quality) return
      }
      if (lowStockOnly && Number(item.is_low_stock) !== 1) return
      
      // Áè†Â≠êÁõ¥ÂæÑËåÉÂõ¥Á≠õÈÄâÔºàÊï£Áè†ÂíåÊâã‰∏≤Ôºâ
      if (diameter && diameter_min && diameter < Number(diameter_min)) return
      if (diameter && diameter_max && diameter > Number(diameter_max)) return
      
      // ËßÑÊ†ºËåÉÂõ¥Á≠õÈÄâÔºàÈ•∞ÂìÅÈÖç‰ª∂ÂíåÊàêÂìÅÔºâ
      if (specification && validatedQuery.specification_min && specification < Number(validatedQuery.specification_min)) return
      if (specification && validatedQuery.specification_max && specification > Number(validatedQuery.specification_max)) return
      
      // ÊûÑÂª∫Â±ÇÁ∫ßÈîÆ
      const specValue = diameter || specification || 0
      const specUnit = diameter ? 'mm' : 'mm'
      const level1Key = material_type
      const level2Key = `${material_type}|${specValue}${specUnit}`
      const level3Key = `${material_type}|${specValue}${specUnit}|${quality}`
      
      // ÂàùÂßãÂåñÂ±ÇÁ∫ßÁªìÊûÑ
      if (!hierarchicalData.has(level1Key)) {
        hierarchicalData.set(level1Key, {
          material_type: material_type,
          total_quantity: 0,
          total_variants: 0,
          has_low_stock: false,
          specifications: new Map()
        })
      }
      
      const level1 = hierarchicalData.get(level1Key)
      
      if (!level1.specifications.has(level2Key)) {
        level1.specifications.set(level2Key, {
          specification_value: specValue,
          specification_unit: specUnit,
          total_quantity: 0,
          total_variants: 0,
          has_low_stock: false,
          qualities: new Map()
        })
      }
      
      const level2 = level1.specifications.get(level2Key)
      
      if (!level2.qualities.has(level3Key)) {
        level2.qualities.set(level3Key, {
          quality: quality,
          remaining_quantity: 0,
          is_low_stock: false,
          weightedPricePerUnit: 0,
          weightedPricePerGram: 0,
          batches: []
        })
      }
      
      const level3 = level2.qualities.get(level3Key)
      
      // Á¥ØÂä†Êï∞ÊçÆ
      const remaining_quantity = Number(item.remaining_quantity)
      const original_quantity = Number(item.original_quantity)
      const is_low_stock = Number(item.is_low_stock) === 1
      
      level3.remaining_quantity += remainingQuantity
      level3.is_low_stock = level3.is_low_stock || isLowStock
      
      // Â§ÑÁêÜphotosÂ≠óÊÆµÁöÑJSONËß£Êûê
      let photos = []
      if (item.photos) {
        try {
          photos = typeof item.photos === 'string' ? JSON.parse(item.photos) : item.photos
          if (!Array.isArray(photos)) {
            photos = []
          }
        } catch (error) {
          console.warn('Ëß£ÊûêphotosÂ≠óÊÆµÂ§±Ë¥•:', error)
          photos = []
        }
      }

      level3.batches.push({purchase_id: item.purchase_id,
        purchase_code: item.purchase_code,
        material_name: item.product_name, // ‰øÆÊîπÔºöproduct_name ‚Üí material_nameÔºàÊ¶ÇÂøµÁªü‰∏ÄÔºâ
        material_type: item.material_type,
        purchase_date: item.purchase_date,
        supplier_name: item.supplier_name,
        original_quantity: original_quantity,
        used_quantity: Number(item.used_quantity),
        remaining_quantity: remaining_quantity,
        bead_diameter: item.bead_diameter ? Number(item.bead_diameter) : null,
        specification: item.specification ? Number(item.specification) : null,
        price_per_unit: req.user!.role === 'BOSS' ? Number(item.price_per_unit) : null,
        price_per_gram: req.user!.role === 'BOSS' ? Number(item.price_per_gram) : null,
        photos: photos
      })
      
      // Âêë‰∏äÁ¥ØÂä†ÁªüËÆ°
      level2.total_quantity += remainingQuantity
      level2.has_low_stock = level2.has_low_stock || isLowStock
      
      level1.total_quantity += remainingQuantity
      level1.has_low_stock = level1.has_low_stock || isLowStock
    })
    
    // ËÆ°ÁÆóÂä†ÊùÉÂπ≥Âùá‰ª∑Ê†ºÂπ∂ËΩ¨Êç¢‰∏∫Êï∞ÁªÑÁªìÊûÑ
    const processedData = Array.from(hierarchicalData.values()).map((level1: any) => {
      const specificationsArray = Array.from(level1.specifications.values()).map((level2: any) => {
        const qualitiesArray = Array.from(level2.qualities.values()).map((level3: any) => {
          // ËÆ°ÁÆóÂä†ÊùÉÂπ≥Âùá‰ª∑Ê†º
          let totalWeightedPriceUnit = 0
          let totalWeightedPriceGram = 0
          let totalWeightForUnit = 0
          let totalWeightForGram = 0
          
          level3.batches.forEach((batch: any) => {
            if (batch.price_per_unit && batch.original_quantity > 0) {
              totalWeightedPriceUnit += batch.price_per_unit * batch.original_quantity
              totalWeightForUnit += batch.original_quantity
            }
            if (batch.price_per_gram && batch.original_quantity > 0) {
              totalWeightedPriceGram += batch.price_per_gram * batch.original_quantity
              totalWeightForGram += batch.original_quantity
            }
          })
          
          return {
            quality: level3.quality,
            remaining_quantity: level3.remaining_quantity,
            is_low_stock: level3.is_low_stock,
            price_per_unit: req.user!.role === 'BOSS' && totalWeightForUnit > 0 
              ? Math.round((totalWeightedPriceUnit / totalWeightForUnit) * 100) / 100 
              : null,
            price_per_gram: req.user!.role === 'BOSS' && totalWeightForGram > 0 
              ? Math.round((totalWeightedPriceGram / totalWeightForGram) * 100) / 100 
              : null,
            batch_count: level3.batches.length,
            batches: level3.batches
          }
        })
        
        level2.total_variants = qualitiesArray.length
        return {
          specification_value: level2.specification_value,
          specification_unit: level2.specification_unit,
          total_quantity: level2.total_quantity,
          total_variants: level2.total_variants,
          has_low_stock: level2.has_low_stock,
          qualities: qualitiesArray
        }
      })
      
      level1.total_variants = specificationsArray.reduce((sum, spec) => sum + spec.total_variants, 0)
      return {
        material_type: level1.material_type,
        total_quantity: level1.total_quantity,
        total_variants: level1.total_variants,
        has_low_stock: level1.has_low_stock,
        specifications: specificationsArray
      }
    })
    
    // ÊéíÂ∫è
    const sortField = sort_by === 'material_type' ? 'material_type' : 'total_quantity'
    processedData.sort((a, b) => {
      if (sortField === 'material_type') {
        return sort === 'asc' ? a.material_type.locale_compare(b.material_type) : b.material_type.locale_compare(a.material_type)
      } else {
        return sort === 'asc' ? a.total_quantity - b.total_quantity : b.total_quantity - a.total_quantity
      }
    })
    
    console.log('‚úÖ [Â±ÇÁ∫ßÂºèÂ∫ìÂ≠òÊü•ËØ¢] Â§ÑÁêÜÂÆåÊàê:', {
      processedDataLength: processedData.length,
      firstProcessedItem: processedData[0]
    })
    
    // ÂàÜÈ°µ
    const total = processedData.length
    const paginatedData = processedData.slice(offset, offset + limitNum)
    
    res.json({
      success: true,
      message: 'Ëé∑ÂèñÂ±ÇÁ∫ßÂºèÂ∫ìÂ≠òÂàóË°®ÊàêÂäü',
      data: {
        hierarchy: paginatedData,
        pagination: {
          page: page_num,
          limit: limitNum,
          total: total,
          pages: Math.ceil(total / limitNum)
        }
      }
    })
  } catch (error) {
    console.error('‚ùå [Â±ÇÁ∫ßÂºèÂ∫ìÂ≠òÊü•ËØ¢] ÂèëÁîüÈîôËØØ:', error)
    res.status(500).json({
      success: false,
      message: 'Ëé∑ÂèñÂ±ÇÁ∫ßÂºèÂ∫ìÂ≠òÂàóË°®Â§±Ë¥•',
      error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ'
    })
  }
}))

// Ëé∑ÂèñÂàÜÁªÑÂ∫ìÂ≠òÂàóË°®ÔºàÊåâ‰∫ßÂìÅÂêçÁß∞ÂàÜÁªÑÔºâ
router.get('/grouped', authenticate_token, asyncHandler(async (req, res) => {// È™åËØÅÊü•ËØ¢ÂèÇÊï∞
  const validatedQuery = inventoryQuerySchema.parse(req.query)
  const {
    page = 1,
    limit = 10,
    search,
    quality,
    low_stock_only,
    sort = 'desc',
    sort_by = 'product_name'
  } = validatedQuery

  const page_num = parseInt(String(page))
  const limitNum = Math.min(parseInt(String(limit)), 100)
  const offset = (page_num - 1) * limitNum

  // ÊûÑÂª∫Êü•ËØ¢Êù°‰ª∂
  let whereClause = 'WHERE 1=1'
  const params: any[] = []

  if (search) {
    whereClause += ' AND p.product_name LIKE ?'
    params.push(`%${search}%`)
  }

  if (quality) {
    whereClause += ' AND p.quality = ?'
    params.push(quality)
  }

  if (lowStockOnly) {
    whereClause += ' AND (CASE WHEN p.material_type = "LOOSE_BEADS" THEN COALESCE(p.piece_count, 0) WHEN p.material_type = "BRACELET" THEN COALESCE(p.quantity, 0) WHEN p.material_type = "ACCESSORIES" THEN COALESCE(p.piece_count, 0) WHEN p.material_type = "FINISHED" THEN COALESCE(p.piece_count, 0) ELSE COALESCE(p.quantity, 0) END - COALESCE(mu.used_beads, 0)) <= p.min_stock_alert'
  }
  
  console.log('üîç [ÂàÜÁªÑÂ∫ìÂ≠òÊü•ËØ¢] ËØ∑Ê±ÇÂèÇÊï∞:', {page: page_num,
    limit: limitNum,
    search,
    quality,
    low_stock_only,
    whereClause,
    params
  })

  try {// Êü•ËØ¢ÂàÜÁªÑÂ∫ìÂ≠òÊï∞ÊçÆ - ‰ΩøÁî®‰∏§Ê≠•Êü•ËØ¢ÈÅøÂÖçJSON_ARRAYAGGÂÖºÂÆπÊÄßÈóÆÈ¢ò
    const groupedQuery = `
      SELECT 
        p.product_name as product_name,
        COUNT(DISTINCT CONCAT(
          COALESCE(p.bead_diameter, p.specification, 0), 
          '-', 
          COALESCE(p.quality, '')
        )) as variant_count,
        SUM(
          CASE 
            WHEN p.material_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
            WHEN p.material_type = 'BRACELET' THEN COALESCE(p.quantity, 0)
            WHEN p.material_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
            WHEN p.material_type = 'FINISHED' THEN COALESCE(p.piece_count, 0)
            ELSE COALESCE(p.quantity, 0)
          END - COALESCE(mu.used_beads, 0)
        ) as totalRemainingBeads,
        MAX(CASE WHEN p.min_stock_alert IS NOT NULL AND 
                     (CASE 
                       WHEN p.material_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
                       WHEN p.material_type = 'BRACELET' THEN COALESCE(p.quantity, 0)
                       WHEN p.material_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
                       WHEN p.material_type = 'FINISHED' THEN COALESCE(p.piece_count, 0)
                       ELSE COALESCE(p.quantity, 0)
                     END - COALESCE(mu.used_beads, 0)) <= p.min_stock_alert 
                THEN 1 ELSE 0 END) as hasLowStock
      FROM purchases p
      LEFT JOIN (
        SELECT purchase_id, SUM(quantity_used) as usedBeads
        FROM material_usage
        GROUP BY purchase_id
      ) mu ON p.id = mu.purchase_id
      ${whereClause}
      GROUP BY p.product_name
      ORDER BY ${sort_by === 'product_name' ? 'p.product_name' : 'totalRemainingBeads'} ${sort === 'asc' ? 'ASC' : 'DESC'}
      LIMIT ? OFFSET ?
    `

    // ËÆ°ÁÆóÊÄªÊï∞
    const countQuery = `
      SELECT COUNT(DISTINCT p.product_name) as total
      FROM purchases p
      LEFT JOIN material_usage mu ON p.id = mu.purchase_id
      ${whereClause}
    `

    console.log('üîç [ÂàÜÁªÑÂ∫ìÂ≠òÊü•ËØ¢] SQLÊü•ËØ¢ÂèÇÊï∞:', { params, limitNum, offset })
    const [groupedResult, countResult] = await Promise.all([
      prisma.$query_raw_unsafe(groupedQuery, ...params, limitNum, offset),
      prisma.$query_raw_unsafe(countQuery, ...params)
    ])

    const groupedInventory = groupedResult as any[]
    const total = (countResult as any[])[0].total
    
    console.log('üìä [ÂàÜÁªÑÂ∫ìÂ≠òÊü•ËØ¢] ÂéüÂßãÊü•ËØ¢ÁªìÊûú:', {
      groupedInventoryLength: groupedInventory.length,
      total: total,
      firstGroup: groupedInventory[0]
    })

    // ‰∏∫ÊØè‰∏™‰∫ßÂìÅÁªÑÊü•ËØ¢Âèò‰ΩìÊï∞ÊçÆ
    const processedGroups = await Promise.all(
      groupedInventory.map(async (group) => {// Êü•ËØ¢ËØ•‰∫ßÂìÅÁöÑÊâÄÊúâÈááË¥≠ËÆ∞ÂΩïÔºàÁî®‰∫éÂêàÂπ∂Áõ∏ÂêåËßÑÊ†ºÂìÅÁõ∏ÁöÑÂèò‰ΩìÔºâ
        const purchaseQuery = `
          SELECT 
            p.id as purchaseId,
            p.bead_diameter as bead_diameter,
            p.specification,
            p.quality,
            CASE 
              WHEN p.material_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
              WHEN p.material_type = 'BRACELET' THEN COALESCE(p.quantity, 0)
              WHEN p.material_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
              WHEN p.material_type = 'FINISHED' THEN COALESCE(p.piece_count, 0)
              ELSE COALESCE(p.quantity, 0)
            END as originalBeads,
            COALESCE(mu.used_beads, 0) as usedBeads,
            (CASE 
              WHEN p.material_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
              WHEN p.material_type = 'BRACELET' THEN COALESCE(p.quantity, 0)
              WHEN p.material_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
              WHEN p.material_type = 'FINISHED' THEN COALESCE(p.piece_count, 0)
              ELSE COALESCE(p.quantity, 0)
            END - COALESCE(mu.used_beads, 0)) as remainingBeads,
            CASE WHEN p.min_stock_alert IS NOT NULL AND 
                     (CASE 
                       WHEN p.material_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
                       WHEN p.material_type = 'BRACELET' THEN COALESCE(p.quantity, 0)
                       WHEN p.material_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
                       WHEN p.material_type = 'FINISHED' THEN COALESCE(p.piece_count, 0)
                       ELSE COALESCE(p.quantity, 0)
                     END - COALESCE(mu.used_beads, 0)) <= p.min_stock_alert 
                THEN 1 ELSE 0 END as is_low_stock,
            p.price_per_bead as price_per_bead,
            p.price_per_gram as price_per_gram,
            p.purchase_date as purchase_date,
            s.name as supplier_name
          FROM purchases p
          LEFT JOIN (
            SELECT purchase_id, SUM(quantity_used) as usedBeads
        FROM material_usage
        GROUP BY purchase_id
          ) mu ON p.id = mu.purchase_id
          LEFT JOIN suppliers s ON p.supplier_id = s.id
          WHERE p.bead_diameter IS NOT NULL AND p.product_name = ?
          ORDER BY p.bead_diameter, p.quality, p.purchase_date
        `
        
        const purchases = await prisma.$query_raw_unsafe(purchaseQuery, group.product_name) as any[]
        console.log(`üîç [ÈááË¥≠ËÆ∞ÂΩïÊü•ËØ¢] ‰∫ßÂìÅ"${group.product_name}"ÁöÑÈááË¥≠ËÆ∞ÂΩï:`, purchases)
        
        // ÊåâËßÑÊ†ºÂíåÂìÅÁõ∏ÂàÜÁªÑÂêàÂπ∂Âèò‰Ωì
        const variantMap = new Map()
        
        purchases.forEach((purchase: any) => {
          const specValue = purchase.bead_diameter || purchase.specification || 0
          const variantKey = `${specValue}-${purchase.quality || 'unknown'}`
          
          if (!variantMap.has(variantKey)) {
            variantMap.set(variantKey, {
              bead_diameter: purchase.bead_diameter ? Number(purchase.bead_diameter) : null,
              specification: purchase.specification ? Number(purchase.specification) : null,
              quality: purchase.quality,
              remaining_beads: 0,
              totalOriginalBeads: 0,
              is_low_stock: false,
              weightedPricePerBead: 0,
              weightedPricePerGram: 0,
              batches: []
            })
          }
          
          const variant = variantMap.get(variantKey)
          const remaining_beads = Number(purchase.remaining_beads)
          const originalBeads = Number(purchase.originalBeads)
          
          // Á¥ØÂä†Â∫ìÂ≠òÊï∞Èáè
          variant.remaining_beads += remainingBeads
          variant.totalOriginalBeads += originalBeads
          
          // Ê£ÄÊü•‰ΩéÂ∫ìÂ≠òÁä∂ÊÄÅ
          if (Number(purchase.is_low_stock) === 1) {
            variant.is_low_stock = true
          }
          
          // Ê∑ªÂä†ÊâπÊ¨°‰ø°ÊÅØ
          variant.batches.push({
            purchase_id: purchase.purchase_id,
            purchase_date: purchase.purchase_date,
            supplier_name: purchase.supplier_name,
            originalBeads: originalBeads,
            used_beads: Number(purchase.used_beads),
            remaining_beads: remainingBeads,
            price_per_bead: req.user!.role === 'BOSS' ? Number(purchase.price_per_bead) : null,
            price_per_gram: req.user!.role === 'BOSS' ? Number(purchase.price_per_gram) : null
          })
        })
        
        // ËÆ°ÁÆóÂä†ÊùÉÂπ≥Âùá‰ª∑Ê†ºÂπ∂ËΩ¨Êç¢‰∏∫Êï∞ÁªÑ
        const filteredVariants = Array.from(variantMap.values()).map((variant: any) => {
          let totalWeightedPriceBead = 0
          let totalWeightedPriceGram = 0
          let totalWeightForBead = 0
          let totalWeightForGram = 0
          
          // ËÆ°ÁÆóÂä†ÊùÉÂπ≥Âùá‰ª∑Ê†ºÔºàÊåâÂéüÂßãÂ∫ìÂ≠òÊï∞ÈáèÂä†ÊùÉÔºâ
          variant.batches.forEach((batch: any) => {
            if (batch.price_per_bead && batch.originalBeads > 0) {
              totalWeightedPriceBead += batch.price_per_bead * batch.originalBeads
              totalWeightForBead += batch.originalBeads
            }
            if (batch.price_per_gram && batch.originalBeads > 0) {
              totalWeightedPriceGram += batch.price_per_gram * batch.originalBeads
              totalWeightForGram += batch.originalBeads
            }
          })
          
          return {
            bead_diameter: variant.bead_diameter,
            quality: variant.quality,
            remaining_beads: variant.remaining_beads,
            is_low_stock: variant.is_low_stock,
            price_per_bead: req.user!.role === 'BOSS' && totalWeightForBead > 0 
              ? Math.round((totalWeightedPriceBead / totalWeightForBead) * 100) / 100 
              : null,
            price_per_gram: req.user!.role === 'BOSS' && totalWeightForGram > 0 
              ? Math.round((totalWeightedPriceGram / totalWeightForGram) * 100) / 100 
              : null,
            batch_count: variant.batches.length,
            batches: variant.batches
          }
        })
        
        console.log(`‚úÖ [Âèò‰ΩìÂêàÂπ∂] ‰∫ßÂìÅ"${group.product_name}"ÂêàÂπ∂ÂêéÁöÑÂèò‰Ωì:`, {
          originalPurchases: purchases.length,
          mergedVariants: filteredVariants.length,
          variants: filteredVariants.map(v => ({
            key: `${v.bead_diameter}mm-${v.quality}`,
            remaining_beads: v.remaining_beads,
            batch_count: v.batch_count,
            avgPricePerBead: v.price_per_bead
          }))
        })

        return {
          product_name: group.product_name,
          variant_count: Number(group.variant_count),
          totalRemainingBeads: Number(group.totalRemainingBeads),
          has_low_stock: Number(group.has_low_stock) === 1,
          variants: filteredVariants
        }
      })
    )

    console.log('‚úÖ [ÂàÜÁªÑÂ∫ìÂ≠òÊü•ËØ¢] ÊúÄÁªàÂ§ÑÁêÜÁªìÊûú:', {
      groupsCount: processedGroups.length,
      firstGroupData: processedGroups[0]
    })

    const responseData = {
      success: true,
      message: 'Ëé∑ÂèñÂàÜÁªÑÂ∫ìÂ≠òÂàóË°®ÊàêÂäü',
      data: {
        groups: processedGroups,
        pagination: {
          page: page_num,
          limit: limitNum,
          total: Number(total),
          pages: Math.ceil(Number(total) / limitNum)
        }
      }
    }
    
    console.log('üì§ [ÂàÜÁªÑÂ∫ìÂ≠òÊü•ËØ¢] Âç≥Â∞ÜÂèëÈÄÅÁöÑÂìçÂ∫îÊï∞ÊçÆ:', {
      success: responseData.success,
      message: responseData.message,
      dataKeys: Object.keys(responseData.data),
      groupsLength: responseData.data.groups.length,
      paginationInfo: responseData.data.pagination,
      timestamp: new Date().toISOString()
    })
    
    res.json(responseData)
  } catch (error) {
    console.error('‚ùå [ÂàÜÁªÑÂ∫ìÂ≠òÊü•ËØ¢] ÂèëÁîüÈîôËØØ:', {
      error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
      stack: error instanceof Error ? error.stack : undefined,
      params,
      whereClause,
      timestamp: new Date().toISOString()
    })
    res.status(500).json({
      success: false,
      message: 'Ëé∑ÂèñÂàÜÁªÑÂ∫ìÂ≠òÂàóË°®Â§±Ë¥•',
      error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ'
    })
  }
}))

// Ëé∑ÂèñÂ∫ìÂ≠òÂàóË°®ÔºàÂéüÊúâÊé•Âè£‰øùÊåÅÂÖºÂÆπÔºâ
router.get('/', authenticate_token, asyncHandler(async (req, res) => {const {
    page = 1,
    limit = 10,
    search,
    quality,
    low_stock_only,
    min_stock,
    max_stock,
    sort = 'desc',
    sort_by = 'purchase_date'
  } = req.query

  const page_num = parseInt(page as string)
  const limitNum = Math.min(parseInt(limit as string), 100)
  const offset = (page_num - 1) * limitNum

  // ÊûÑÂª∫Êü•ËØ¢Êù°‰ª∂
  let whereClause = 'WHERE p.bead_diameter IS NOT NULL'
  const params: any[] = []

  if (search) {
    whereClause += ' AND p.product_name LIKE ?'
    params.push(`%${search}%`)
  }

  if (quality) {
    whereClause += ' AND p.quality = ?'
    params.push(quality)
  }

  if (lowStockOnly) {
    whereClause += ' AND (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) <= p.min_stock_alert'
  }

  if (min_stock) {
    whereClause += ' AND (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) >= ?'
    params.push(parseInt(min_stock as string))
  }

  if (max_stock) {
    whereClause += ' AND (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) <= ?'
    params.push(parseInt(max_stock as string))
  }

  // ÊéíÂ∫è
  const validSortFields = ['purchase_date', 'created_at', 'remainingBeads', 'product_name']
  const sortField = validSortFields.includes(sort_by as string) ? sort_by : 'purchase_date'
  const sortDirection = sort === 'asc' ? 'ASC' : 'DESC'

  try {// Êü•ËØ¢Â∫ìÂ≠òÊï∞ÊçÆ
    const inventoryQuery = `
      SELECT 
        p.id as purchase_id,
        p.product_name as product_name,
        CONCAT(p.product_name, ' ', p.bead_diameter, 'mm ', COALESCE(p.quality, ''), 'Á∫ß') as bead_type,
        p.bead_diameter as bead_diameter,
        p.quality,
        p.min_stock_alert as min_stock_alert,
        p.total_beads as originalBeads,
        COALESCE(SUM(mu.quantity_used), 0) as usedBeads,
        (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) as remainingBeads,
        CASE 
          WHEN p.min_stock_alert IS NOT NULL AND 
               (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) <= p.min_stock_alert 
          THEN 1 
          ELSE 0 
        END as is_low_stock,
        p.price_per_bead as price_per_bead,
        p.price_per_gram as price_per_gram,
        s.name as supplier_name,
        p.purchase_date as purchase_date,
        p.photos,
        p.notes,
        p.created_at as created_at,
        p.updated_at as updated_at
      FROM purchases p
      LEFT JOIN material_usage mu ON p.id = mu.purchase_id
      LEFT JOIN suppliers s ON p.supplier_id = s.id
      ${whereClause}
      GROUP BY p.id, p.product_name, p.bead_diameter, p.quality, p.min_stock_alert, 
               p.total_beads, p.price_per_bead, p.price_per_gram, s.name, 
               p.purchase_date, p.photos, p.notes, p.created_at, p.updated_at
      ORDER BY ${sortField} ${sortDirection}
      LIMIT ? OFFSET ?
    `

    // ËÆ°ÁÆóÊÄªÊï∞
    const countQuery = `
      SELECT COUNT(DISTINCT p.id) as total
      FROM purchases p
      LEFT JOIN material_usage mu ON p.id = mu.purchase_id
      LEFT JOIN suppliers s ON p.supplier_id = s.id
      ${whereClause}
    `

    const [inventoryResult, countResult] = await Promise.all([
      prisma.$query_raw_unsafe(inventoryQuery, ...params, limitNum, offset),
      prisma.$query_raw_unsafe(countQuery, ...params)
    ])

    const inventory = inventoryResult as any[]
    const total = (countResult as any[])[0].total

    // ÊùÉÈôêËøáÊª§
    const filteredInventory = filterInventoryData(inventory, req.user!.role)

    res.json({
      success: true,
      message: 'Ëé∑ÂèñÂ∫ìÂ≠òÂàóË°®ÊàêÂäü',
      data: {
        items: filteredInventory,
        pagination: {
          page: page_num,
          limit: limitNum,
          total: Number(total),
          pages: Math.ceil(Number(total) / limitNum)
        }
      }
    })
  } catch (error) {
    console.error('Ëé∑ÂèñÂ∫ìÂ≠òÂàóË°®Â§±Ë¥•:', error)
    res.status(500).json({
      success: false,
      message: 'Ëé∑ÂèñÂ∫ìÂ≠òÂàóË°®Â§±Ë¥•'
    })
  }
}))

// Â∫ìÂ≠òÊêúÁ¥¢
router.get('/search', authenticate_token, asyncHandler(async (req, res) => {
  const { q: query, limit = 20 } = req.query

  if (!query) {
    return res.status(400).json({
      success: false,
      message: 'ÊêúÁ¥¢ÂÖ≥ÈîÆËØç‰∏çËÉΩ‰∏∫Á©∫'
    })
  }

  const limitNum = Math.min(parseInt(limit as string), 50)

  try {const searchQuery = `
      SELECT 
        p.id as purchase_id,
        p.product_name as product_name,
        CONCAT(p.product_name, ' ', p.bead_diameter, 'mm ', COALESCE(p.quality, ''), 'Á∫ß') as bead_type,
        p.bead_diameter as bead_diameter,
        p.quality,
        (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) as remainingBeads,
        CASE 
          WHEN p.min_stock_alert IS NOT NULL AND 
               (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) <= p.min_stock_alert 
          THEN 1 
          ELSE 0 
        END as is_low_stock,
        p.price_per_bead as price_per_bead,
        s.name as supplier_name,
        p.purchase_date as purchase_date
      FROM purchases p
      LEFT JOIN material_usage mu ON p.id = mu.purchase_id
      LEFT JOIN suppliers s ON p.supplier_id = s.id
      WHERE p.bead_diameter IS NOT NULL 
        AND (p.product_name LIKE ? OR s.name LIKE ?)
      GROUP BY p.id, p.product_name, p.bead_diameter, p.quality, p.min_stock_alert, 
               p.total_beads, p.price_per_bead, s.name, p.purchase_date
      ORDER BY remainingBeads DESC
      LIMIT ?
    `

    const searchPattern = `%${query}%`
    const results = await prisma.$query_raw_unsafe(
      searchQuery,
      searchPattern,
      searchPattern,
      limitNum
    ) as any[]

    // ÊùÉÈôêËøáÊª§
    const filteredResults = filterInventoryData(results, req.user!.role)

    res.json({
      success: true,
      message: 'ÊêúÁ¥¢ÊàêÂäü',
      data: {
        items: filteredResults,
        total: filteredResults.length
      }
    })
    return
  } catch (error) {
    console.error('Â∫ìÂ≠òÊêúÁ¥¢Â§±Ë¥•:', error)
    res.status(500).json({
      success: false,
      message: 'ÊêúÁ¥¢Â§±Ë¥•'
    })
    return
  }
}))

// ÊàêÂìÅÊü•ËØ¢ÂèÇÊï∞È™åËØÅschema
const finishedProductQuerySchema = z.object({page: z.string().regex(/^\d+$/, 'È°µÁ†ÅÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).refine(n => n >= 1, 'È°µÁ†ÅÂøÖÈ°ªÂ§ß‰∫é0').optional(),
  limit: z.string().regex(/^\d+$/, 'ÊØèÈ°µÊï∞ÈáèÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).refine(n => n >= 1 && n <= 100, 'ÊØèÈ°µÊï∞ÈáèÂøÖÈ°ªÂú®1-100‰πãÈó¥').optional(),
  search: z.string().max(100, 'ÊêúÁ¥¢ÂÖ≥ÈîÆËØç‰∏çËÉΩË∂ÖËøá100Â≠óÁ¨¶').optional(),
  quality: quality_schema.optional(),
  low_stock_only: z.string().transform(s => s === 'true').optional(),
  specification_min: z.string().regex(/^\d+(\.\d+)?$/, 'ÊúÄÂ∞èËßÑÊ†ºÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).optional(),
  specification_max: z.string().regex(/^\d+(\.\d+)?$/, 'ÊúÄÂ§ßËßÑÊ†ºÂøÖÈ°ªÊòØÊï∞Â≠ó').transform(Number).optional(),
  sort: z.enum(['asc', 'desc']).optional(),
  sort_by: z.enum(['purchase_date', 'product_name', 'specification', 'remaining_quantity']).optional()
}).refine((data) => {
  if (data.specification_min && data.specification_max && data.specification_min > data.specification_max) {
    throw new Error('ÊúÄÂ∞èËßÑÊ†º‰∏çËÉΩÂ§ß‰∫éÊúÄÂ§ßËßÑÊ†º')
  }
  return true
})

// Ëé∑ÂèñÊàêÂìÅÂç°ÁâáÊï∞ÊçÆÔºà‰∏ìÁî®‰∫éÊàêÂìÅÂ±ïÁ§∫Ôºâ
router.get('/finished-products-cards', authenticate_token, asyncHandler(async (req, res) => {// È™åËØÅÊü•ËØ¢ÂèÇÊï∞
  const validatedQuery = finishedProductQuerySchema.parse(req.query)
  const {
    page = 1,
    limit = 20,
    search,
    quality,
    low_stock_only,
    specification_min,
    specification_max,
    sort = 'desc',
    sort_by = 'purchase_date'
  } = validatedQuery

  const page_num = parseInt(String(page))
  const limitNum = Math.min(parseInt(String(limit)), 100)
  const offset = (page_num - 1) * limitNum

  console.log('üéØ [ÊàêÂìÅÂç°ÁâáÊü•ËØ¢] ËØ∑Ê±ÇÂèÇÊï∞:', {page: page_num,
    limit: limitNum,
    search,
    quality,
    low_stock_only,
    specification_min,
    specification_max
  })

  try {
    // ÊûÑÂª∫Êü•ËØ¢Êù°‰ª∂
    let whereConditions = ['p.material_type = "FINISHED"']
    let queryParams: any[] = []

    // ÊêúÁ¥¢Êù°‰ª∂
    if (search) {
      whereConditions.push('(p.product_name LIKE ? OR s.name LIKE ?)')
      const searchPattern = `%${search}%`
      queryParams.push(searchPattern, searchPattern)
    }

    // ÂìÅÁõ∏Á≠õÈÄâ
    if (quality) {
      whereConditions.push('p.quality = ?')
      queryParams.push(quality)
    }

    // ËßÑÊ†ºËåÉÂõ¥Á≠õÈÄâ
    if (specificationMin) {
      whereConditions.push('p.specification >= ?')
      queryParams.push(Number(specification_min))
    }
    if (specificationMax) {
      whereConditions.push('p.specification <= ?')
      queryParams.push(Number(specification_max))
    }

    // ÊûÑÂª∫ÊéíÂ∫èÊù°‰ª∂
    let order_by = 'p.purchase_date DESC'
    if (sort_by === 'product_name') {
      order_by = `p.product_name ${sort === 'asc' ? 'ASC' : 'DESC'}`
    } else if (sort_by === 'specification') {
      order_by = `p.specification ${sort === 'asc' ? 'ASC' : 'DESC'}`
    } else if (sort_by === 'remaining_quantity') {order_by = `remaining_quantity ${sort === 'asc' ? 'ASC' : 'DESC'}`
    }

    // ‰∏ªÊü•ËØ¢SQL
    const finishedProductsQuery = `
      SELECT 
        p.id as purchaseId,
        p.purchase_code as purchase_code,
        p.product_name as product_name,
        p.specification,
        p.piece_count as piece_count,
        p.quality,
        p.photos,
        CASE 
          WHEN ${req.user!.role === 'BOSS' ? 'TRUE' : 'FALSE'} THEN 
            CASE 
              WHEN p.material_type = 'FINISHED' AND p.piece_count > 0 AND p.total_price IS NOT NULL 
              THEN ROUND(p.total_price / p.piece_count, 2)
              ELSE p.unit_price
            END
          ELSE NULL
        END as pricePerUnit,
        CASE 
          WHEN ${req.user!.role === 'BOSS' ? 'TRUE' : 'FALSE'} THEN p.total_price
          ELSE NULL
        END as total_price,
        s.name as supplier_name,
        p.purchase_date as purchase_date,
        COALESCE(p.piece_count, 0) as originalQuantity,
        COALESCE(mu.used_quantity, 0) as usedQuantity,
        (COALESCE(p.piece_count, 0) - COALESCE(mu.used_quantity, 0)) as remainingQuantity,
        CASE 
          WHEN p.min_stock_alert IS NOT NULL AND 
               (COALESCE(p.piece_count, 0) - COALESCE(mu.used_quantity, 0)) <= p.min_stock_alert 
          THEN 1 
          ELSE 0 
        END as isLowStock,
        p.created_at as created_at,
        p.updated_at as updated_at
      FROM purchases p
      LEFT JOIN (
        SELECT purchaseId, SUM(quantity_used) as usedQuantity
        FROM material_usage
        GROUP BY purchaseId
      ) mu ON p.id = mu.purchase_id
      LEFT JOIN suppliers s ON p.supplier_id = s.id
      WHERE ${whereConditions.join(' AND ')}
      ${low_stock_only ? 'HAVING is_low_stock = 1' : ''}
      ORDER BY ${order_by}
      LIMIT ? OFFSET ?
    `

    // ËÆ°Êï∞Êü•ËØ¢SQL
    const countQuery = `
      SELECT COUNT(*) as total
      FROM purchases p
      LEFT JOIN (
        SELECT purchaseId, SUM(quantity_used) as usedQuantity
        FROM material_usage
        GROUP BY purchaseId
      ) mu ON p.id = mu.purchase_id
      LEFT JOIN suppliers s ON p.supplier_id = s.id
      WHERE ${whereConditions.join(' AND ')}
      ${low_stock_only ? 'HAVING (COALESCE(p.piece_count, 0) - COALESCE(mu.used_quantity, 0)) <= COALESCE(p.min_stock_alert, 0)' : ''}
    `

    console.log('üîç [ÊàêÂìÅÂç°ÁâáÊü•ËØ¢] SQLÊü•ËØ¢ÂèÇÊï∞:', { queryParams, limitNum, offset })

    // ÊâßË°åÊü•ËØ¢
    const [products, countResult] = await Promise.all([
      prisma.$query_raw_unsafe(finishedProductsQuery, ...queryParams, limitNum, offset),
      prisma.$query_raw_unsafe(countQuery, ...queryParams)
    ])

    const total = Number((countResult as any[])[0]?.total || 0)
    const total_pages = Math.ceil(total / limitNum)

    // ËΩ¨Êç¢Êï∞ÊçÆÊ†ºÂºè
    const convertedProducts = (products as any[]).map(item => {
      const converted = { ...item }
      
      // ËΩ¨Êç¢BigIntÂ≠óÊÆµÔºà‰ΩÜ‰∏çËΩ¨Êç¢purchaseIdÔºåÂõ†‰∏∫ÂÆÉÊòØÂ≠óÁ¨¶‰∏≤UUIDÔºâ
      const bigIntFields = [
        'specification', 'piece_count', 'original_quantity',
        'used_quantity', 'remaining_quantity', 'is_low_stock'
      ]
      
      bigIntFields.forEach(field => {
        if (converted[field] !== null && converted[field] !== undefined) {
          converted[field] = Number(converted[field])
        }
      })
      
      // purchaseId‰øùÊåÅÂéüÂßãÂ≠óÁ¨¶‰∏≤Ê†ºÂºèÔºå‰∏çËøõË°åÊï∞Â≠óËΩ¨Êç¢
      // Âõ†‰∏∫ÂÆÉÊòØUUIDÂ≠óÁ¨¶‰∏≤ÔºåËΩ¨Êç¢‰∏∫Number‰ºöÂèòÊàêNaN
      
      // ËΩ¨Êç¢‰ª∑Ê†ºÂ≠óÊÆµ
      const priceFields = ['price_per_unit', 'total_price']
      priceFields.forEach(field => {
        if (converted[field] !== null && converted[field] !== undefined) {
          converted[field] = Number(converted[field])
        }
      })
      
      // Â§ÑÁêÜphotosÂ≠óÊÆµ
      if (converted.photos) {
        try {
          converted.photos = typeof converted.photos === 'string' 
            ? JSON.parse(converted.photos) 
            : converted.photos
        } catch (e) {
          converted.photos = []
        }
      } else {
        converted.photos = []
      }
      
      return converted
    })

    console.log('üìä [ÊàêÂìÅÂç°ÁâáÊü•ËØ¢] Êü•ËØ¢ÁªìÊûú:', {
      productsLength: convertedProducts.length,
      total,
      total_pages,
      current_page: page_num
    })
    
    console.log('üîç [ÊàêÂìÅÂç°ÁâáÊü•ËØ¢] ÂéüÂßãÊü•ËØ¢Êï∞ÊçÆÔºàÂâç3‰∏™Ôºâ:', (products as any[]).slice(0, 3).map(item => ({
      purchase_id: item.purchase_id,
      product_name: item.product_name,
      purchaseIdType: typeof item.purchase_id
    })))
    
    console.log('üîç [ÊàêÂìÅÂç°ÁâáÊü•ËØ¢] ËΩ¨Êç¢ÂêéÊï∞ÊçÆÔºàÂâç3‰∏™Ôºâ:', convertedProducts.slice(0, 3).map(item => ({
      purchase_id: item.purchase_id,
      product_name: item.product_name,
      purchaseIdType: typeof item.purchase_id
    })))

    res.json({
      success: true,
      message: 'Ëé∑ÂèñÊàêÂìÅÊï∞ÊçÆÊàêÂäü',
      data: {
        products: convertedProducts,
        pagination: {
          current_page: page_num,
          perPage: limitNum,
          total: total,
          total_pages: total_pages,
          hasNext: page_num < total_pages,
          hasPrev: page_num > 1
        }
      }
    })
  } catch (error) {
    console.error('‚ùå [ÊàêÂìÅÂç°ÁâáÊü•ËØ¢] Êü•ËØ¢Â§±Ë¥•:', error)
    res.status(500).json(
      ErrorResponses.internal('Ëé∑ÂèñÊàêÂìÅÊï∞ÊçÆÂ§±Ë¥•', error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ')
    )
  }
}))

// Ëé∑ÂèñÂ∫ìÂ≠òÁªüËÆ°Êï∞ÊçÆÔºà‰ª™Ë°®ÁõòÔºâ
router.get('/statistics', authenticate_token, asyncHandler(async (req, res) => {
  console.log('üîç [Â∫ìÂ≠òÁªüËÆ°] Êé•Êî∂Âà∞statisticsËØ∑Ê±Ç:', {
    method: req.method,
    path: req.path,
    user: req.user?.user_name,
    timestamp: new Date().toISOString()
  })
  
  try {// ‰øÆÂ§çÁöÑÁªüËÆ°Êü•ËØ¢ÔºåÈÅøÂÖçÂµåÂ•óËÅöÂêàÂáΩÊï∞
    const basicStatsQuery = `
      SELECT 
        p.material_type as material_type,
        COUNT(DISTINCT p.id) as totalItems,
        SUM(CASE 
          WHEN p.material_type = 'LOOSE_BEADS' THEN (p.piece_count - COALESCE(mu.used_quantity, 0))
          WHEN p.material_type = 'BRACELET' THEN (p.total_beads - COALESCE(mu.used_quantity, 0))
          WHEN p.material_type = 'ACCESSORIES' THEN (p.piece_count - COALESCE(mu.used_quantity, 0))
          WHEN p.material_type = 'FINISHED' THEN (p.piece_count - COALESCE(mu.used_quantity, 0))
          ELSE 0
        END) as total_quantity
      FROM purchases p
      LEFT JOIN (
        SELECT purchase_id, SUM(quantity_used) as used_quantity
        FROM material_usage
        GROUP BY purchase_id
      ) mu ON p.id = mu.purchase_id
      GROUP BY p.material_type
      ORDER BY p.material_type
    `

    // ÊâßË°åÂü∫Á°ÄÁªüËÆ°Êü•ËØ¢
    console.log('üîç [Â∫ìÂ≠òÁªüËÆ°] ÊâßË°åSQLÊü•ËØ¢...')
    const typeStats = await prisma.$query_raw_unsafe(basicStatsQuery)
    console.log('üìä [Â∫ìÂ≠òÁªüËÆ°] Êü•ËØ¢ÁªìÊûú:', {
      length: (typeStats as any[]).length,
      data: typeStats
    })
    
    // ËΩ¨Êç¢BigIntÂ≠óÊÆµÂπ∂Â∫îÁî®Â≠óÊÆµÊ†ºÂºèËΩ¨Êç¢
    const convertBigInt = (data: any[]) => {
      return data.map(item => {
        // ÂÖàËΩ¨Êç¢BigInt‰∏∫Number
        const converted = { ...item }
        Object.keys(converted).forEach(key => {
          if (typeof converted[key] === 'bigint') {
            converted[key] = Number(converted[key])
          }
        })
        console.log('üîß [Â∫ìÂ≠òÁªüËÆ°] BigIntËΩ¨Êç¢ÂêéÁöÑÈ°πÁõÆ:', converted)
        // ÁÑ∂ÂêéËΩ¨Êç¢Â≠óÊÆµÂêç‰∏∫snake_caseÔºàAPIÊ†ºÂºèÔºâ
        return convertToApiFormat(converted)
      })
    }

    // ËÆ°ÁÆóÊÄª‰ΩìÁªüËÆ°
    const totalStats = {
      totalItems: (typeStats as any[]).reduce((sum, item) => sum + Number(item.totalItems), 0),
      total_quantity: (typeStats as any[]).reduce((sum, item) => sum + Number(item.total_quantity), 0)
    }
    console.log('üìä [Â∫ìÂ≠òÁªüËÆ°] ÊÄª‰ΩìÁªüËÆ°:', totalStats)

    const responseData = {
      totalStats: totalStats,
      typeStatistics: convertBigInt(typeStats as any[])
    }
    console.log('üìä [Â∫ìÂ≠òÁªüËÆ°] ÂìçÂ∫îÊï∞ÊçÆ:', responseData)

    // ‰ΩøÁî®convertToApiFormatÁ°Æ‰øùÂ≠óÊÆµÊ†ºÂºèÁ¨¶ÂêàAPIËßÑËåÉ
    const convertedData = convertToApiFormat(responseData)
    console.log('üìä [Â∫ìÂ≠òÁªüËÆ°] ËΩ¨Êç¢ÂêéÊï∞ÊçÆ:', convertedData)

    res.json({
      success: true,
      message: 'Ëé∑ÂèñÂ∫ìÂ≠òÁªüËÆ°Êï∞ÊçÆÊàêÂäü',
      data: convertedData
    })
  } catch (error) {
    console.error('‚ùå [Â∫ìÂ≠òÁªüËÆ°] Êü•ËØ¢Â§±Ë¥•:', error)
    res.status(500).json(
      ErrorResponses.internal('Ëé∑ÂèñÂ∫ìÂ≠òÁªüËÆ°Êï∞ÊçÆÂ§±Ë¥•', error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ')
    )
  }
}))

// Ëé∑Âèñ‰∫ßÂìÅÂàÜÂ∏ÉÊï∞ÊçÆÔºàÁî®‰∫éÈ•ºÂõæÔºâ
router.get('/product-distribution', authenticate_token, asyncHandler(async (req, res) => {
  console.log('üîç [‰∫ßÂìÅÂàÜÂ∏É] Êé•Êî∂Âà∞product-distributionËØ∑Ê±Ç:', {
    method: req.method,
    path: req.path,
    query: req.query,
    user: req.user?.user_name,
    timestamp: new Date().toISOString()
  })
  
  try {
    const { material_type, limit = 20 } = req.query
    
    // ÊûÑÂª∫Êü•ËØ¢Êù°‰ª∂
    let whereClause = ''
    if (material_type && material_type !== 'ALL') {
      whereClause = `WHERE p.material_type = '${material_type}'`
    }
    
    // Êü•ËØ¢‰∫ßÂìÅÂàÜÂ∏ÉÊï∞ÊçÆÔºàÂâçNÂêç + ÂÖ∂‰ªñÔºâ
    const distributionQuery = `
      SELECT 
        p.product_name as product_name,
        p.material_type as material_type,
        SUM(CASE 
          WHEN p.material_type = 'LOOSE_BEADS' THEN (p.piece_count - COALESCE(mu.used_quantity, 0))
          WHEN p.material_type = 'BRACELET' THEN (p.total_beads - COALESCE(mu.used_quantity, 0))
          WHEN p.material_type = 'ACCESSORIES' THEN (p.piece_count - COALESCE(mu.used_quantity, 0))
          WHEN p.material_type = 'FINISHED' THEN (p.piece_count - COALESCE(mu.used_quantity, 0))
          ELSE 0
        END) as total_quantity
      FROM purchases p
      LEFT JOIN (
        SELECT purchaseId, SUM(quantity_used) as usedQuantity
        FROM material_usage
        GROUP BY purchaseId
      ) mu ON p.id = mu.purchase_id
      ${whereClause}
      GROUP BY p.product_name, p.material_type
      HAVING total_quantity > 0
      ORDER BY total_quantity DESC
    `

    console.log('üîç [‰∫ßÂìÅÂàÜÂ∏É] ÊâßË°åSQLÊü•ËØ¢:', distributionQuery)
    const allProducts = await prisma.$query_raw_unsafe(distributionQuery) as any[]
    console.log('üìä [‰∫ßÂìÅÂàÜÂ∏É] Êü•ËØ¢ÁªìÊûú:', {
      length: allProducts.length,
      sample: allProducts.slice(0, 3)
    })
    
    // ËΩ¨Êç¢BigIntÂ≠óÊÆµ
    const convertedProducts = allProducts.map(item => {
      const converted = { ...item }
      Object.keys(converted).forEach(key => {
        if (typeof converted[key] === 'bigint') {
          converted[key] = Number(converted[key])
        }
      })
      return converted
    })
    
    // ËÆ°ÁÆóËØ•‰∫ßÂìÅÁ±ªÂûãÁöÑÊÄªÊï∞ÈáèÔºàÁ°Æ‰øùÊï∞Â≠óÁõ∏Âä†ËÄå‰∏çÊòØÂ≠óÁ¨¶‰∏≤ÊãºÊé•Ôºâ
    const total_quantity = convertedProducts.reduce((sum, item) => {
      const quantity = Number(item.total_quantity) || 0
      return sum + quantity
    }, 0)
    
    // Ëé∑ÂèñÂâçNÂêç‰∫ßÂìÅ
    const topProducts = convertedProducts.slice(0, parseInt(limit as string))
    const topQuantity = topProducts.reduce((sum, item) => sum + item.total_quantity, 0)
    
    // ËÆ°ÁÆóÂÖ∂‰ªñ‰∫ßÂìÅÁöÑÊï∞Èáè
    const othersQuantity = total_quantity - topQuantity
    
    // ÊûÑÂª∫È•ºÂõæÊï∞ÊçÆ - ÁôæÂàÜÊØîÂü∫‰∫éËØ•‰∫ßÂìÅÁ±ªÂûãÁöÑÊÄªÈáèËÆ°ÁÆó
    const pieChartData = topProducts.map(item => ({
      name: item.product_name,
      value: item.total_quantity,
      percentage: ((item.total_quantity / total_quantity) * 100).toFixed(1)
    }))
    
    // Â¶ÇÊûúÊúâÂÖ∂‰ªñ‰∫ßÂìÅÔºåÊ∑ªÂä†Âà∞Êï∞ÊçÆ‰∏≠
    if (othersQuantity > 0) {
      pieChartData.push({
        name: 'ÂÖ∂‰ªñ',
        value: othersQuantity,
        percentage: ((othersQuantity / total_quantity) * 100).toFixed(1)
      })
    }
    
    const responseData = {
      total_quantity: total_quantity,
      topProductsCount: topProducts.length,
      othersCount: convertedProducts.length - topProducts.length,
      topProducts: pieChartData
    }
    
    console.log('üìä [‰∫ßÂìÅÂàÜÂ∏É] ÂìçÂ∫îÊï∞ÊçÆ:', responseData)
    
    // ‰ΩøÁî®convertToApiFormatÁ°Æ‰øùÂ≠óÊÆµÊ†ºÂºèÁ¨¶ÂêàAPIËßÑËåÉ
    const convertedData = convertToApiFormat(responseData)
    
    res.json({
      success: true,
      message: 'Ëé∑Âèñ‰∫ßÂìÅÂàÜÂ∏ÉÊï∞ÊçÆÊàêÂäü',
      data: convertedData
    })
  } catch (error) {
    console.error('‚ùå [‰∫ßÂìÅÂàÜÂ∏É] Êü•ËØ¢Â§±Ë¥•:', error)
    res.status(500).json(
      ErrorResponses.internal('Ëé∑Âèñ‰∫ßÂìÅÂàÜÂ∏ÉÊï∞ÊçÆÂ§±Ë¥•', error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ')
    )
  }
}))

// Ëé∑ÂèñÂ∫ìÂ≠òÊ∂àËÄóÂàÜÊûê
router.get('/consumption-analysis', authenticate_token, asyncHandler(async (req, res) => {
  const { time_range = 'all', limit = 10 } = req.query

  console.log('üîç [Â∫ìÂ≠òÊ∂àËÄóÂàÜÊûê] ËØ∑Ê±ÇÂèÇÊï∞:', {
    time_range,
    limit,
    userRole: req.user!.role
  })

  try {
    // ÊûÑÂª∫Êó∂Èó¥Á≠õÈÄâÊù°‰ª∂
    let timeCondition = ''
    const now = new Date()
    
    switch (time_range) {
      case '7d':
        const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
        timeCondition = `AND mu.created_at >= '${sevenDaysAgo.toISOString()}'`
        break
      case '30d':
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
        timeCondition = `AND mu.created_at >= '${thirtyDaysAgo.toISOString()}'`
        break
      case '90d':
        const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000)
        timeCondition = `AND mu.created_at >= '${ninetyDaysAgo.toISOString()}'`
        break
      case '6m':
        const sixMonthsAgo = new Date(now.getTime() - 6 * 30 * 24 * 60 * 60 * 1000)
        timeCondition = `AND mu.created_at >= '${sixMonthsAgo.toISOString()}'`
        break
      case '1y':
        const oneYearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000)
        timeCondition = `AND mu.created_at >= '${oneYearAgo.toISOString()}'`
        break
      case 'all':
      default:
        timeCondition = ''
        break
    }

    // Êü•ËØ¢Â∫ìÂ≠òÊ∂àËÄóÁªüËÆ°Êï∞ÊçÆ
    const consumptionQuery = `
      SELECT 
        p.id as purchaseId,
        p.product_name as product_name,
        p.material_type as material_type,
        p.bead_diameter as bead_diameter,
        p.specification,
        p.quality,
        s.name as supplier_name,
        SUM(
          CASE 
            WHEN p.material_type IN ('LOOSE_BEADS', 'BRACELET') THEN mu.quantity_used
        WHEN p.material_type IN ('ACCESSORIES', 'FINISHED') THEN mu.quantity_used
            ELSE 0
          END
        ) as total_consumed,
        COUNT(mu.id) as consumption_count,
        AVG(
          CASE 
            WHEN p.material_type IN ('LOOSE_BEADS', 'BRACELET') THEN mu.quantity_used
        WHEN p.material_type IN ('ACCESSORIES', 'FINISHED') THEN mu.quantity_used
            ELSE 0
          END
        ) as avg_consumption,
        MAX(mu.created_at) as last_consumption_date,
        MIN(mu.created_at) as first_consumption_date,
        CASE 
          WHEN p.material_type IN ('LOOSE_BEADS', 'BRACELET') THEN 'È¢ó'
          WHEN p.material_type IN ('ACCESSORIES', 'FINISHED') THEN '‰ª∂'
          ELSE '‰∏™'
        END as unit_type
      FROM material_usage mu
      INNER JOIN purchases p ON mu.purchase_id = p.id
      LEFT JOIN suppliers s ON p.supplier_id = s.id
      WHERE 1=1 ${timeCondition}
        AND (
          (p.material_type IN ('LOOSE_BEADS', 'BRACELET') AND mu.quantity_used > 0) OR
      (p.material_type IN ('ACCESSORIES', 'FINISHED') AND mu.quantity_used > 0)
        )
      GROUP BY p.id, p.product_name, p.material_type, p.bead_diameter, p.specification, p.quality, s.name
      ORDER BY total_consumed DESC
      LIMIT ?
    `

    console.log('üîç [Â∫ìÂ≠òÊ∂àËÄóÂàÜÊûê] ÊâßË°åSQLÊü•ËØ¢:', consumptionQuery)
    const consumptionData = await prisma.$query_raw_unsafe(consumptionQuery, parseInt(limit as string)) as any[]
    
    console.log('üìä [Â∫ìÂ≠òÊ∂àËÄóÂàÜÊûê] Êü•ËØ¢ÁªìÊûú:', {
      length: consumptionData.length,
      sample: consumptionData.slice(0, 3)
    })

    // ËΩ¨Êç¢BigIntÂ≠óÊÆµ
    const convertedData = consumptionData.map(item => {
      const converted = { ...item }
      Object.keys(converted).forEach(key => {
        if (typeof converted[key] === 'bigint') {
          converted[key] = Number(converted[key])
        }
      })
      return converted
    })

    // ËÆ°ÁÆóÊÄª‰ΩìÁªüËÆ°
    const totalConsumption = convertedData.reduce((sum, item) => sum + Number(item.total_consumed), 0)
    const totalConsumptionCount = convertedData.reduce((sum, item) => sum + Number(item.consumption_count), 0)

    const responseData = {
      time_range,
      totalConsumption: totalConsumption,
      totalConsumptionCount: totalConsumptionCount,
      topConsumedProducts: convertedData,
      analysisDate: new Date().toISOString()
    }

    console.log('üìä [Â∫ìÂ≠òÊ∂àËÄóÂàÜÊûê] ÂìçÂ∫îÊï∞ÊçÆ:', responseData)

    // ÊùÉÈôêËøáÊª§ÔºàÈõáÂëò‰∏çËÉΩÊü•Áúã‰æõÂ∫îÂïÜÂíå‰ª∑Ê†º‰ø°ÊÅØÔºâ
    if (req.user!.role === 'EMPLOYEE') {
      responseData.topConsumedProducts = responseData.topConsumedProducts.map(item => ({
        ...item,
        supplier_name: null
      }))
    }

    res.json({
      success: true,
      message: 'Ëé∑ÂèñÂ∫ìÂ≠òÊ∂àËÄóÂàÜÊûêÊàêÂäü',
      data: responseData
    })
  } catch (error) {
    console.error('‚ùå [Â∫ìÂ≠òÊ∂àËÄóÂàÜÊûê] Êü•ËØ¢Â§±Ë¥•:', error)
    res.status(500).json(
      ErrorResponses.internal('Ëé∑ÂèñÂ∫ìÂ≠òÊ∂àËÄóÂàÜÊûêÂ§±Ë¥•', error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ')
    )
  }
}))

// Ëé∑Âèñ‰∫ßÂìÅ‰ª∑Ê†ºÂàÜÂ∏É
router.get('/price-distribution', authenticate_token, asyncHandler(async (req, res) => {
  const { 
    material_type = 'LOOSE_BEADS', 
    price_type = 'unit_price', 
    limit = 10 
  } = req.query

  console.log('üîç [‰∫ßÂìÅ‰ª∑Ê†ºÂàÜÂ∏É] ËØ∑Ê±ÇÂèÇÊï∞:', {
    material_type,
    price_type,
    limit,
    userRole: req.user!.role
  })

  try {
    // ÊûÑÂª∫‰∫ßÂìÅÁ±ªÂûãÁ≠õÈÄâÊù°‰ª∂
    let materialTypeCondition = ''
    if (material_type && material_type !== 'ALL') {
      material_typeCondition = `AND p.material_type = '${material_type}'`
    }

    // Ê†πÊçÆ‰ª∑Ê†ºÁ±ªÂûãÈÄâÊã©‰∏çÂêåÁöÑÂ§ÑÁêÜÈÄªËæë
    if (price_type === 'unit_price') {
      // Âçï‰ª∑ÂàÜÂ∏É - ËøîÂõû‰ª∑Ê†ºÂå∫Èó¥ÁªüËÆ°
      const priceRangeQuery = `
        SELECT 
           CASE 
             -- ÊàêÂìÅÁ±ªÂûã‰ΩøÁî®‰∏ìÈó®ÁöÑ‰ª∑Ê†ºÂå∫Èó¥
             WHEN material_type = 'FINISHED' AND calculated_price >= 0 AND calculated_price <= 50 THEN '0-50ÂÖÉÔºàÂê´Ôºâ'
             WHEN material_type = 'FINISHED' AND calculated_price > 50 AND calculated_price <= 100 THEN '50-100ÂÖÉÔºàÂê´Ôºâ'
             WHEN material_type = 'FINISHED' AND calculated_price > 100 AND calculated_price <= 200 THEN '100-200ÂÖÉÔºàÂê´Ôºâ'
             WHEN material_type = 'FINISHED' AND calculated_price > 200 AND calculated_price <= 500 THEN '200-500ÂÖÉÔºàÂê´Ôºâ'
             WHEN material_type = 'FINISHED' AND calculated_price > 500 THEN '500ÂÖÉ‰ª•‰∏ä'
             -- ÂÖ∂‰ªñ‰∫ßÂìÅÁ±ªÂûã‰ΩøÁî®ÂéüÊúâ‰ª∑Ê†ºÂå∫Èó¥
             WHEN material_type != 'FINISHED' AND calculated_price >= 0 AND calculated_price <= 3 THEN '0-3ÂÖÉÔºàÂê´Ôºâ'
             WHEN material_type != 'FINISHED' AND calculated_price > 3 AND calculated_price <= 10 THEN '3-10ÂÖÉÔºàÂê´Ôºâ'
             WHEN material_type != 'FINISHED' AND calculated_price > 10 AND calculated_price <= 20 THEN '10-20ÂÖÉÔºàÂê´Ôºâ'
             WHEN material_type != 'FINISHED' AND calculated_price > 20 AND calculated_price <= 50 THEN '20-50ÂÖÉÔºàÂê´Ôºâ'
             WHEN material_type != 'FINISHED' AND calculated_price > 50 THEN '50ÂÖÉ‰ª•‰∏ä'
             ELSE 'Êú™Áü•'
           END as price_range,
          COUNT(*) as count
        FROM (          SELECT             p.material_type as material_type,            CASE               WHEN p.material_type = 'LOOSE_BEADS' AND p.total_beads > 0 THEN p.total_price / p.total_beads              WHEN p.material_type = 'BRACELET' AND p.quantity > 0 THEN p.total_price / p.quantity              WHEN p.material_type = 'ACCESSORIES' AND p.piece_count > 0 THEN p.total_price / p.piece_count              WHEN p.material_type = 'FINISHED' AND p.piece_count > 0 THEN p.total_price / p.piece_count              ELSE NULL            END as calculated_price          FROM purchases p          WHERE p.status IN ('ACTIVE', 'PENDING')             AND p.total_price IS NOT NULL             AND p.total_price > 0            AND (              (p.material_type = 'LOOSE_BEADS' AND p.total_beads IS NOT NULL AND p.total_beads > 0) OR              (p.material_type = 'BRACELET' AND p.quantity IS NOT NULL AND p.quantity > 0) OR              (p.material_type = 'ACCESSORIES' AND p.piece_count IS NOT NULL AND p.piece_count > 0) OR              (p.material_type = 'FINISHED' AND p.piece_count IS NOT NULL AND p.piece_count > 0)            )            ${material_typeCondition}        ) as priceData
        WHERE calculated_price IS NOT NULL
        GROUP BY price_range
        ORDER BY 
           CASE price_range
             -- ÊàêÂìÅÁ±ªÂûãÊéíÂ∫è
             WHEN '0-50ÂÖÉÔºàÂê´Ôºâ' THEN 1
             WHEN '50-100ÂÖÉÔºàÂê´Ôºâ' THEN 2
             WHEN '100-200ÂÖÉÔºàÂê´Ôºâ' THEN 3
             WHEN '200-500ÂÖÉÔºàÂê´Ôºâ' THEN 4
             WHEN '500ÂÖÉ‰ª•‰∏ä' THEN 5
             -- ÂÖ∂‰ªñ‰∫ßÂìÅÁ±ªÂûãÊéíÂ∫è
             WHEN '0-3ÂÖÉÔºàÂê´Ôºâ' THEN 6
             WHEN '3-10ÂÖÉÔºàÂê´Ôºâ' THEN 7
             WHEN '10-20ÂÖÉÔºàÂê´Ôºâ' THEN 8
             WHEN '20-50ÂÖÉÔºàÂê´Ôºâ' THEN 9
             WHEN '50ÂÖÉ‰ª•‰∏ä' THEN 10
             ELSE 11
           END
      `
      
      const rangeData = await prisma.$query_raw_unsafe(priceRangeQuery) as any[]
      const total_count = rangeData.reduce((sum, item) => sum + Number(item.count), 0)
      
      const priceRanges = rangeData.map(item => ({
        name: item.price_range,
        value: Number(item.count),
        percentage: totalCount > 0 ? (Number(item.count) / total_count * 100).toFixed(1) : '0'
      }))
      
      const responseData = {
        material_type: material_type,
        price_type,
        priceLabel: 'Âçï‰ª∑Âå∫Èó¥ÂàÜÂ∏É',
        totalProducts: total_count,
        priceRanges: priceRanges,
        analysisDate: new Date().toISOString()
      }
      
      console.log('üìä [Âçï‰ª∑Âå∫Èó¥ÂàÜÂ∏É] ÂìçÂ∫îÊï∞ÊçÆ:', responseData)
      
      res.json({
        success: true,
        message: 'Ëé∑ÂèñÂçï‰ª∑Âå∫Èó¥ÂàÜÂ∏ÉÊàêÂäü',
        data: responseData
      })
      return
    }
    
    // ÊÄª‰ª∑ÂàÜÂ∏É - ËøîÂõûÊÄª‰ª∑ÊúÄÈ´òÁöÑ‰∫ßÂìÅÂàóË°®
    let priceField = 'p.total_price'
    let priceLabel = 'ÊÄª‰ª∑'

    // Êü•ËØ¢‰ª∑Ê†ºÂàÜÂ∏ÉÊï∞ÊçÆ
     const priceQuery = `
       SELECT 
         p.id as purchaseId,
         p.product_name as product_name,
         p.material_type as material_type,
         p.bead_diameter as bead_diameter,
         p.specification,
         p.quality,
         p.quantity,
         p.piece_count as piece_count,
         p.total_beads as total_beads,
         p.unit_price as unit_price,
         p.total_price as total_price,
         p.price_per_bead as price_per_bead,
         p.price_per_piece as price_per_piece,
         p.price_per_gram as price_per_gram,
         p.weight,
         s.name as supplier_name,
         p.purchase_date as purchase_date,
         p.created_at as created_at,
         COALESCE(SUM(mu.quantity_used), 0) as usedBeads,
        (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) as remainingBeads,
         ${priceField} as calculated_price
       FROM purchases p
       LEFT JOIN suppliers s ON p.supplier_id = s.id
       LEFT JOIN material_usage mu ON p.id = mu.purchase_id
       WHERE p.status IN ('ACTIVE', 'PENDING') 
         AND p.total_price IS NOT NULL 
         AND p.total_price > 0
         AND (
           (p.material_type IN ('LOOSE_BEADS', 'BRACELET') AND (p.total_beads IS NOT NULL AND p.total_beads > 0 OR p.piece_count IS NOT NULL AND p.piece_count > 0)) OR
         (p.material_type = 'ACCESSORIES' AND p.piece_count IS NOT NULL AND p.piece_count > 0) OR
         (p.material_type = 'FINISHED' AND p.piece_count IS NOT NULL AND p.piece_count > 0)
         )
         ${material_typeCondition}
       GROUP BY p.id, p.product_name, p.material_type, p.bead_diameter, p.specification, 
                p.quality, p.quantity, p.piece_count, p.total_beads, p.unit_price, 
                p.total_price, p.price_per_bead, p.price_per_piece, p.price_per_gram, p.weight, 
                s.name, p.purchase_date, p.created_at
       ORDER BY calculated_price DESC
       LIMIT ?
     `

    console.log('üîç [‰∫ßÂìÅ‰ª∑Ê†ºÂàÜÂ∏É] ÊâßË°åSQLÊü•ËØ¢:', priceQuery)
    const priceData = await prisma.$query_raw_unsafe(priceQuery, parseInt(limit as string)) as any[]
    
    console.log('üìä [‰∫ßÂìÅ‰ª∑Ê†ºÂàÜÂ∏É] Êü•ËØ¢ÁªìÊûú:', {
      length: priceData.length,
      sample: priceData.slice(0, 3)
    })

    // ËΩ¨Êç¢BigIntÂ≠óÊÆµ
    const convertedData = priceData.map(item => {
      const converted = { ...item }
      Object.keys(converted).forEach(key => {
        if (typeof converted[key] === 'bigint') {
          converted[key] = Number(converted[key])
        }
        // ËΩ¨Êç¢DecimalÂ≠óÊÆµ‰∏∫Êï∞Â≠ó
        if (converted[key] && typeof converted[key] === 'object' && converted[key].constructor.name === 'Decimal') {
          converted[key] = parseFloat(converted[key].toString())
        }
      })
      return converted
    })

    // ËÆ°ÁÆóÁªüËÆ°‰ø°ÊÅØ
     const totalProducts = convertedData.length
     const avg_price = totalProducts > 0 ? 
       convertedData.reduce((sum, item) => sum + (item.calculated_price || 0), 0) / totalProducts : 0
     const maxPrice = totalProducts > 0 ? 
       Math.max(...convertedData.map(item => item.calculated_price || 0)) : 0
     const minPrice = totalProducts > 0 ? 
       Math.min(...convertedData.map(item => item.calculated_price || 0)) : 0

    const responseData = {
      material_type: material_type,
      price_type,
      priceLabel: priceLabel,
      totalProducts: totalProducts,
      avg_price: avg_price,
      maxPrice: maxPrice,
      minPrice: minPrice,
      topPriceProducts: convertedData,
      analysisDate: new Date().toISOString()
    }

    console.log('üìä [‰∫ßÂìÅ‰ª∑Ê†ºÂàÜÂ∏É] ÂìçÂ∫îÊï∞ÊçÆ:', responseData)

    // ÊùÉÈôêËøáÊª§ÔºàÈõáÂëò‰∏çËÉΩÊü•Áúã‰æõÂ∫îÂïÜÂíå‰ª∑Ê†º‰ø°ÊÅØÔºâ
    if (req.user!.role === 'EMPLOYEE') {
      responseData.topPriceProducts = responseData.topPriceProducts.map(item => ({
        ...item,
        supplier_name: null,
        unit_price: null,
        total_price: null,
        price_per_bead: null,
        price_per_gram: null
      }))
      responseData.avg_price = 0
      responseData.maxPrice = 0
      responseData.minPrice = 0
    }

    res.json({
      success: true,
      message: 'Ëé∑Âèñ‰∫ßÂìÅ‰ª∑Ê†ºÂàÜÂ∏ÉÊàêÂäü',
      data: responseData
    })
  } catch (error) {
    console.error('‚ùå [‰∫ßÂìÅ‰ª∑Ê†ºÂàÜÂ∏É] Êü•ËØ¢Â§±Ë¥•:', error)
    res.status(500).json(
      ErrorResponses.internal('Ëé∑Âèñ‰∫ßÂìÅ‰ª∑Ê†ºÂàÜÂ∏ÉÂ§±Ë¥•', error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ')
    )
  }
}))

// Ëé∑ÂèñÂéüÊùêÊñôÂàÜÂ∏ÉÊï∞ÊçÆÔºàÈ•ºÂõæÔºâ
router.get('/material-distribution', authenticate_token, asyncHandler(async (req, res) => {
  try {
    const { material_type, limit = 10 } = req.query
    
    console.log('üìä [ÂéüÊùêÊñôÂàÜÂ∏É] Êü•ËØ¢ÂèÇÊï∞:', {
      material_type,
      limit,
      timestamp: new Date().toISOString()
    })
    
    let whereClause = 'WHERE p.material_type IS NOT NULL'
    const queryParams = []
    
    // Ê∑ªÂä†ÊùêÊñôÁ±ªÂûãËøáÊª§
    if (material_type && material_type !== 'ALL') {
      whereClause += ' AND p.material_type = ?'
      queryParams.push(material_type)
    }
    
    const distributionQuery = `
      SELECT 
        p.material_type as material_type,
        COUNT(DISTINCT p.id) as count,
        SUM(p.total_beads - COALESCE(usage_summary.total_used, 0)) as total_remaining_quantity,
        AVG(p.price_per_gram) as avgPricePerGram,
        SUM(p.total_price) as total_value
      FROM purchases p
      LEFT JOIN (
        SELECT purchaseId, SUM(quantity_used) as total_used
        FROM material_usage
        GROUP BY purchaseId
      ) usage_summary ON p.id = usage_summary.purchase_id
      ${whereClause}
      GROUP BY p.material_type
      ORDER BY total_remaining_quantity DESC
      LIMIT ?
    `
    
    queryParams.push(parseInt(limit as string))
    
    console.log('üìä [ÂéüÊùêÊñôÂàÜÂ∏É] ÊâßË°åÊü•ËØ¢:', {
      query: distributionQuery,
      params: queryParams
    })
    
    const result = await prisma.$query_raw_unsafe(distributionQuery, ...queryParams) as any[]
    
    console.log('üìä [ÂéüÊùêÊñôÂàÜÂ∏É] Êü•ËØ¢ÁªìÊûú:', {
      count: result.length,
      data: result
    })
    
    // Â¶ÇÊûúÊ≤°ÊúâÊï∞ÊçÆÔºåËøîÂõûÁ©∫ÁªìÊûúËÄå‰∏çÊòØÈîôËØØ
    if (result.length === 0) {
      console.log('üìä [ÂéüÊùêÊñôÂàÜÂ∏É] Ê≤°ÊúâÊâæÂà∞Êï∞ÊçÆÔºåËøîÂõûÁ©∫ÁªìÊûú')
      return res.json({
        success: true,
        message: 'ÊöÇÊó†ÂéüÊùêÊñôÂàÜÂ∏ÉÊï∞ÊçÆ',
        data: {
          items: [],
          total: 0
        }
      })
    }
    
    // ËΩ¨Êç¢BigIntÂ≠óÊÆµ‰∏∫Number
    const convertedResult = result.map(item => ({
      material_type: item.material_type,
      count: Number(item.count),
      total_remaining_quantity: Number(item.total_remaining_quantity),
      avgPricePerGram: item.avgPricePerGram ? Number(item.avgPricePerGram) : null,
      total_value: item.total_value ? Number(item.total_value) : null
    }))
    
    // ÊùÉÈôêËøáÊª§ÔºàÈõáÂëò‰∏çËÉΩÊü•Áúã‰ª∑Ê†º‰ø°ÊÅØÔºâ
    if (req.user!.role === 'EMPLOYEE') {
      convertedResult.forEach(item => {
        item.avgPricePerGram = null
        item.total_value = null
      })
    }
    
    res.json({
      success: true,
      message: 'Ëé∑ÂèñÂéüÊùêÊñôÂàÜÂ∏ÉÊï∞ÊçÆÊàêÂäü',
      data: {
        items: convertedResult,
        total: convertedResult.length
      }
    })
    return
  } catch (error) {
    console.error('‚ùå [ÂéüÊùêÊñôÂàÜÂ∏É] Êü•ËØ¢Â§±Ë¥•:', error)
    res.status(500).json(
      ErrorResponses.internal('Ëé∑ÂèñÂéüÊùêÊñôÂàÜÂ∏ÉÊï∞ÊçÆÂ§±Ë¥•', error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ')
    )
    return
  }
}))

// Ëé∑ÂèñÂ∫ìÂ≠òËØ¶ÊÉÖ
router.get('/:purchaseId', authenticate_token, asyncHandler(async (req, res) => {
  const { purchase_id } = req.params

  try {const detailQuery = `
      SELECT 
        p.id as purchase_id,
        p.product_name as product_name,
        CONCAT(p.product_name, ' ', p.bead_diameter, 'mm ', COALESCE(p.quality, ''), 'Á∫ß') as bead_type,
        p.bead_diameter as bead_diameter,
        p.quality,
        p.min_stock_alert as min_stock_alert,
        p.total_beads as originalBeads,
        COALESCE(SUM(mu.quantity_used), 0) as usedBeads,
        (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) as remainingBeads,
        CASE 
          WHEN p.min_stock_alert IS NOT NULL AND 
               (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) <= p.min_stock_alert 
          THEN 1 
          ELSE 0 
        END as is_low_stock,
        p.price_per_bead as price_per_bead,
        p.price_per_gram as price_per_gram,
        p.total_price as total_price,
        p.weight,
        s.name as supplier_name,
        s.contact as supplier_contact,
        s.phone as supplier_phone,
        p.purchase_date as purchase_date,
        p.photos,
        p.notes,
        p.created_at as created_at,
        p.updated_at as updated_at
      FROM purchases p
      LEFT JOIN material_usage mu ON p.id = mu.purchase_id
      LEFT JOIN suppliers s ON p.supplier_id = s.id
      WHERE p.id = ?
      GROUP BY p.id, p.product_name, p.bead_diameter, p.quality, p.min_stock_alert, 
               p.total_beads, p.price_per_bead, p.price_per_gram, p.total_price, p.weight,
               s.name, s.contact, s.phone, p.purchase_date, p.photos, p.notes, 
               p.created_at, p.updated_at
    `

    const result = await prisma.$query_raw_unsafe(detailQuery, purchase_id) as any[]

    if (result.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Â∫ìÂ≠òËÆ∞ÂΩï‰∏çÂ≠òÂú®'
      })
    }

    // ÊùÉÈôêËøáÊª§
    const filteredResult = filterInventoryData(result, req.user!.role)

    res.json({
      success: true,
      message: 'Ëé∑ÂèñÂ∫ìÂ≠òËØ¶ÊÉÖÊàêÂäü',
      data: filteredResult[0]
    })
    return
  } catch (error) {
    console.error('Ëé∑ÂèñÂ∫ìÂ≠òËØ¶ÊÉÖÂ§±Ë¥•:', error)
    res.status(500).json({
      success: false,
      message: 'Ëé∑ÂèñÂ∫ìÂ≠òËØ¶ÊÉÖÂ§±Ë¥•'
    })
    return
  }
}))

// Ëé∑Âèñ‰ΩéÂ∫ìÂ≠òÈ¢ÑË≠¶
router.get('/alerts/low-stock', authenticate_token, asyncHandler(async (req, res) => {try {
    const alertQuery = `
      SELECT 
        p.id as purchase_id,
        p.product_name as product_name,
        CONCAT(p.product_name, ' ', p.bead_diameter, 'mm ', COALESCE(p.quality, ''), 'Á∫ß') as bead_type,
        p.bead_diameter as bead_diameter,
        p.quality,
        p.min_stock_alert as min_stock_alert,
        (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) as remainingBeads,
        p.purchase_date as purchase_date
      FROM purchases p
      LEFT JOIN material_usage mu ON p.id = mu.purchase_id
      WHERE p.bead_diameter IS NOT NULL 
        AND p.min_stock_alert IS NOT NULL
      GROUP BY p.id, p.product_name, p.bead_diameter, p.quality, p.min_stock_alert, 
               p.total_beads, p.purchase_date
      HAVING remainingBeads <= p.min_stock_alert
      ORDER BY remainingBeads ASC
    `

    const alerts = await prisma.$query_raw_unsafe(alertQuery) as any[]

    // ËΩ¨Êç¢BigIntÂ≠óÊÆµ
    const convertedAlerts = alerts.map(item => {
      const converted = { ...item }
      Object.keys(converted).forEach(key => {
        if (typeof converted[key] === 'bigint') {
          converted[key] = Number(converted[key])
        }
      })
      return converted
    })

    res.json({
      success: true,
      message: 'Ëé∑Âèñ‰ΩéÂ∫ìÂ≠òÈ¢ÑË≠¶ÊàêÂäü',
      data: {
        items: convertedAlerts,
        total: convertedAlerts.length
      }
    })
  } catch (error) {
    console.error('Ëé∑Âèñ‰ΩéÂ∫ìÂ≠òÈ¢ÑË≠¶Â§±Ë¥•:', error)
    res.status(500).json({
      success: false,
      message: 'Ëé∑Âèñ‰ΩéÂ∫ìÂ≠òÈ¢ÑË≠¶Â§±Ë¥•'
    })
  }
}))



// ÂØºÂá∫Â∫ìÂ≠òÊï∞ÊçÆ
router.get('/export/excel', authenticate_token, asyncHandler(async (req, res) => {
  try {
    let exportQuery = `
      SELECT 
        p.product_name as '‰∫ßÂìÅÂêçÁß∞',
        CONCAT(p.bead_diameter, 'mm') as 'Áè†Â≠êÁõ¥ÂæÑ',
        p.quality as 'ÂìÅÁõ∏Á≠âÁ∫ß',
        p.total_beads as 'ÈááË¥≠ÊÄªÈ¢óÊï∞',
        COALESCE(SUM(mu.quantity_used), 0) as 'Â∑≤‰ΩøÁî®È¢óÊï∞',
        (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) as 'Ââ©‰ΩôÈ¢óÊï∞',
        CASE 
          WHEN p.min_stock_alert IS NOT NULL AND 
               (p.total_beads - COALESCE(SUM(mu.quantity_used), 0)) <= p.min_stock_alert 
          THEN 'ÊòØ' 
          ELSE 'Âê¶' 
        END as '‰ΩéÂ∫ìÂ≠òÈ¢ÑË≠¶'`
    
    if (req.user!.role === 'BOSS') {
      exportQuery += `,
        s.name as '‰æõÂ∫îÂïÜ',
        p.price_per_gram as 'ÂÖã‰ª∑',
        p.price_per_bead as 'ÊØèÈ¢óÂçï‰ª∑'`
    }
    
    exportQuery += `,
        DATE_FORMAT(p.purchase_date, '%Y-%m-%d') as 'ÈááË¥≠Êó•Êúü'
      FROM purchases p
      LEFT JOIN material_usage mu ON p.id = mu.purchase_id`
    
    if (req.user!.role === 'BOSS') {
      exportQuery += `
      LEFT JOIN suppliers s ON p.supplier_id = s.id`
    }
    
    exportQuery += `
      WHERE p.bead_diameter IS NOT NULL
      GROUP BY p.id, p.product_name, p.bead_diameter, p.quality, p.min_stock_alert, 
               p.total_beads, p.price_per_gram, p.price_per_bead, p.purchase_date`
    
    if (req.user!.role === 'BOSS') {
      exportQuery += `, s.name`
    }
    
    exportQuery += `
      ORDER BY p.purchase_date DESC`

    const exportData = await prisma.$query_raw_unsafe(exportQuery) as any[]

    // ËΩ¨Êç¢BigIntÂ≠óÊÆµ
    const convertedExportData = exportData.map(item => {
      const converted = { ...item }
      Object.keys(converted).forEach(key => {
        if (typeof converted[key] === 'bigint') {
          converted[key] = Number(converted[key])
        }
      })
      return converted
    })

    res.json({
      success: true,
      message: 'ÂØºÂá∫Êï∞ÊçÆËé∑ÂèñÊàêÂäü',
      data: {
        items: convertedExportData,
        total: convertedExportData.length,
        filename: `Â∫ìÂ≠òÊï∞ÊçÆ_${new Date().toISOString().split('T')[0]}.xlsx`
      }
    })
  } catch (error) {
    console.error('ÂØºÂá∫Â∫ìÂ≠òÊï∞ÊçÆÂ§±Ë¥•:', error)
    res.status(500).json({
      success: false,
      message: 'ÂØºÂá∫Êï∞ÊçÆÂ§±Ë¥•'
    })
  }
}))



export default router