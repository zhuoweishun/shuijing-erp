import mysql from 'mysql2/promise'

async function recreate_triggers() {
  let connection
  
  try {
    // ÂàõÂª∫Êï∞ÊçÆÂ∫ìËøûÊé•
    connection = await mysql.createConnection({
      host: 'localhost',
      user: 'root',
      password: 'ZWSloveWCC123',
      database: 'crystal_erp_dev'
    })

    console.log('üîß ÈáçÊñ∞ÂàõÂª∫Ëß¶ÂèëÂô®...')
    
    // ÂÖàÂà†Èô§Áé∞ÊúâËß¶ÂèëÂô®
    console.log('üóëÔ∏è Âà†Èô§Áé∞ÊúâËß¶ÂèëÂô®...')
    const drop_triggers = [
      'DROP TRIGGER IF EXISTS tr_purchase_insert_material',
      'DROP TRIGGER IF EXISTS tr_purchase_update_material', 
      'DROP TRIGGER IF EXISTS tr_material_usage_update_stock',
      'DROP TRIGGER IF EXISTS tr_material_usage_update_stock_after_update',
      'DROP TRIGGER IF EXISTS tr_material_usage_update_stock_after_delete'
    ]
    
    for (const sql of drop_triggers) {
      await connection.query(sql)
    }
    
    console.log('‚úÖ Áé∞ÊúâËß¶ÂèëÂô®Â∑≤Âà†Èô§')
    
    // ÂàõÂª∫Êñ∞Ëß¶ÂèëÂô®
    console.log('üìÑ ÂàõÂª∫Êñ∞Ëß¶ÂèëÂô®...')
    
    // Ëß¶ÂèëÂô®1: ÈááË¥≠ËÆ∞ÂΩïÂàõÂª∫Êó∂Ëá™Âä®ÂàõÂª∫materialËÆ∞ÂΩï
    const trigger1 = `
    CREATE TRIGGER tr_purchase_insert_material
    AFTER INSERT ON purchases
    FOR EACH ROW
    BEGIN
      IF NEW.status = 'ACTIVE' THEN
        INSERT INTO materials (
          id,
          material_code, 
          material_name, 
          material_type, 
          quality,
          bead_diameter, 
          bracelet_inner_diameter,
          bracelet_bead_count,
          accessory_specification, 
          finished_material_specification,
          original_quantity,
          used_quantity,
          remaining_quantity,
          inventory_unit, 
          unit_cost, 
          total_cost,
          min_stock_alert, 
          purchase_id, 
          supplier_id, 
          photos, 
          material_date, 
          notes, 
          created_by,
          created_at,
          updated_at
        ) VALUES (
          CONCAT('mat_', SUBSTRING(UUID(), 1, 8), '_', UNIX_TIMESTAMP()),
          NEW.purchase_code,
          NEW.purchase_name,
          NEW.purchase_type,
          COALESCE(NEW.quality, 'UNKNOWN'),
          NEW.bead_diameter,
          CASE 
            WHEN NEW.purchase_type = 'BRACELET' THEN NEW.specification
            ELSE NULL
          END,
          NEW.beads_per_string,
          CASE 
            WHEN NEW.purchase_type = 'ACCESSORIES' THEN CAST(NEW.specification AS CHAR)
            ELSE NULL
          END,
          CASE 
            WHEN NEW.purchase_type = 'FINISHED_MATERIAL' THEN CAST(NEW.specification AS CHAR)
            ELSE NULL
          END,
          
          -- ËΩ¨Êç¢ÂêéÁöÑÊï∞ÈáèËÆ°ÁÆó
          CASE 
            WHEN NEW.purchase_type = 'LOOSE_BEADS' THEN 
              CASE 
                WHEN NEW.bead_diameter = 4.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 25)
                WHEN NEW.bead_diameter = 6.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 11)
                WHEN NEW.bead_diameter = 8.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 6)
                WHEN NEW.bead_diameter = 10.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 4)
                WHEN NEW.bead_diameter = 12.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 3)
                ELSE FLOOR(COALESCE(NEW.weight, 0) * 5)
              END
            WHEN NEW.purchase_type = 'BRACELET' THEN 
              COALESCE(NEW.total_beads, 
                CASE 
                  WHEN NEW.bead_diameter = 4.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 25)
                  WHEN NEW.bead_diameter = 6.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 11)
                  WHEN NEW.bead_diameter = 8.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 6)
                  WHEN NEW.bead_diameter = 10.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 4)
                  WHEN NEW.bead_diameter = 12.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 3)
                  ELSE FLOOR(COALESCE(NEW.weight, 0) * 5)
                END,
                1
              )
            WHEN NEW.purchase_type = 'ACCESSORIES' THEN COALESCE(NEW.piece_count, 1)
            WHEN NEW.purchase_type = 'FINISHED_MATERIAL' THEN COALESCE(NEW.piece_count, 1)
            ELSE 1
          END,
          
          -- ÂàùÂßãused_quantity‰∏∫0
          0,
          
          -- remaining_quantity = original_quantity - used_quantity
          CASE 
            WHEN NEW.purchase_type = 'LOOSE_BEADS' THEN 
              CASE 
                WHEN NEW.bead_diameter = 4.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 25)
                WHEN NEW.bead_diameter = 6.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 11)
                WHEN NEW.bead_diameter = 8.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 6)
                WHEN NEW.bead_diameter = 10.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 4)
                WHEN NEW.bead_diameter = 12.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 3)
                ELSE FLOOR(COALESCE(NEW.weight, 0) * 5)
              END
            WHEN NEW.purchase_type = 'BRACELET' THEN 
              COALESCE(NEW.total_beads, 
                CASE 
                  WHEN NEW.bead_diameter = 4.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 25)
                  WHEN NEW.bead_diameter = 6.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 11)
                  WHEN NEW.bead_diameter = 8.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 6)
                  WHEN NEW.bead_diameter = 10.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 4)
                  WHEN NEW.bead_diameter = 12.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 3)
                  ELSE FLOOR(COALESCE(NEW.weight, 0) * 5)
                END,
                1
              )
            WHEN NEW.purchase_type = 'ACCESSORIES' THEN COALESCE(NEW.piece_count, 1)
            WHEN NEW.purchase_type = 'FINISHED_MATERIAL' THEN COALESCE(NEW.piece_count, 1)
            ELSE 1
          END,
          
          -- Â∫ìÂ≠òÂçï‰Ωç
          CASE 
            WHEN NEW.purchase_type IN ('LOOSE_BEADS', 'BRACELET') THEN 'PIECES'
            WHEN NEW.purchase_type = 'ACCESSORIES' THEN 'SLICES'
            WHEN NEW.purchase_type = 'FINISHED_MATERIAL' THEN 'ITEMS'
            ELSE 'PIECES'
          END,
          
          -- Âçï‰ΩçÊàêÊú¨ËÆ°ÁÆó
          CASE 
            WHEN NEW.purchase_type = 'LOOSE_BEADS' THEN 
              COALESCE(NEW.total_price, 0) / GREATEST(
                CASE 
                  WHEN NEW.bead_diameter = 4.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 25)
                  WHEN NEW.bead_diameter = 6.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 11)
                  WHEN NEW.bead_diameter = 8.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 6)
                  WHEN NEW.bead_diameter = 10.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 4)
                  WHEN NEW.bead_diameter = 12.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 3)
                  ELSE FLOOR(COALESCE(NEW.weight, 0) * 5)
                END,
                1
              )
            WHEN NEW.purchase_type = 'BRACELET' THEN 
              COALESCE(NEW.total_price, 0) / GREATEST(
                COALESCE(NEW.total_beads, 
                  CASE 
                    WHEN NEW.bead_diameter = 4.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 25)
                    WHEN NEW.bead_diameter = 6.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 11)
                    WHEN NEW.bead_diameter = 8.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 6)
                    WHEN NEW.bead_diameter = 10.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 4)
                    WHEN NEW.bead_diameter = 12.0 THEN FLOOR(COALESCE(NEW.weight, 0) * 3)
                    ELSE FLOOR(COALESCE(NEW.weight, 0) * 5)
                  END,
                  1
                ),
                1
              )
            ELSE COALESCE(NEW.total_price, 0) / GREATEST(COALESCE(NEW.piece_count, 1), 1)
          END,
          
          COALESCE(NEW.total_price, 0),
          NEW.min_stock_alert,
          NEW.id,
          NEW.supplier_id,
          NEW.photos,
          DATE(NEW.purchase_date),
          NEW.notes,
          NEW.user_id,
          NEW.created_at,
          NEW.updated_at
        );
      END IF;
    END`
    
    await connection.query(trigger1)
    console.log('‚úÖ Ëß¶ÂèëÂô®1ÂàõÂª∫ÊàêÂäü: tr_purchase_insert_material')
    
    // Ëß¶ÂèëÂô®2: ÈááË¥≠ËÆ∞ÂΩïÊõ¥Êñ∞Êó∂ÂêåÊ≠•Êõ¥Êñ∞materialËÆ∞ÂΩï
    const trigger2 = `
    CREATE TRIGGER tr_purchase_update_material
    AFTER UPDATE ON purchases
    FOR EACH ROW
    BEGIN
      IF NEW.status = 'ACTIVE' AND OLD.status = 'ACTIVE' THEN
        UPDATE materials SET
          material_name = NEW.purchase_name,
          quality = COALESCE(NEW.quality, 'UNKNOWN'),
          bead_diameter = NEW.bead_diameter,
          min_stock_alert = NEW.min_stock_alert,
          photos = NEW.photos,
          notes = NEW.notes,
          updated_at = NEW.updated_at
        WHERE purchase_id = NEW.id;
      ELSEIF NEW.status = 'USED' AND OLD.status = 'ACTIVE' THEN
        UPDATE materials SET
          notes = CONCAT(COALESCE(notes, ''), '\n[ÈááË¥≠ËÆ∞ÂΩïÂ∑≤Ê†áËÆ∞‰∏∫USED]'),
          updated_at = NEW.updated_at
        WHERE purchase_id = NEW.id;
      END IF;
    END`
    
    await connection.query(trigger2)
    console.log('‚úÖ Ëß¶ÂèëÂô®2ÂàõÂª∫ÊàêÂäü: tr_purchase_update_material')
    
    // Ëß¶ÂèëÂô®3: material‰ΩøÁî®ÈáèÊõ¥Êñ∞Ëß¶ÂèëÂô® - INSERT
    const trigger3 = `
    CREATE TRIGGER tr_material_usage_update_stock
    AFTER INSERT ON material_usage
    FOR EACH ROW
    BEGIN
      UPDATE materials SET
        used_quantity = (
          SELECT COALESCE(SUM(quantity_used), 0)
          FROM material_usage
          WHERE material_id = NEW.material_id
        ),
        remaining_quantity = original_quantity - (
          SELECT COALESCE(SUM(quantity_used), 0)
          FROM material_usage
          WHERE material_id = NEW.material_id
        ),
        updated_at = CURRENT_TIMESTAMP
      WHERE id = NEW.material_id;
    END`
    
    await connection.query(trigger3)
    console.log('‚úÖ Ëß¶ÂèëÂô®3ÂàõÂª∫ÊàêÂäü: tr_material_usage_update_stock')
    
    // Ëß¶ÂèëÂô®4: material‰ΩøÁî®ÈáèÊõ¥Êñ∞Ëß¶ÂèëÂô® - UPDATE
    const trigger4 = `
    CREATE TRIGGER tr_material_usage_update_stock_after_update
    AFTER UPDATE ON material_usage
    FOR EACH ROW
    BEGIN
      UPDATE materials SET
        used_quantity = (
          SELECT COALESCE(SUM(quantity_used), 0)
          FROM material_usage
          WHERE material_id = NEW.material_id
        ),
        remaining_quantity = original_quantity - (
          SELECT COALESCE(SUM(quantity_used), 0)
          FROM material_usage
          WHERE material_id = NEW.material_id
        ),
        updated_at = CURRENT_TIMESTAMP
      WHERE id = NEW.material_id;
    END`
    
    await connection.query(trigger4)
    console.log('‚úÖ Ëß¶ÂèëÂô®4ÂàõÂª∫ÊàêÂäü: tr_material_usage_update_stock_after_update')
    
    // Ëß¶ÂèëÂô®5: material‰ΩøÁî®ÈáèÊõ¥Êñ∞Ëß¶ÂèëÂô® - DELETE
    const trigger5 = `
    CREATE TRIGGER tr_material_usage_update_stock_after_delete
    AFTER DELETE ON material_usage
    FOR EACH ROW
    BEGIN
      UPDATE materials SET
        used_quantity = (
          SELECT COALESCE(SUM(quantity_used), 0)
          FROM material_usage
          WHERE material_id = OLD.material_id
        ),
        remaining_quantity = original_quantity - (
          SELECT COALESCE(SUM(quantity_used), 0)
          FROM material_usage
          WHERE material_id = OLD.material_id
        ),
        updated_at = CURRENT_TIMESTAMP
      WHERE id = OLD.material_id;
    END`
    
    await connection.query(trigger5)
    console.log('‚úÖ Ëß¶ÂèëÂô®5ÂàõÂª∫ÊàêÂäü: tr_material_usage_update_stock_after_delete')
    
    // ÂàõÂª∫Á¥¢Âºï
    console.log('üìä ÂàõÂª∫Á¥¢Âºï...')
    try {
      await connection.query('CREATE INDEX idx_materials_purchase_id ON materials(purchase_id)')
    } catch (error) {
      if (error.code !== 'ER_DUP_KEYNAME') {
        throw error
      }
      console.log('Á¥¢Âºï idx_materials_purchase_id Â∑≤Â≠òÂú®')
    }
    
    try {
      await connection.query('CREATE INDEX idx_material_usage_material_id ON material_usage(material_id)')
    } catch (error) {
      if (error.code !== 'ER_DUP_KEYNAME') {
        throw error
      }
      console.log('Á¥¢Âºï idx_material_usage_material_id Â∑≤Â≠òÂú®')
    }
    console.log('‚úÖ Á¥¢ÂºïÂàõÂª∫ÂÆåÊàê')
    
    // È™åËØÅËß¶ÂèëÂô®ÊòØÂê¶Â≠òÂú®
    const [triggers] = await connection.query(`
      SELECT TRIGGER_NAME, EVENT_MANIPULATION, EVENT_OBJECT_TABLE 
      FROM information_schema.TRIGGERS 
      WHERE TRIGGER_SCHEMA = 'crystal_erp_dev'
      ORDER BY TRIGGER_NAME
    `)
    
    console.log('\nüìã ÂΩìÂâçÊï∞ÊçÆÂ∫ì‰∏≠ÁöÑËß¶ÂèëÂô®:')
    triggers.forEach(trigger => {
      console.log(`- ${trigger.TRIGGER_NAME}: ${trigger.EVENT_MANIPULATION} on ${trigger.EVENT_OBJECT_TABLE}`)
    })
    
    console.log('\nüéâ ÊâÄÊúâËß¶ÂèëÂô®ÈáçÊñ∞ÂàõÂª∫ÂÆåÊàêÔºÅ')
    
  } catch (error) {
    console.error('‚ùå ÈáçÊñ∞ÂàõÂª∫Ëß¶ÂèëÂô®Êó∂ÂèëÁîüÈîôËØØ:', error)
    throw error
  } finally {
    if (connection) {
      await connection.end()
    }
  }
}

// ËøêË°åËÑöÊú¨
recreate_triggers().catch(error => {
  console.error('ÈáçÊñ∞ÂàõÂª∫Ëß¶ÂèëÂô®Â§±Ë¥•:', error)
  process.exit(1)
})