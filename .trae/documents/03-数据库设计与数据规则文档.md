# 文档 03：数据库设计与数据规则文档

## 一、数据库架构概览

### 1.1 核心表结构
本系统采用MySQL数据库，包含以下核心表：
- 用户表（users）
- 供应商表（suppliers）
- 采购表（purchases）
- 成品表（products）
- 系统配置表（system_configs）
- 编辑日志表（edit_logs）
- 原材料使用记录表（material_usage）
- SKU主表（product_skus）
- SKU库存变更日志表（sku_inventory_logs）
- 审计日志表（audit_logs）
- 客户备注表（customer_notes）
- 客户购买记录表（customer_purchases）
- 客户表（customers）
- 财务记录表（financial_records）

### 1.2 字段命名规范（全蛇形命名）
- **严格使用snake_case命名**：所有字段都使用下划线分隔（如：user_name、purchase_code、product_name）
- **主键统一使用id**：String类型，使用cuid()生成
- **外键使用{table}_id格式**：如user_id、supplier_id、customer_id
- **时间字段使用_at后缀**：created_at、updated_at、last_login_at
- **编号字段使用_code后缀**：purchase_code、sku_code
- **价格字段使用price_per_前缀**：price_per_gram、price_per_bead、price_per_piece
- **数量字段明确含义**：total_quantity、available_quantity、remaining_quantity
- **状态字段使用枚举**：product_type、quality、status等

## 二、核心表结构设计

### 2.1 用户表（users）

```sql
CREATE TABLE users (
  id VARCHAR(36) PRIMARY KEY,
  user_name VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(100) UNIQUE,
  password VARCHAR(255) NOT NULL,
  role ENUM('BOSS', 'EMPLOYEE') DEFAULT 'EMPLOYEE',
  name VARCHAR(100) NOT NULL,
  phone VARCHAR(20),
  avatar VARCHAR(500),
  is_active BOOLEAN DEFAULT TRUE,
  last_login_at TIMESTAMP NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**字段说明：**
- `user_name`: 登录用户名，唯一
- `name`: 真实姓名
- `role`: 用户角色（BOSS/EMPLOYEE）
- `is_active`: 账户状态
- `last_login_at`: 最后登录时间

### 2.2 供应商表（suppliers）

```sql
CREATE TABLE suppliers (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(200) UNIQUE NOT NULL,
  contact VARCHAR(100),
  phone VARCHAR(20),
  email VARCHAR(100),
  address VARCHAR(500),
  description TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.2.1 采购表 (purchases) - 完整优化版

**表结构：**
```sql
CREATE TABLE purchases (
    id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
    purchase_code VARCHAR(50) UNIQUE NOT NULL COMMENT '采购编号',
    purchase_name VARCHAR(255) NOT NULL COMMENT '产品名称',
    purchase_type ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED_MATERIAL') NOT NULL COMMENT '产品类型',
    quality ENUM('AA', 'A', 'AB', 'B', 'C', 'UNKNOWN') DEFAULT 'UNKNOWN' COMMENT '品质等级',
    bead_diameter DECIMAL(5,2) COMMENT '珠子直径(mm)',
    bracelet_inner_diameter DECIMAL(5,2) COMMENT '手串内径(mm)',
    bracelet_bead_count INT COMMENT '手串珠子数量',
    accessory_specification VARCHAR(100) COMMENT '配件规格',
    finished_material_specification VARCHAR(100) COMMENT '成品规格',
    quantity DECIMAL(10,2) NOT NULL COMMENT '数量',
    piece_count INT COMMENT '件数',
    price_per_gram DECIMAL(10,2) COMMENT '克价',
    weight DECIMAL(10,2) COMMENT '重量(克)',
    total_price DECIMAL(12,2) NOT NULL COMMENT '总价',
    supplier_id VARCHAR(36) COMMENT '供应商ID',
    photos JSON COMMENT '照片URLs',
    purchase_date DATE NOT NULL COMMENT '采购日期',
    notes TEXT COMMENT '备注',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id) ON DELETE SET NULL
);

-- 采购列表查询优化索引
CREATE INDEX idx_purchases_search ON purchases(purchase_name, purchase_code);
CREATE INDEX idx_purchases_filter ON purchases(purchase_type, quality, purchase_date);
CREATE INDEX idx_purchases_supplier ON purchases(supplier_id);
CREATE INDEX idx_purchases_price_range ON purchases(price_per_gram, total_price);
CREATE INDEX idx_purchases_spec_range ON purchases(bead_diameter, bracelet_inner_diameter);
CREATE INDEX idx_purchases_date_sort ON purchases(purchase_date DESC, created_at DESC);
```

**采购列表字段映射规则：**
- **规格字段动态选择**：根据产品类型自动选择对应规格字段
  - LOOSE_BEADS → bead_diameter
  - BRACELET → bracelet_inner_diameter  
  - ACCESSORIES → accessory_specification
  - FINISHED_MATERIAL → finished_material_specification
- **搜索字段**：purchase_name（产品名称）、purchase_code（采购编号）支持模糊匹配
- **筛选字段**：支持多选的quality、purchase_type、supplier，支持范围筛选的价格和规格
- **排序字段**：所有数值字段支持升序/降序排序，规格字段根据产品类型动态选择

### 2.3 采购表（purchases）

```sql
CREATE TABLE purchases (
  id VARCHAR(36) PRIMARY KEY,
  purchase_code VARCHAR(50) UNIQUE NOT NULL,
  purchase_name VARCHAR(200) NOT NULL,
  quantity INT,
  min_stock_alert INT,
  price_per_gram DECIMAL(10,1),
  unit_price DECIMAL(10,1),
  total_price DECIMAL(10,1),
  weight DECIMAL(10,1),
  bead_diameter DECIMAL(10,1),
  beads_per_string INT,
  total_beads INT,
  price_per_bead DECIMAL(10,4),
  price_per_piece DECIMAL(10,4),
  quality ENUM('AA', 'A', 'AB', 'B', 'C'),
  purchase_type ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED') DEFAULT 'BRACELET',
  unit_type ENUM('PIECES', 'STRINGS', 'SLICES', 'ITEMS') DEFAULT 'STRINGS'
  specification DECIMAL(10,1),
  piece_count INT,
  purchase_date TIMESTAMP NOT NULL,
  natural_language_input TEXT,
  photos JSON,
  notes TEXT,
  ai_recognition_result JSON,
  status ENUM('ACTIVE', 'USED') DEFAULT 'ACTIVE',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  supplier_id VARCHAR(36),
  user_id VARCHAR(36) NOT NULL,
  last_edited_by_id VARCHAR(36),
  
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (last_edited_by_id) REFERENCES users(id),
  INDEX idx_purchases_purchase_code (purchase_code),
  INDEX idx_purchases_purchase_type (purchase_type),
  INDEX idx_purchases_quality (quality),
  INDEX idx_purchases_purchase_date (purchase_date DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**重要字段说明（已修复）：**
- `purchase_code`: 采购编号，格式为CG+YYYYMMDD+序号（如：CG20241231001）
- `purchase_name`: 采购名称（修复：统一使用purchase_name而非product_name）
- `purchase_type`: 采购类型（LOOSE_BEADS/BRACELET/ACCESSORIES/FINISHED_MATERIAL）
- `unit_type`: 计量单位（PIECES/STRINGS/SLICES/ITEMS）
- `bead_diameter`: 珠子直径（散珠/手串专用）
- `price_per_gram`: 克价（散珠/手串专用）
- `price_per_bead`: 每颗价格（散珠/手串专用，自动计算）
- `price_per_piece`: 每片/件价格（配件/成品专用，自动计算）
- `total_beads`: 总颗数（散珠专用，自动计算）
- `beads_per_string`: 每串颗数（手串专用）
- `piece_count`: 片数/件数（配件/成品专用）
- `weight`: 重量（散珠/手串专用）
- `min_stock_alert`: 最低预警颗数
- `photos`: 图片URL数组（JSON格式存储）
- `natural_language_input`: 自然语言录入信息
- `ai_recognition_result`: AI识别结果（JSON格式存储）
- `status`: 状态（ACTIVE/USED）
- `remaining_quantity`: 剩余数量（库存视图计算字段）

**采购类型字段映射规则：**
| 采购类型 | 英文标识 | 必填字段 | 计算字段 | 单位类型 |
|----------|----------|----------|----------|----------|
| 散珠 | LOOSE_BEADS | price_per_gram, weight, bead_diameter | total_beads, price_per_bead | PIECES |
| 手串 | BRACELET | price_per_gram, weight, bead_diameter, beads_per_string | price_per_bead | STRINGS |
| 配件 | ACCESSORIES | piece_count, total_price | price_per_piece | SLICES/ITEMS |
| 成品 | FINISHED_MATERIAL | piece_count, total_price | price_per_piece | ITEMS |

**自动计算字段逻辑：**
```sql
-- 散珠总颗数计算（基于重量和直径）
total_beads = CASE 
  WHEN bead_diameter = 4.0 THEN weight * 25
  WHEN bead_diameter = 6.0 THEN weight * 11
  WHEN bead_diameter = 8.0 THEN weight * 6
  WHEN bead_diameter = 10.0 THEN weight * 4
  WHEN bead_diameter = 12.0 THEN weight * 3
  ELSE weight * 5
END

-- 每颗价格计算
price_per_bead = total_price / total_beads

-- 每片/件价格计算
price_per_piece = total_price / piece_count
```

**数据验证规则：**
- `purchase_name`: 长度2-200字符，不能为空
- `purchase_type`: 必须为枚举值之一
- `total_price`: 必须大于0
- `quality`: 必须为AA/A/AB/B/C之一
- `photos`: JSON数组格式，最多5个URL
- `weight`: 散珠/手串类型时必填，必须大于0
- `piece_count`: 配件/成品类型时必填，必须大于0
- `bead_diameter`: 散珠/手串类型时必填，常用值：4/6/8/10/12mm

### 2.4 成品表（products）

```sql
CREATE TABLE products (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  description TEXT,
  category VARCHAR(100),
  quantity INT DEFAULT 0,
  unit VARCHAR(20) NOT NULL,
  unit_price DECIMAL(10,2) NOT NULL,
  total_value DECIMAL(10,2) NOT NULL,
  status ENUM('MAKING', 'AVAILABLE', 'SOLD', 'OFFLINE') DEFAULT 'AVAILABLE',
  location VARCHAR(100),
  notes TEXT,
  images TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  user_id VARCHAR(36) NOT NULL,
  product_code VARCHAR(50),
  sku_id VARCHAR(36),
  
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  INDEX idx_products_status (status),
  INDEX idx_products_sku_id (sku_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.5 系统配置表（system_configs）

```sql
CREATE TABLE system_configs (
  id VARCHAR(36) PRIMARY KEY,
  key VARCHAR(100) UNIQUE NOT NULL,
  value TEXT NOT NULL,
  description VARCHAR(500),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.6 编辑日志表（edit_logs）

```sql
CREATE TABLE edit_logs (
  id VARCHAR(36) PRIMARY KEY,
  purchase_id VARCHAR(36) NOT NULL,
  user_id VARCHAR(36) NOT NULL,
  action VARCHAR(100) NOT NULL,
  details TEXT,
  changed_fields JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (purchase_id) REFERENCES purchases(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  INDEX idx_edit_logs_purchase_id (purchase_id),
  INDEX idx_edit_logs_user_id (user_id),
  INDEX idx_edit_logs_created_at (created_at DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.7 原材料使用记录表（material_usage）

```sql
CREATE TABLE material_usage (
  id VARCHAR(36) PRIMARY KEY,
  purchase_id VARCHAR(36),
  product_id VARCHAR(36),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  total_cost DECIMAL(10,2),
  unit_cost DECIMAL(10,4),
  action ENUM('CREATE', 'USE', 'RETURN', 'ADJUST') DEFAULT 'CREATE',
  material_id VARCHAR(36) NOT NULL,
  notes TEXT,
  quantity_used INT NOT NULL,
  sku_id VARCHAR(36),
  
  FOREIGN KEY (purchase_id) REFERENCES purchases(id) ON DELETE RESTRICT,
  FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT,
  INDEX idx_material_usage_purchase_id (purchase_id),
  INDEX idx_material_usage_product_id (product_id),
  INDEX idx_material_usage_action (action)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.8 SKU主表（product_skus）

```sql
CREATE TABLE product_skus (
  id VARCHAR(36) PRIMARY KEY,
  sku_code VARCHAR(50) UNIQUE NOT NULL,
  sku_name VARCHAR(200) NOT NULL,
  material_signature_hash VARCHAR(32) NOT NULL,
  material_signature JSON NOT NULL,
  total_quantity INT DEFAULT 0,
  available_quantity INT DEFAULT 0,
  unit_price DECIMAL(10,2) NOT NULL,
  total_value DECIMAL(10,2) NOT NULL,
  photos JSON,
  description TEXT,
  specification VARCHAR(100),
  material_cost DECIMAL(10,2),
  labor_cost DECIMAL(10,2),
  craft_cost DECIMAL(10,2),
  total_cost DECIMAL(10,2),
  selling_price DECIMAL(10,2) NOT NULL,
  profit_margin DECIMAL(5,2),
  status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(36) NOT NULL,
  
  FOREIGN KEY (created_by) REFERENCES users(id),
  INDEX idx_product_skus_sku_code (sku_code),
  INDEX idx_product_skus_material_hash (material_signature_hash),
  INDEX idx_product_skus_status (status),
  INDEX idx_product_skus_created_by (created_by)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**SKU字段说明：**
- `sku_code`: SKU编号
- `sku_name`: SKU名称
- `material_signature_hash`: 原材料标识哈希值
- `material_signature`: 原材料标识JSON
- `total_quantity`: 总数量
- `available_quantity`: 可售数量
- `material_cost`: 原材料成本
- `labor_cost`: 人工成本
- `craft_cost`: 工艺成本
- `selling_price`: 销售价格
- `profit_margin`: 利润率

### 2.9 SKU库存变更日志表（sku_inventory_logs）

```sql
CREATE TABLE sku_inventory_logs (
  id VARCHAR(36) PRIMARY KEY,
  sku_id VARCHAR(36) NOT NULL,
  action ENUM('CREATE', 'SELL', 'ADJUST', 'DESTROY') NOT NULL,
  quantity_change INT NOT NULL,
  quantity_before INT NOT NULL,
  quantity_after INT NOT NULL,
  reference_type ENUM('PRODUCT', 'SALE', 'MANUAL', 'DESTROY', 'REFUND') NOT NULL,
  reference_id VARCHAR(36),
  notes TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  user_id VARCHAR(36) NOT NULL,
  
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  INDEX idx_sku_inventory_logs_sku_id (sku_id),
  INDEX idx_sku_inventory_logs_action (action),
  INDEX idx_sku_inventory_logs_created_at (created_at DESC),
  INDEX idx_sku_inventory_logs_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.10 审计日志表（audit_logs）

```sql
CREATE TABLE audit_logs (
  id VARCHAR(36) PRIMARY KEY,
  user_id VARCHAR(36),
  action VARCHAR(100) NOT NULL,
  resource VARCHAR(100) NOT NULL,
  resource_id VARCHAR(36),
  details TEXT,
  ip_address VARCHAR(45),
  user_agent VARCHAR(500),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  INDEX idx_audit_logs_user_id (user_id),
  INDEX idx_audit_logs_action (action),
  INDEX idx_audit_logs_resource (resource),
  INDEX idx_audit_logs_created_at (created_at DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.11 客户表（customers）

```sql
CREATE TABLE customers (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  phone VARCHAR(20) UNIQUE NOT NULL,
  address TEXT,
  notes TEXT,
  total_purchases DECIMAL(10,2) DEFAULT 0.00,
  total_orders INT DEFAULT 0,
  first_purchase_date TIMESTAMP NULL,
  last_purchase_date TIMESTAMP NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  birthday TIMESTAMP NULL,
  wechat VARCHAR(100),
  average_order_value DECIMAL(10,2) DEFAULT 0.00,
  city VARCHAR(50),
  customer_labels JSON,
  days_since_first_purchase INT,
  days_since_last_purchase INT,
  primary_label VARCHAR(50),
  province VARCHAR(50),
  refund_count INT DEFAULT 0,
  refund_rate DECIMAL(5,2) DEFAULT 0.00,
  total_all_orders INT DEFAULT 0,
  
  INDEX idx_customers_name (name),
  INDEX idx_customers_phone (phone),
  INDEX idx_customers_city (city),
  INDEX idx_customers_province (province)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.12 客户备注表（customer_notes）

```sql
CREATE TABLE customer_notes (
  id VARCHAR(36) PRIMARY KEY,
  customer_id VARCHAR(36) NOT NULL,
  category ENUM('PREFERENCE', 'BEHAVIOR', 'CONTACT', 'OTHER') NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(36) NOT NULL,
  
  FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE,
  FOREIGN KEY (created_by) REFERENCES users(id),
  INDEX idx_customer_notes_customer_id (customer_id),
  INDEX idx_customer_notes_category (category),
  INDEX idx_customer_notes_created_by (created_by)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.13 客户购买记录表（customer_purchases）

```sql
CREATE TABLE customer_purchases (
  id VARCHAR(36) PRIMARY KEY,
  customer_id VARCHAR(36) NOT NULL,
  sku_id VARCHAR(36) NOT NULL,
  sku_name VARCHAR(200) NOT NULL,
  quantity INT NOT NULL,
  unit_price DECIMAL(10,2) NOT NULL,
  original_price DECIMAL(10,2),
  total_price DECIMAL(10,2) NOT NULL,
  status ENUM('ACTIVE', 'REFUNDED') DEFAULT 'ACTIVE',
  refund_date TIMESTAMP NULL,
  refund_reason VARCHAR(200),
  refund_notes TEXT,
  sale_channel VARCHAR(50),
  notes TEXT,
  purchase_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  FOREIGN KEY (customer_id) REFERENCES customers(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  INDEX idx_customer_purchases_customer_id (customer_id),
  INDEX idx_customer_purchases_sku_id (sku_id),
  INDEX idx_customer_purchases_purchase_date (purchase_date DESC),
  INDEX idx_customer_purchases_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.14 财务记录表（financial_records）

```sql
CREATE TABLE financial_records (
  id VARCHAR(36) PRIMARY KEY,
  record_type ENUM('INCOME', 'EXPENSE', 'REFUND', 'LOSS') NOT NULL,
  amount DECIMAL(10,2) NOT NULL,
  description VARCHAR(200) NOT NULL,
  reference_type ENUM('PURCHASE', 'SALE', 'REFUND', 'MANUAL') NOT NULL,
  reference_id VARCHAR(36),
  category VARCHAR(100),
  transaction_date TIMESTAMP NOT NULL,
  notes TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  user_id VARCHAR(36) NOT NULL,
  
  FOREIGN KEY (user_id) REFERENCES users(id),
  INDEX idx_financial_records_record_type (record_type),
  INDEX idx_financial_records_reference_type (reference_type),
  INDEX idx_financial_records_reference_id (reference_id),
  INDEX idx_financial_records_transaction_date (transaction_date DESC),
  INDEX idx_financial_records_user_id (user_id),
  INDEX idx_financial_records_created_at (created_at DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

## 三、枚举类型定义

### 3.1 用户角色（UserRole）
```sql
ENUM('BOSS', 'EMPLOYEE')
```

### 3.2 品质等级（Quality）
```sql
ENUM('AA', 'A', 'AB', 'B', 'C')
```

### 3.3 产品类型（ProductType）
```sql
ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED_MATERIAL')
```
- `LOOSE_BEADS`: 散珠
- `BRACELET`: 手串
- `ACCESSORIES`: 配件
- `FINISHED_MATERIAL`: 成品

### 3.4 计量单位（UnitType）
```sql
ENUM('PIECES', 'STRINGS', 'SLICES', 'ITEMS')
```
- `PIECES`: 颗
- `STRINGS`: 串
- `SLICES`: 片
- `ITEMS`: 件

### 3.5 产品状态（ProductStatus）
```sql
ENUM('MAKING', 'AVAILABLE', 'SOLD', 'OFFLINE')
```

### 3.6 SKU状态（SkuStatus）
```sql
ENUM('ACTIVE', 'INACTIVE')
```

### 3.7 财务记录类型（financial_records_recordType）
```sql
ENUM('INCOME', 'EXPENSE', 'REFUND', 'LOSS')
```

### 3.8 客户备注分类（customer_notes_category）
```sql
ENUM('PREFERENCE', 'BEHAVIOR', 'CONTACT', 'OTHER')
```

### 3.9 SKU库存操作类型（sku_inventory_logs_action）
```sql
ENUM('CREATE', 'SELL', 'ADJUST', 'DESTROY')
```

### 3.10 财务记录引用类型（financial_records_referenceType）
```sql
ENUM('PURCHASE', 'SALE', 'REFUND', 'MANUAL')
```

### 3.11 SKU库存引用类型（sku_inventory_logs_referenceType）
```sql
ENUM('PRODUCT', 'SALE', 'MANUAL', 'DESTROY', 'REFUND')
```

### 3.12 原材料使用操作类型（material_usage_action）
```sql
ENUM('CREATE', 'USE', 'RETURN', 'ADJUST')
```

### 3.13 客户购买状态（customer_purchases_status）
```sql
ENUM('ACTIVE', 'REFUNDED')
```

### 3.14 采购状态（purchases_status）
```sql
ENUM('ACTIVE', 'USED')
```

## 四、purchase到material映射数据库规范（核心机制）

### 4.1 映射逻辑数据库实现

**核心原理：**
- 采购表（purchases）存储原始采购数据
- 库存查询时通过mapPurchaseToMaterial函数进行字段映射
- 前端统一使用material_*字段名，保持一致性

**字段映射SQL示例：**
```sql
-- 库存查询中的字段映射
SELECT 
  p.id as purchase_id,
  p.purchase_code as purchase_code,  -- 映射为material_code
  p.purchase_name as purchase_name,  -- 映射为material_name
  p.purchase_type as purchase_type,  -- 映射为material_type
  p.purchase_date as purchase_date,  -- 映射为material_date
  CASE 
    WHEN p.purchase_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
    WHEN p.purchase_type = 'BRACELET' THEN COALESCE(p.total_beads, p.piece_count, 0)
    WHEN p.purchase_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
    WHEN p.purchase_type = 'FINISHED_MATERIAL' THEN COALESCE(p.piece_count, 0)
    ELSE COALESCE(p.quantity, 0)
  END as original_quantity,
  COALESCE(mu.used_quantity, 0) as used_quantity,
  (CASE 
    WHEN p.purchase_type = 'LOOSE_BEADS' THEN COALESCE(p.piece_count, 0)
    WHEN p.purchase_type = 'BRACELET' THEN COALESCE(p.total_beads, p.piece_count, 0)
    WHEN p.purchase_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 0)
    WHEN p.purchase_type = 'FINISHED_MATERIAL' THEN COALESCE(p.piece_count, 0)
    ELSE COALESCE(p.quantity, 0)
  END - COALESCE(mu.used_quantity, 0)) as remaining_quantity
FROM purchases p
LEFT JOIN (
  SELECT purchase_id, SUM(quantity_used) as used_quantity
  FROM material_usage
  GROUP BY purchase_id
) mu ON p.id = mu.purchase_id
```

### 4.2 库存计算规则

**原始数量计算：**
- **散珠（LOOSE_BEADS）**：使用piece_count字段
- **手串（BRACELET）**：优先使用total_beads，备选piece_count
- **配件（ACCESSORIES）**：使用piece_count字段
- **成品原材料（FINISHED_MATERIAL）**：使用piece_count字段

**剩余数量计算：**
```sql
remaining_quantity = original_quantity - COALESCE(used_quantity, 0)
```

**库存状态判断：**
```sql
CASE 
  WHEN remaining_quantity <= 0 THEN 'out'
  WHEN p.min_stock_alert IS NOT NULL AND remaining_quantity <= p.min_stock_alert THEN 'low'
  ELSE 'sufficient'
END as stock_status
```

### 4.3 数据类型安全处理

**数值字段类型转换：**
```sql
-- 确保返回数字类型，避免字符串拼接问题
CAST(COALESCE(SUM(mu.quantity_used_beads), 0) + COALESCE(SUM(mu.quantity_used_pieces), 0) AS UNSIGNED) as total_consumed

-- 价格字段处理
CAST(p.price_per_gram AS DECIMAL(10,2)) as price_per_gram,
CAST(p.total_price AS DECIMAL(12,2)) as total_price
```

**BigInt字段处理：**
- 数据库查询返回的BigInt字段需要在后端转换为Number
- 前端显示前进行防护性Number()转换
- 避免JavaScript中的字符串拼接问题

## 五、数据库设计原则

### 5.1 命名规范原则
1. **全蛇形命名**：所有表名、字段名、索引名都使用snake_case
2. **语义明确**：字段名能清楚表达其含义
3. **统一性**：相同含义的字段在不同表中使用相同命名
4. **可扩展性**：预留扩展空间，避免频繁修改表结构

### 4.2 数据类型规范
1. **主键**：统一使用VARCHAR(36)存储cuid
2. **价格字段**：使用DECIMAL(10,2)或DECIMAL(10,4)确保精度
3. **时间字段**：使用TIMESTAMP类型
4. **JSON字段**：用于存储复杂数据结构（如photos、material_signature）
5. **枚举字段**：使用ENUM类型限制取值范围

### 5.3 库存查询优化索引（重要更新）

**原材料库存查询专用索引：**
```sql
-- 库存搜索优化索引
CREATE INDEX idx_inventory_search ON purchases(purchase_name, purchase_code);

-- 库存筛选优化索引
CREATE INDEX idx_inventory_filter ON purchases(purchase_type, quality, purchase_date);

-- 供应商筛选索引
CREATE INDEX idx_inventory_supplier ON purchases(supplier_id);

-- 价格范围筛选索引
CREATE INDEX idx_inventory_price_range ON purchases(price_per_gram, total_price);

-- 规格范围筛选索引
CREATE INDEX idx_inventory_spec_range ON purchases(bead_diameter, specification);

-- 库存排序优化索引
CREATE INDEX idx_inventory_sort ON purchases(purchase_date DESC, created_at DESC);

-- 库存状态查询索引
CREATE INDEX idx_inventory_status ON purchases(purchase_type, min_stock_alert);
```

**material_usage表优化索引：**
```sql
-- 使用量汇总查询优化
CREATE INDEX idx_material_usage_summary ON material_usage(purchase_id, quantity_used);

-- 成品关联查询优化
CREATE INDEX idx_material_usage_product ON material_usage(product_id, purchase_id);
```

### 5.4 索引设计原则
1. **主键索引**：每个表都有主键索引
2. **外键索引**：所有外键字段都建立索引
3. **查询索引**：根据常用查询条件建立复合索引
4. **唯一索引**：确保业务唯一性（如user_name、phone、purchase_code）
5. **全文索引**：支持文本搜索的字段建立FULLTEXT索引
6. **库存专用索引**：针对库存查询场景的专门优化

### 4.4 关系设计原则
1. **外键约束**：确保数据完整性
2. **级联操作**：合理设置ON DELETE和ON UPDATE规则
3. **软删除**：重要数据使用状态字段而非物理删除
4. **审计追踪**：重要操作记录到audit_logs表

## 五、数据完整性规则

### 5.1 必填字段验证
- 用户表：user_name、password、name、role
- 采购表：purchase_code、product_name、product_type、user_id
- 客户表：name、phone
- SKU表：sku_code、sku_name、material_signature、selling_price

### 5.2 唯一性约束
- users.user_name：用户名唯一
- users.email：邮箱唯一（如果提供）
- suppliers.name：供应商名称唯一
- purchases.purchase_code：采购编号唯一
- product_skus.sku_code：SKU编号唯一
- customers.phone：客户手机号唯一

### 5.3 数据范围约束
- 价格字段：必须大于等于0
- 数量字段：必须大于等于0
- 百分比字段：0-100之间
- 枚举字段：只能取预定义值

### 5.4 关联完整性
- 所有外键必须引用存在的记录
- 删除父记录时，子记录的处理策略明确
- 重要关联使用RESTRICT防止误删

## 六、性能优化建议

### 6.1 索引优化
1. **复合索引**：根据查询模式建立复合索引
2. **覆盖索引**：减少回表查询
3. **前缀索引**：对长字符串字段使用前缀索引
4. **索引维护**：定期分析索引使用情况

### 6.2 查询优化
1. **分页查询**：使用LIMIT和OFFSET
2. **条件过滤**：在WHERE子句中使用索引字段
3. **JOIN优化**：合理使用JOIN类型
4. **子查询优化**：避免相关子查询

### 6.3 存储优化
1. **数据类型选择**：选择合适的数据类型
2. **字段长度**：根据实际需要设置字段长度
3. **NULL值处理**：合理使用NULL和默认值
4. **分区策略**：对大表考虑分区

## 七、安全性考虑

### 7.1 数据访问控制
1. **用户权限**：基于角色的访问控制
2. **敏感数据**：密码加密存储
3. **审计日志**：记录所有重要操作
4. **数据脱敏**：敏感字段在非生产环境脱敏

### 7.2 数据备份策略
1. **定期备份**：每日全量备份
2. **增量备份**：实时或定时增量备份
3. **异地备份**：备份文件异地存储
4. **恢复测试**：定期测试备份恢复

### 7.3 数据加密
1. **传输加密**：使用SSL/TLS加密传输
2. **存储加密**：敏感字段加密存储
3. **密钥管理**：安全的密钥管理机制
4. **访问日志**：记录数据访问日志

## 八、维护和监控

### 8.1 数据库监控
1. **性能监控**：查询性能、连接数、锁等待
2. **空间监控**：表空间、索引空间使用情况
3. **错误监控**：数据库错误日志监控
4. **备份监控**：备份任务执行状态

### 8.2 数据质量监控
1. **数据一致性**：定期检查数据一致性
2. **数据完整性**：检查外键约束
3. **业务规则**：验证业务逻辑正确性
4. **异常数据**：识别和处理异常数据

### 8.3 版本管理
1. **Schema版本**：数据库结构版本管理
2. **迁移脚本**：结构变更的迁移脚本
3. **回滚策略**：变更失败的回滚方案
4. **测试验证**：变更前的充分测试

---

**注意：本文档严格遵循全蛇形命名规范（snake_case），所有字段名、表名都使用下划线分隔，与实际Prisma schema代码完全一致。**