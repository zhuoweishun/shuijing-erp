# 文档 03：数据库设计与数据规则文档

## 一、数据库架构概览

### 1.1 核心表结构
本系统采用MySQL数据库，基于**独立materials表架构**，包含以下核心表：
- **原材料表（materials）** - 核心库存数据表
- 采购表（purchases）- 原始采购记录表
- 用户表（users）
- 供应商表（suppliers）
- 成品表（products）
- 原材料使用记录表（material_usage）
- SKU主表（product_skus）
- SKU库存变更日志表（sku_inventory_logs）
- 审计日志表（audit_logs）
- 客户表（customers）
- 客户备注表（customer_notes）
- 客户购买记录表（customer_purchases）
- 财务记录表（financial_records）
- 系统配置表（system_configs）
- 编辑日志表（edit_logs）

### 1.2 独立materials表架构（核心创新）

**架构原理：**
- **purchases表**：存储原始采购数据，保持采购记录的完整性
- **materials表**：存储转换后的库存数据，作为库存管理的唯一数据源
- **数据同步**：通过触发器实现purchases→materials的自动同步
- **业务分离**：采购管理和库存管理完全解耦，各自独立

**核心优势：**
1. **数据一致性**：库存数据统一来源，避免计算误差
2. **性能优化**：库存查询直接读取materials表，无需复杂计算
3. **业务清晰**：采购和库存职责分离，逻辑更清晰
4. **扩展性强**：支持复杂的库存管理需求

### 1.3 字段命名规范（全蛇形命名）
- **严格使用snake_case命名**：所有字段都使用下划线分隔（如：material_name、purchase_code、remaining_quantity）
- **主键统一使用id**：String类型，使用cuid()生成
- **外键使用{table}_id格式**：如user_id、supplier_id、material_id
- **时间字段使用_at后缀**：created_at、updated_at、last_login_at
- **编号字段使用_code后缀**：purchase_code、material_code、sku_code
- **价格字段使用price_per_前缀**：price_per_gram、price_per_bead、price_per_piece
- **数量字段明确含义**：original_quantity、used_quantity、remaining_quantity
- **状态字段使用枚举**：material_type、quality、stock_status等

## 二、核心表结构设计

### 2.1 原材料表（materials）- 核心库存数据表

```sql
CREATE TABLE materials (
  id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
  material_code VARCHAR(50) UNIQUE NOT NULL COMMENT '原材料编号（来自purchase_code）',
  material_name VARCHAR(255) NOT NULL COMMENT '原材料名称（来自purchase_name）',
  material_type ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED_MATERIAL') NOT NULL COMMENT '原材料类型',
  quality ENUM('AA', 'A', 'AB', 'B', 'C', 'UNKNOWN') DEFAULT 'UNKNOWN' COMMENT '品质等级',
  
  -- 规格信息（根据类型动态使用）
  bead_diameter DECIMAL(5,2) COMMENT '珠子直径(mm)',
  bracelet_inner_diameter DECIMAL(5,2) COMMENT '手串内径(mm)',
  bracelet_bead_count INT COMMENT '手串珠子数量',
  accessory_specification VARCHAR(100) COMMENT '配件规格',
  finished_material_specification VARCHAR(100) COMMENT '成品规格',
  
  -- 转换后的库存数据（核心字段）
  original_quantity INT NOT NULL COMMENT '原始数量（转换单位后）',
  used_quantity INT DEFAULT 0 COMMENT '已使用数量',
  remaining_quantity INT GENERATED ALWAYS AS (original_quantity - used_quantity) STORED COMMENT '剩余数量（计算字段）',
  inventory_unit ENUM('PIECES', 'STRINGS', 'SLICES', 'ITEMS') NOT NULL COMMENT '库存计量单位',
  
  -- 价格信息
  unit_cost DECIMAL(10,4) NOT NULL COMMENT '单位成本（转换后）',
  total_cost DECIMAL(12,2) NOT NULL COMMENT '总成本',
  
  -- 库存管理字段
  min_stock_alert INT COMMENT '最低库存预警',
  stock_status ENUM('SUFFICIENT', 'LOW', 'OUT') GENERATED ALWAYS AS (
    CASE 
      WHEN remaining_quantity <= 0 THEN 'OUT'
      WHEN min_stock_alert IS NOT NULL AND remaining_quantity <= min_stock_alert THEN 'LOW'
      ELSE 'SUFFICIENT'
    END
  ) STORED COMMENT '库存状态（计算字段）',
  
  -- 关联信息
  purchase_id VARCHAR(36) NOT NULL COMMENT '关联的采购记录ID',
  supplier_id VARCHAR(36) COMMENT '供应商ID',
  
  -- 附加信息
  photos JSON COMMENT '照片URLs',
  material_date DATE NOT NULL COMMENT '入库日期（来自purchase_date）',
  notes TEXT COMMENT '备注',
  
  -- 审计字段
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(36) NOT NULL COMMENT '创建人',
  
  FOREIGN KEY (purchase_id) REFERENCES purchases(id) ON DELETE RESTRICT,
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id) ON DELETE SET NULL,
  FOREIGN KEY (created_by) REFERENCES users(id),
  
  -- 索引设计
  INDEX idx_materials_code (material_code),
  INDEX idx_materials_name (material_name),
  INDEX idx_materials_type_quality (material_type, quality),
  INDEX idx_materials_purchase_id (purchase_id),
  INDEX idx_materials_supplier_id (supplier_id),
  INDEX idx_materials_stock_status (stock_status),
  INDEX idx_materials_remaining_quantity (remaining_quantity),
  INDEX idx_materials_date (material_date DESC),
  INDEX idx_materials_search (material_name, material_code),
  INDEX idx_materials_inventory_filter (material_type, quality, stock_status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**核心字段说明：**
- `material_code`: 原材料编号，来自purchase_code
- `material_name`: 原材料名称，来自purchase_name
- `material_type`: 原材料类型（LOOSE_BEADS/BRACELET/ACCESSORIES/FINISHED_MATERIAL）
- `original_quantity`: 转换单位后的原始数量（不可修改）
- `used_quantity`: 已使用数量（通过material_usage表更新）
- `remaining_quantity`: 剩余数量（计算字段：original_quantity - used_quantity）
- `inventory_unit`: 库存计量单位（PIECES/STRINGS/SLICES/ITEMS）
- `unit_cost`: 单位成本（转换后的每颗/每片/每件成本）
- `stock_status`: 库存状态（自动计算：SUFFICIENT/LOW/OUT）

### 2.2 采购表（purchases）- 原始采购记录表（已修复）

**修复内容：**
- 统一字段名称：purchase_name替代product_name
- 修复产品类型：FINISHED_MATERIAL替代FINISHED
- 增强数据验证：按类型差异化验证规则
- 完善字段注释：明确字段用途和约束
- 优化索引设计：支持高效的搜索和筛选

```sql
CREATE TABLE purchases (
    id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
    purchase_code VARCHAR(50) UNIQUE NOT NULL COMMENT '采购编号',
    purchase_name VARCHAR(255) NOT NULL COMMENT '产品名称（修复：统一字段名）',
    purchase_type ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED_MATERIAL') NOT NULL COMMENT '产品类型（修复：FINISHED_MATERIAL替代FINISHED）',
    quality ENUM('AA', 'A', 'AB', 'B', 'C', 'UNKNOWN') DEFAULT 'UNKNOWN' COMMENT '品质等级',
    
    -- 规格信息（根据类型动态使用）
    bead_diameter DECIMAL(5,2) COMMENT '珠子直径(mm)',
    bracelet_inner_diameter DECIMAL(5,2) COMMENT '手串内径(mm)',
    bracelet_bead_count INT COMMENT '手串珠子数量',
    accessory_specification VARCHAR(100) COMMENT '配件规格',
    finished_material_specification VARCHAR(100) COMMENT '成品规格',
    
    -- 采购数量和价格信息
    quantity DECIMAL(10,2) NOT NULL COMMENT '数量',
    piece_count INT COMMENT '件数',
    price_per_gram DECIMAL(10,2) COMMENT '克价',
    weight DECIMAL(10,2) COMMENT '重量(克)',
    total_price DECIMAL(12,2) NOT NULL COMMENT '总价',
    
    -- 计算字段（采购阶段使用）
    total_beads INT COMMENT '总颗数（散珠/手串）',
    price_per_bead DECIMAL(10,4) COMMENT '每颗价格',
    price_per_piece DECIMAL(10,4) COMMENT '每片/件价格',
    unit_price DECIMAL(10,2) COMMENT '单价',
    
    -- 关联信息
    supplier_id VARCHAR(36) COMMENT '供应商ID',
    user_id VARCHAR(36) NOT NULL COMMENT '录入人',
    
    -- 附加信息
    photos JSON COMMENT '照片URLs（JSON数组格式）',
    purchase_date DATE NOT NULL COMMENT '采购日期',
    notes TEXT COMMENT '备注',
    natural_language_input TEXT COMMENT '自然语言录入信息（新增）',
    ai_recognition_result JSON COMMENT 'AI识别结果（新增）',
    
    -- 状态管理
    status ENUM('ACTIVE', 'USED') DEFAULT 'ACTIVE' COMMENT '状态（影响删除权限，不影响库存）',
    min_stock_alert INT COMMENT '最低库存预警',
    
    -- 审计字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id) ON DELETE SET NULL,
    FOREIGN KEY (user_id) REFERENCES users(id),
    
    -- 索引设计（采购列表查询优化）
     INDEX idx_purchases_code (purchase_code),
     INDEX idx_purchases_name (purchase_name),
     INDEX idx_purchases_type_quality (purchase_type, quality),
     INDEX idx_purchases_supplier (supplier_id),
     INDEX idx_purchases_date (purchase_date DESC),
     INDEX idx_purchases_search (purchase_name, purchase_code), -- 搜索优化索引
     INDEX idx_purchases_filter (purchase_type, quality, purchase_date), -- 筛选优化索引
     INDEX idx_purchases_price_range (price_per_gram, total_price), -- 价格范围筛选索引
     INDEX idx_purchases_spec_range (bead_diameter, bracelet_inner_diameter), -- 规格范围筛选索引
     INDEX idx_purchases_date_sort (purchase_date DESC, created_at DESC) -- 排序优化索引
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**数据验证规则（按类型差异化）：**
```sql
-- 散珠/手串类型验证
CHECK (
  CASE 
    WHEN purchase_type IN ('LOOSE_BEADS', 'BRACELET') THEN
      price_per_gram IS NOT NULL AND price_per_gram > 0 AND
      weight IS NOT NULL AND weight > 0 AND
      bead_diameter IS NOT NULL AND bead_diameter > 0
    ELSE TRUE
  END
),

-- 手串特殊验证
CHECK (
  CASE 
    WHEN purchase_type = 'BRACELET' THEN
      bracelet_bead_count IS NOT NULL AND bracelet_bead_count > 0
    ELSE TRUE
  END
),

-- 配件/成品类型验证
CHECK (
  CASE 
    WHEN purchase_type IN ('ACCESSORIES', 'FINISHED_MATERIAL') THEN
      piece_count IS NOT NULL AND piece_count > 0
    ELSE TRUE
  END
)
```

**自动计算逻辑（触发器实现）：**
```sql
-- 散珠总颗数计算
total_beads = CASE 
  WHEN bead_diameter = 4.0 THEN FLOOR(weight * 25)
  WHEN bead_diameter = 6.0 THEN FLOOR(weight * 11)
  WHEN bead_diameter = 8.0 THEN FLOOR(weight * 6)
  WHEN bead_diameter = 10.0 THEN FLOOR(weight * 4)
  WHEN bead_diameter = 12.0 THEN FLOOR(weight * 3)
  ELSE FLOOR(weight * 5)
END

-- 单位成本计算
price_per_bead = total_price / total_beads  -- 散珠/手串
price_per_piece = total_price / piece_count  -- 配件/成品
```

**重要说明：**
- purchases表保持原始采购数据的完整性
- status字段只影响记录的删除权限，不影响库存计算
- 库存管理完全基于materials表，与purchases.status无关
- 所有字段名称已统一为蛇形命名规范
- 产品类型枚举值已修复为标准值

### 2.3 原材料使用记录表（material_usage）

```sql
CREATE TABLE material_usage (
  id VARCHAR(36) PRIMARY KEY,
  material_id VARCHAR(36) NOT NULL COMMENT '关联的原材料ID',
  product_id VARCHAR(36) COMMENT '关联的成品ID',
  sku_id VARCHAR(36) COMMENT '关联的SKU ID',
  quantity_used INT NOT NULL COMMENT '使用数量',
  unit_cost DECIMAL(10,4) COMMENT '单位成本',
  total_cost DECIMAL(10,2) COMMENT '总成本',
  action ENUM('CREATE', 'USE', 'RETURN', 'ADJUST') DEFAULT 'USE' COMMENT '操作类型',
  notes TEXT COMMENT '备注',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  user_id VARCHAR(36) NOT NULL COMMENT '操作人',
  
  FOREIGN KEY (material_id) REFERENCES materials(id) ON DELETE RESTRICT,
  FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT,
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE RESTRICT,
  FOREIGN KEY (user_id) REFERENCES users(id),
  
  INDEX idx_material_usage_material_id (material_id),
  INDEX idx_material_usage_product_id (product_id),
  INDEX idx_material_usage_sku_id (sku_id),
  INDEX idx_material_usage_action (action),
  INDEX idx_material_usage_created_at (created_at DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.4 用户表（users）

```sql
CREATE TABLE users (
  id VARCHAR(36) PRIMARY KEY,
  user_name VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(100) UNIQUE,
  password VARCHAR(255) NOT NULL,
  role ENUM('BOSS', 'EMPLOYEE') DEFAULT 'EMPLOYEE',
  name VARCHAR(100) NOT NULL,
  phone VARCHAR(20),
  avatar VARCHAR(500),
  is_active BOOLEAN DEFAULT TRUE,
  last_login_at TIMESTAMP NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**字段说明：**
- `user_name`: 登录用户名，唯一
- `name`: 真实姓名
- `role`: 用户角色（BOSS/EMPLOYEE）
- `is_active`: 账户状态
- `last_login_at`: 最后登录时间

### 2.2 供应商表（suppliers）

```sql
CREATE TABLE suppliers (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(200) UNIQUE NOT NULL,
  contact VARCHAR(100),
  phone VARCHAR(20),
  email VARCHAR(100),
  address VARCHAR(500),
  description TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.2.1 采购表 (purchases) - 完整优化版

**表结构：**
```sql
CREATE TABLE purchases (
    id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
    purchase_code VARCHAR(50) UNIQUE NOT NULL COMMENT '采购编号',
    purchase_name VARCHAR(255) NOT NULL COMMENT '产品名称',
    purchase_type ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED_MATERIAL') NOT NULL COMMENT '产品类型',
    quality ENUM('AA', 'A', 'AB', 'B', 'C', 'UNKNOWN') DEFAULT 'UNKNOWN' COMMENT '品质等级',
    bead_diameter DECIMAL(5,2) COMMENT '珠子直径(mm)',
    bracelet_inner_diameter DECIMAL(5,2) COMMENT '手串内径(mm)',
    bracelet_bead_count INT COMMENT '手串珠子数量',
    accessory_specification VARCHAR(100) COMMENT '配件规格',
    finished_material_specification VARCHAR(100) COMMENT '成品规格',
    quantity DECIMAL(10,2) NOT NULL COMMENT '数量',
    piece_count INT COMMENT '件数',
    price_per_gram DECIMAL(10,2) COMMENT '克价',
    weight DECIMAL(10,2) COMMENT '重量(克)',
    total_price DECIMAL(12,2) NOT NULL COMMENT '总价',
    supplier_id VARCHAR(36) COMMENT '供应商ID',
    photos JSON COMMENT '照片URLs',
    purchase_date DATE NOT NULL COMMENT '采购日期',
    notes TEXT COMMENT '备注',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id) ON DELETE SET NULL
);

-- 采购列表查询优化索引
CREATE INDEX idx_purchases_search ON purchases(purchase_name, purchase_code);
CREATE INDEX idx_purchases_filter ON purchases(purchase_type, quality, purchase_date);
CREATE INDEX idx_purchases_supplier ON purchases(supplier_id);
CREATE INDEX idx_purchases_price_range ON purchases(price_per_gram, total_price);
CREATE INDEX idx_purchases_spec_range ON purchases(bead_diameter, bracelet_inner_diameter);
CREATE INDEX idx_purchases_date_sort ON purchases(purchase_date DESC, created_at DESC);
```

**采购列表字段映射规则：**
- **规格字段动态选择**：根据产品类型自动选择对应规格字段
  - LOOSE_BEADS → bead_diameter
  - BRACELET → bracelet_inner_diameter  
  - ACCESSORIES → accessory_specification
  - FINISHED_MATERIAL → finished_material_specification
- **搜索字段**：purchase_name（产品名称）、purchase_code（采购编号）支持模糊匹配
- **筛选字段**：支持多选的quality、purchase_type、supplier，支持范围筛选的价格和规格
- **排序字段**：所有数值字段支持升序/降序排序，规格字段根据产品类型动态选择

### 2.3 采购表（purchases）

```sql
CREATE TABLE purchases (
  id VARCHAR(36) PRIMARY KEY,
  purchase_code VARCHAR(50) UNIQUE NOT NULL,
  purchase_name VARCHAR(200) NOT NULL,
  quantity INT,
  min_stock_alert INT,
  price_per_gram DECIMAL(10,1),
  unit_price DECIMAL(10,1),
  total_price DECIMAL(10,1),
  weight DECIMAL(10,1),
  bead_diameter DECIMAL(10,1),
  beads_per_string INT,
  total_beads INT,
  price_per_bead DECIMAL(10,4),
  price_per_piece DECIMAL(10,4),
  quality ENUM('AA', 'A', 'AB', 'B', 'C'),
  purchase_type ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED') DEFAULT 'BRACELET',
  unit_type ENUM('PIECES', 'STRINGS', 'SLICES', 'ITEMS') DEFAULT 'STRINGS'
  specification DECIMAL(10,1),
  piece_count INT,
  purchase_date TIMESTAMP NOT NULL,
  natural_language_input TEXT,
  photos JSON,
  notes TEXT,
  ai_recognition_result JSON,
  status ENUM('ACTIVE', 'USED') DEFAULT 'ACTIVE',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  supplier_id VARCHAR(36),
  user_id VARCHAR(36) NOT NULL,
  last_edited_by_id VARCHAR(36),
  
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (last_edited_by_id) REFERENCES users(id),
  INDEX idx_purchases_purchase_code (purchase_code),
  INDEX idx_purchases_purchase_type (purchase_type),
  INDEX idx_purchases_quality (quality),
  INDEX idx_purchases_purchase_date (purchase_date DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**重要字段说明（已修复）：**
- `purchase_code`: 采购编号，格式为CG+YYYYMMDD+序号（如：CG20241231001）
- `purchase_name`: 采购名称（修复：统一使用purchase_name而非product_name）
- `purchase_type`: 采购类型（LOOSE_BEADS/BRACELET/ACCESSORIES/FINISHED_MATERIAL）
- `unit_type`: 计量单位（PIECES/STRINGS/SLICES/ITEMS）
- `bead_diameter`: 珠子直径（散珠/手串专用）
- `price_per_gram`: 克价（散珠/手串专用）
- `price_per_bead`: 每颗价格（散珠/手串专用，自动计算）
- `price_per_piece`: 每片/件价格（配件/成品专用，自动计算）
- `total_beads`: 总颗数（散珠专用，自动计算）
- `beads_per_string`: 每串颗数（手串专用）
- `piece_count`: 片数/件数（配件/成品专用）
- `weight`: 重量（散珠/手串专用）
- `min_stock_alert`: 最低预警颗数
- `photos`: 图片URL数组（JSON格式存储）
- `natural_language_input`: 自然语言录入信息
- `ai_recognition_result`: AI识别结果（JSON格式存储）
- `status`: 状态（ACTIVE/USED）
- `remaining_quantity`: 剩余数量（库存视图计算字段）

**采购类型字段映射规则：**
| 采购类型 | 英文标识 | 必填字段 | 计算字段 | 单位类型 |
|----------|----------|----------|----------|----------|
| 散珠 | LOOSE_BEADS | price_per_gram, weight, bead_diameter | total_beads, price_per_bead | PIECES |
| 手串 | BRACELET | price_per_gram, weight, bead_diameter, beads_per_string | price_per_bead | STRINGS |
| 配件 | ACCESSORIES | piece_count, total_price | price_per_piece | SLICES/ITEMS |
| 成品 | FINISHED_MATERIAL | piece_count, total_price | price_per_piece | ITEMS |

**自动计算字段逻辑：**
```sql
-- 散珠总颗数计算（基于重量和直径）
total_beads = CASE 
  WHEN bead_diameter = 4.0 THEN weight * 25
  WHEN bead_diameter = 6.0 THEN weight * 11
  WHEN bead_diameter = 8.0 THEN weight * 6
  WHEN bead_diameter = 10.0 THEN weight * 4
  WHEN bead_diameter = 12.0 THEN weight * 3
  ELSE weight * 5
END

-- 每颗价格计算
price_per_bead = total_price / total_beads

-- 每片/件价格计算
price_per_piece = total_price / piece_count
```

**数据验证规则：**
- `purchase_name`: 长度2-200字符，不能为空
- `purchase_type`: 必须为枚举值之一
- `total_price`: 必须大于0
- `quality`: 必须为AA/A/AB/B/C之一
- `photos`: JSON数组格式，最多5个URL
- `weight`: 散珠/手串类型时必填，必须大于0
- `piece_count`: 配件/成品类型时必填，必须大于0
- `bead_diameter`: 散珠/手串类型时必填，常用值：4/6/8/10/12mm

### 2.4 成品表（products）

```sql
CREATE TABLE products (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  description TEXT,
  category VARCHAR(100),
  quantity INT DEFAULT 0,
  unit VARCHAR(20) NOT NULL,
  unit_price DECIMAL(10,2) NOT NULL,
  total_value DECIMAL(10,2) NOT NULL,
  status ENUM('MAKING', 'AVAILABLE', 'SOLD', 'OFFLINE') DEFAULT 'AVAILABLE',
  location VARCHAR(100),
  notes TEXT,
  images TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  user_id VARCHAR(36) NOT NULL,
  product_code VARCHAR(50),
  sku_id VARCHAR(36),
  
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  INDEX idx_products_status (status),
  INDEX idx_products_sku_id (sku_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.5 系统配置表（system_configs）

```sql
CREATE TABLE system_configs (
  id VARCHAR(36) PRIMARY KEY,
  key VARCHAR(100) UNIQUE NOT NULL,
  value TEXT NOT NULL,
  description VARCHAR(500),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.6 编辑日志表（edit_logs）

```sql
CREATE TABLE edit_logs (
  id VARCHAR(36) PRIMARY KEY,
  purchase_id VARCHAR(36) NOT NULL,
  user_id VARCHAR(36) NOT NULL,
  action VARCHAR(100) NOT NULL,
  details TEXT,
  changed_fields JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (purchase_id) REFERENCES purchases(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  INDEX idx_edit_logs_purchase_id (purchase_id),
  INDEX idx_edit_logs_user_id (user_id),
  INDEX idx_edit_logs_created_at (created_at DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.7 原材料表（materials）

```sql
CREATE TABLE materials (
  id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
  material_code VARCHAR(50) UNIQUE NOT NULL COMMENT '原材料编号（来自purchase_code）',
  material_name VARCHAR(255) NOT NULL COMMENT '原材料名称（来自purchase_name）',
  material_type ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED_MATERIAL') NOT NULL COMMENT '原材料类型',
  quality ENUM('AA', 'A', 'AB', 'B', 'C', 'UNKNOWN') DEFAULT 'UNKNOWN' COMMENT '品质等级',
  
  -- 规格信息（根据类型动态使用）
  bead_diameter DECIMAL(5,2) COMMENT '珠子直径(mm)',
  bracelet_inner_diameter DECIMAL(5,2) COMMENT '手串内径(mm)',
  bracelet_bead_count INT COMMENT '手串珠子数量',
  accessory_specification VARCHAR(100) COMMENT '配件规格',
  finished_material_specification VARCHAR(100) COMMENT '成品规格',
  
  -- 转换后的库存数据（核心字段）
  original_quantity INT NOT NULL COMMENT '原始数量（转换单位后）',
  used_quantity INT DEFAULT 0 COMMENT '已使用数量',
  remaining_quantity INT GENERATED ALWAYS AS (original_quantity - used_quantity) STORED COMMENT '剩余数量（计算字段）',
  inventory_unit ENUM('PIECES', 'STRINGS', 'SLICES', 'ITEMS') NOT NULL COMMENT '库存计量单位',
  
  -- 价格信息
  unit_cost DECIMAL(10,4) NOT NULL COMMENT '单位成本（转换后）',
  total_cost DECIMAL(12,2) NOT NULL COMMENT '总成本',
  
  -- 库存管理字段
  min_stock_alert INT COMMENT '最低库存预警',
  stock_status ENUM('SUFFICIENT', 'LOW', 'OUT') GENERATED ALWAYS AS (
    CASE 
      WHEN remaining_quantity <= 0 THEN 'OUT'
      WHEN min_stock_alert IS NOT NULL AND remaining_quantity <= min_stock_alert THEN 'LOW'
      ELSE 'SUFFICIENT'
    END
  ) STORED COMMENT '库存状态（计算字段）',
  
  -- 关联信息
  purchase_id VARCHAR(36) NOT NULL COMMENT '关联的采购记录ID',
  supplier_id VARCHAR(36) COMMENT '供应商ID',
  
  -- 附加信息
  photos JSON COMMENT '照片URLs',
  material_date DATE NOT NULL COMMENT '入库日期（来自purchase_date）',
  notes TEXT COMMENT '备注',
  
  -- 审计字段
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(36) NOT NULL COMMENT '创建人',
  
  FOREIGN KEY (purchase_id) REFERENCES purchases(id) ON DELETE RESTRICT,
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id) ON DELETE SET NULL,
  FOREIGN KEY (created_by) REFERENCES users(id),
  
  -- 索引设计
  INDEX idx_materials_code (material_code),
  INDEX idx_materials_name (material_name),
  INDEX idx_materials_type_quality (material_type, quality),
  INDEX idx_materials_purchase_id (purchase_id),
  INDEX idx_materials_supplier_id (supplier_id),
  INDEX idx_materials_stock_status (stock_status),
  INDEX idx_materials_remaining_quantity (remaining_quantity),
  INDEX idx_materials_date (material_date DESC),
  INDEX idx_materials_search (material_name, material_code),
  INDEX idx_materials_inventory_filter (material_type, quality, stock_status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.8 原材料使用记录表（material_usage）

```sql
CREATE TABLE material_usage (
  id VARCHAR(36) PRIMARY KEY,
  purchase_id VARCHAR(36),
  product_id VARCHAR(36),
  material_id VARCHAR(36) NOT NULL COMMENT '关联的原材料ID',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  total_cost DECIMAL(10,2),
  unit_cost DECIMAL(10,4),
  action ENUM('CREATE', 'USE', 'RETURN', 'ADJUST') DEFAULT 'CREATE',
  notes TEXT,
  quantity_used INT NOT NULL,
  sku_id VARCHAR(36),
  
  FOREIGN KEY (purchase_id) REFERENCES purchases(id) ON DELETE RESTRICT,
  FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT,
  FOREIGN KEY (material_id) REFERENCES materials(id) ON DELETE RESTRICT,
  INDEX idx_material_usage_purchase_id (purchase_id),
  INDEX idx_material_usage_product_id (product_id),
  INDEX idx_material_usage_material_id (material_id),
  INDEX idx_material_usage_action (action)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.9 SKU主表（product_skus）

```sql
CREATE TABLE product_skus (
  id VARCHAR(36) PRIMARY KEY,
  sku_code VARCHAR(50) UNIQUE NOT NULL,
  sku_name VARCHAR(200) NOT NULL,
  material_signature_hash VARCHAR(32) NOT NULL,
  material_signature JSON NOT NULL,
  total_quantity INT DEFAULT 0,
  available_quantity INT DEFAULT 0,
  unit_price DECIMAL(10,2) NOT NULL,
  total_value DECIMAL(10,2) NOT NULL,
  photos JSON,
  description TEXT,
  specification VARCHAR(100),
  material_cost DECIMAL(10,2),
  labor_cost DECIMAL(10,2),
  craft_cost DECIMAL(10,2),
  total_cost DECIMAL(10,2),
  selling_price DECIMAL(10,2) NOT NULL,
  profit_margin DECIMAL(5,2),
  status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(36) NOT NULL,
  
  FOREIGN KEY (created_by) REFERENCES users(id),
  INDEX idx_product_skus_sku_code (sku_code),
  INDEX idx_product_skus_material_hash (material_signature_hash),
  INDEX idx_product_skus_status (status),
  INDEX idx_product_skus_created_by (created_by)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**SKU字段说明：**
- `sku_code`: SKU编号
- `sku_name`: SKU名称
- `material_signature_hash`: 原材料标识哈希值
- `material_signature`: 原材料标识JSON
- `total_quantity`: 总数量
- `available_quantity`: 可售数量
- `material_cost`: 原材料成本
- `labor_cost`: 人工成本
- `craft_cost`: 工艺成本
- `selling_price`: 销售价格
- `profit_margin`: 利润率

### 2.10 SKU库存变更日志表（sku_inventory_logs）

```sql
CREATE TABLE sku_inventory_logs (
  id VARCHAR(36) PRIMARY KEY,
  sku_id VARCHAR(36) NOT NULL,
  action ENUM('CREATE', 'SELL', 'ADJUST', 'DESTROY') NOT NULL,
  quantity_change INT NOT NULL,
  quantity_before INT NOT NULL,
  quantity_after INT NOT NULL,
  reference_type ENUM('PRODUCT', 'SALE', 'MANUAL', 'DESTROY', 'REFUND') NOT NULL,
  reference_id VARCHAR(36),
  notes TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  user_id VARCHAR(36) NOT NULL,
  
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  INDEX idx_sku_inventory_logs_sku_id (sku_id),
  INDEX idx_sku_inventory_logs_action (action),
  INDEX idx_sku_inventory_logs_created_at (created_at DESC),
  INDEX idx_sku_inventory_logs_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.11 审计日志表（audit_logs）

```sql
CREATE TABLE audit_logs (
  id VARCHAR(36) PRIMARY KEY,
  user_id VARCHAR(36),
  action VARCHAR(100) NOT NULL,
  resource VARCHAR(100) NOT NULL,
  resource_id VARCHAR(36),
  details TEXT,
  ip_address VARCHAR(45),
  user_agent VARCHAR(500),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  INDEX idx_audit_logs_user_id (user_id),
  INDEX idx_audit_logs_action (action),
  INDEX idx_audit_logs_resource (resource),
  INDEX idx_audit_logs_created_at (created_at DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.12 客户表（customers）

```sql
CREATE TABLE customers (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  phone VARCHAR(20) UNIQUE NOT NULL,
  address TEXT,
  notes TEXT,
  total_purchases DECIMAL(10,2) DEFAULT 0.00,
  total_orders INT DEFAULT 0,
  first_purchase_date TIMESTAMP NULL,
  last_purchase_date TIMESTAMP NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  birthday TIMESTAMP NULL,
  wechat VARCHAR(100),
  average_order_value DECIMAL(10,2) DEFAULT 0.00,
  city VARCHAR(50),
  customer_labels JSON,
  days_since_first_purchase INT,
  days_since_last_purchase INT,
  primary_label VARCHAR(50),
  province VARCHAR(50),
  refund_count INT DEFAULT 0,
  refund_rate DECIMAL(5,2) DEFAULT 0.00,
  total_all_orders INT DEFAULT 0,
  
  INDEX idx_customers_name (name),
  INDEX idx_customers_phone (phone),
  INDEX idx_customers_city (city),
  INDEX idx_customers_province (province)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.13 客户备注表（customer_notes）

```sql
CREATE TABLE customer_notes (
  id VARCHAR(36) PRIMARY KEY,
  customer_id VARCHAR(36) NOT NULL,
  category ENUM('PREFERENCE', 'BEHAVIOR', 'CONTACT', 'OTHER') NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(36) NOT NULL,
  
  FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE,
  FOREIGN KEY (created_by) REFERENCES users(id),
  INDEX idx_customer_notes_customer_id (customer_id),
  INDEX idx_customer_notes_category (category),
  INDEX idx_customer_notes_created_by (created_by)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.14 客户购买记录表（customer_purchases）

```sql
CREATE TABLE customer_purchases (
  id VARCHAR(36) PRIMARY KEY,
  customer_id VARCHAR(36) NOT NULL,
  sku_id VARCHAR(36) NOT NULL,
  sku_name VARCHAR(200) NOT NULL,
  quantity INT NOT NULL,
  unit_price DECIMAL(10,2) NOT NULL,
  original_price DECIMAL(10,2),
  total_price DECIMAL(10,2) NOT NULL,
  status ENUM('ACTIVE', 'REFUNDED') DEFAULT 'ACTIVE',
  refund_date TIMESTAMP NULL,
  refund_reason VARCHAR(200),
  refund_notes TEXT,
  sale_channel VARCHAR(50),
  notes TEXT,
  purchase_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  FOREIGN KEY (customer_id) REFERENCES customers(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  INDEX idx_customer_purchases_customer_id (customer_id),
  INDEX idx_customer_purchases_sku_id (sku_id),
  INDEX idx_customer_purchases_purchase_date (purchase_date DESC),
  INDEX idx_customer_purchases_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2.15 财务记录表（financial_records）

```sql
CREATE TABLE financial_records (
  id VARCHAR(36) PRIMARY KEY,
  record_type ENUM('INCOME', 'EXPENSE', 'REFUND', 'LOSS') NOT NULL,
  amount DECIMAL(10,2) NOT NULL,
  description VARCHAR(200) NOT NULL,
  reference_type ENUM('PURCHASE', 'SALE', 'REFUND', 'MANUAL') NOT NULL,
  reference_id VARCHAR(36),
  category VARCHAR(100),
  transaction_date TIMESTAMP NOT NULL,
  notes TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  user_id VARCHAR(36) NOT NULL,
  
  FOREIGN KEY (user_id) REFERENCES users(id),
  INDEX idx_financial_records_record_type (record_type),
  INDEX idx_financial_records_reference_type (reference_type),
  INDEX idx_financial_records_reference_id (reference_id),
  INDEX idx_financial_records_transaction_date (transaction_date DESC),
  INDEX idx_financial_records_user_id (user_id),
  INDEX idx_financial_records_created_at (created_at DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

## 四、枚举类型定义

### 4.1 核心枚举类型

**用户角色（UserRole）：**
```sql
ENUM('BOSS', 'EMPLOYEE')
```

**品质等级（Quality）：**
```sql
ENUM('AA', 'A', 'AB', 'B', 'C', 'UNKNOWN')
```

**原材料类型（MaterialType）：**
```sql
ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED_MATERIAL')
```
- `LOOSE_BEADS`: 散珠
- `BRACELET`: 手串
- `ACCESSORIES`: 配件
- `FINISHED_MATERIAL`: 成品原材料

**库存计量单位（InventoryUnit）：**
```sql
ENUM('PIECES', 'STRINGS', 'SLICES', 'ITEMS')
```
- `PIECES`: 颗（散珠、手串）
- `STRINGS`: 串（手串成品）
- `SLICES`: 片（配件）
- `ITEMS`: 件（成品原材料）

**库存状态（StockStatus）：**
```sql
ENUM('SUFFICIENT', 'LOW', 'OUT')
```
- `SUFFICIENT`: 库存充足
- `LOW`: 低库存
- `OUT`: 缺货

**原材料使用操作类型（MaterialUsageAction）：**
```sql
ENUM('CREATE', 'USE', 'RETURN', 'ADJUST')
```
- `CREATE`: 创建（初始化）
- `USE`: 使用（制作成品）
- `RETURN`: 退回（成品销毁）
- `ADJUST`: 调整（库存修正）

### 4.2 业务状态枚举

**采购状态（PurchaseStatus）：**
```sql
ENUM('ACTIVE', 'USED')
```
- `ACTIVE`: 正常状态，可以编辑和删除
- `USED`: 已被使用，不允许删除，但不影响库存计算

### 3.5 产品状态（ProductStatus）
```sql
ENUM('MAKING', 'AVAILABLE', 'SOLD', 'OFFLINE')
```

### 3.6 SKU状态（SkuStatus）
```sql
ENUM('ACTIVE', 'INACTIVE')
```

### 3.7 财务记录类型（financial_records_recordType）
```sql
ENUM('INCOME', 'EXPENSE', 'REFUND', 'LOSS')
```

### 3.8 客户备注分类（customer_notes_category）
```sql
ENUM('PREFERENCE', 'BEHAVIOR', 'CONTACT', 'OTHER')
```

### 3.9 SKU库存操作类型（sku_inventory_logs_action）
```sql
ENUM('CREATE', 'SELL', 'ADJUST', 'DESTROY')
```

### 3.10 财务记录引用类型（financial_records_referenceType）
```sql
ENUM('PURCHASE', 'SALE', 'REFUND', 'MANUAL')
```

### 3.11 SKU库存引用类型（sku_inventory_logs_referenceType）
```sql
ENUM('PRODUCT', 'SALE', 'MANUAL', 'DESTROY', 'REFUND')
```

### 3.12 原材料使用操作类型（material_usage_action）
```sql
ENUM('CREATE', 'USE', 'RETURN', 'ADJUST')
```

### 3.13 客户购买状态（customer_purchases_status）
```sql
ENUM('ACTIVE', 'REFUNDED')
```

### 3.14 采购状态（purchases_status）
```sql
ENUM('ACTIVE', 'USED')
```

## 三、数据同步机制（核心架构）

### 3.1 purchase到material同步触发器

```sql
-- 采购记录创建时自动创建material记录
DELIMITER //
CREATE TRIGGER tr_purchase_insert_material
AFTER INSERT ON purchases
FOR EACH ROW
BEGIN
  IF NEW.status = 'ACTIVE' THEN
    INSERT INTO materials (
      material_code, material_name, material_type, quality,
      bead_diameter, bracelet_inner_diameter, bracelet_bead_count,
      accessory_specification, finished_material_specification,
      original_quantity, inventory_unit, unit_cost, total_cost,
      min_stock_alert, purchase_id, supplier_id, photos, material_date, notes, created_by
    ) VALUES (
      NEW.purchase_code, NEW.purchase_name, NEW.purchase_type, NEW.quality,
      NEW.bead_diameter, NEW.bracelet_inner_diameter, NEW.bracelet_bead_count,
      NEW.accessory_specification, NEW.finished_material_specification,
      -- 数量转换逻辑
      CASE 
        WHEN NEW.purchase_type = 'LOOSE_BEADS' THEN COALESCE(NEW.total_beads, NEW.piece_count, 1)
        WHEN NEW.purchase_type = 'BRACELET' THEN COALESCE(NEW.total_beads, NEW.piece_count, 1)
        WHEN NEW.purchase_type = 'ACCESSORIES' THEN COALESCE(NEW.piece_count, 1)
        WHEN NEW.purchase_type = 'FINISHED_MATERIAL' THEN COALESCE(NEW.piece_count, 1)
        ELSE 1
      END,
      -- 库存单位
      CASE 
        WHEN NEW.purchase_type IN ('LOOSE_BEADS', 'BRACELET') THEN 'PIECES'
        WHEN NEW.purchase_type = 'ACCESSORIES' THEN 'SLICES'
        WHEN NEW.purchase_type = 'FINISHED_MATERIAL' THEN 'ITEMS'
        ELSE 'PIECES'
      END,
      -- 单位成本计算
      CASE 
        WHEN NEW.purchase_type = 'LOOSE_BEADS' THEN COALESCE(NEW.price_per_bead, NEW.total_price / COALESCE(NEW.total_beads, NEW.piece_count, 1))
        WHEN NEW.purchase_type = 'BRACELET' THEN COALESCE(NEW.price_per_bead, NEW.total_price / COALESCE(NEW.total_beads, NEW.piece_count, 1))
        WHEN NEW.purchase_type = 'ACCESSORIES' THEN COALESCE(NEW.price_per_piece, NEW.total_price / COALESCE(NEW.piece_count, 1))
        WHEN NEW.purchase_type = 'FINISHED_MATERIAL' THEN COALESCE(NEW.price_per_piece, NEW.total_price / COALESCE(NEW.piece_count, 1))
        ELSE NEW.total_price
      END,
      NEW.total_price, NEW.min_stock_alert, NEW.id, NEW.supplier_id,
      NEW.photos, DATE(NEW.purchase_date), NEW.notes, NEW.user_id
    );
  END IF;
END//
DELIMITER ;

-- 采购记录更新时同步更新material记录
DELIMITER //
CREATE TRIGGER tr_purchase_update_material
AFTER UPDATE ON purchases
FOR EACH ROW
BEGIN
  IF NEW.status = 'ACTIVE' AND OLD.status = 'ACTIVE' THEN
    UPDATE materials SET
      material_name = NEW.purchase_name,
      quality = NEW.quality,
      bead_diameter = NEW.bead_diameter,
      bracelet_inner_diameter = NEW.bracelet_inner_diameter,
      bracelet_bead_count = NEW.bracelet_bead_count,
      accessory_specification = NEW.accessory_specification,
      finished_material_specification = NEW.finished_material_specification,
      min_stock_alert = NEW.min_stock_alert,
      photos = NEW.photos,
      notes = NEW.notes,
      updated_at = CURRENT_TIMESTAMP
    WHERE purchase_id = NEW.id;
  ELSEIF NEW.status = 'USED' AND OLD.status = 'ACTIVE' THEN
    -- purchase状态变为USED时，不删除material记录，保持库存数据完整性
    UPDATE materials SET
      notes = CONCAT(COALESCE(notes, ''), '\n[采购记录已标记为USED]'),
      updated_at = CURRENT_TIMESTAMP
    WHERE purchase_id = NEW.id;
  END IF;
END//
DELIMITER ;
```

### 3.2 material_usage更新触发器

```sql
-- material使用量更新触发器
DELIMITER //
CREATE TRIGGER tr_material_usage_update_stock
AFTER INSERT ON material_usage
FOR EACH ROW
BEGIN
  UPDATE materials SET
    used_quantity = (
      SELECT COALESCE(SUM(quantity_used), 0)
      FROM material_usage
      WHERE material_id = NEW.material_id
    ),
    updated_at = CURRENT_TIMESTAMP
  WHERE id = NEW.material_id;
END//
DELIMITER ;

DELIMITER //
CREATE TRIGGER tr_material_usage_update_stock_after_update
AFTER UPDATE ON material_usage
FOR EACH ROW
BEGIN
  UPDATE materials SET
    used_quantity = (
      SELECT COALESCE(SUM(quantity_used), 0)
      FROM material_usage
      WHERE material_id = NEW.material_id
    ),
    updated_at = CURRENT_TIMESTAMP
  WHERE id = NEW.material_id;
END//
DELIMITER ;

DELIMITER //
CREATE TRIGGER tr_material_usage_update_stock_after_delete
AFTER DELETE ON material_usage
FOR EACH ROW
BEGIN
  UPDATE materials SET
    used_quantity = (
      SELECT COALESCE(SUM(quantity_used), 0)
      FROM material_usage
      WHERE material_id = OLD.material_id
    ),
    updated_at = CURRENT_TIMESTAMP
  WHERE id = OLD.material_id;
END//
DELIMITER ;
```

### 4.2 material表结构设计

```sql
CREATE TABLE materials (
  id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
  material_code VARCHAR(50) UNIQUE NOT NULL COMMENT '原材料编号（来自purchase_code）',
  material_name VARCHAR(255) NOT NULL COMMENT '原材料名称（来自purchase_name）',
  material_type ENUM('LOOSE_BEADS', 'BRACELET', 'ACCESSORIES', 'FINISHED_MATERIAL') NOT NULL COMMENT '原材料类型',
  quality ENUM('AA', 'A', 'AB', 'B', 'C', 'UNKNOWN') DEFAULT 'UNKNOWN' COMMENT '品质等级',
  
  -- 规格信息（根据类型动态使用）
  bead_diameter DECIMAL(5,2) COMMENT '珠子直径(mm)',
  bracelet_inner_diameter DECIMAL(5,2) COMMENT '手串内径(mm)',
  bracelet_bead_count INT COMMENT '手串珠子数量',
  accessory_specification VARCHAR(100) COMMENT '配件规格',
  finished_material_specification VARCHAR(100) COMMENT '成品规格',
  
  -- 转换后的库存数据（核心字段）
  original_quantity INT NOT NULL COMMENT '原始数量（转换单位后）',
  used_quantity INT DEFAULT 0 COMMENT '已使用数量',
  remaining_quantity INT GENERATED ALWAYS AS (original_quantity - used_quantity) STORED COMMENT '剩余数量（计算字段）',
  inventory_unit ENUM('PIECES', 'STRINGS', 'SLICES', 'ITEMS') NOT NULL COMMENT '库存计量单位',
  
  -- 价格信息
  unit_cost DECIMAL(10,4) NOT NULL COMMENT '单位成本（转换后）',
  total_cost DECIMAL(12,2) NOT NULL COMMENT '总成本',
  
  -- 库存管理字段
  min_stock_alert INT COMMENT '最低库存预警',
  stock_status ENUM('SUFFICIENT', 'LOW', 'OUT') GENERATED ALWAYS AS (
    CASE 
      WHEN remaining_quantity <= 0 THEN 'OUT'
      WHEN min_stock_alert IS NOT NULL AND remaining_quantity <= min_stock_alert THEN 'LOW'
      ELSE 'SUFFICIENT'
    END
  ) STORED COMMENT '库存状态（计算字段）',
  
  -- 关联信息
  purchase_id VARCHAR(36) NOT NULL COMMENT '关联的采购记录ID',
  supplier_id VARCHAR(36) COMMENT '供应商ID',
  
  -- 附加信息
  photos JSON COMMENT '照片URLs',
  material_date DATE NOT NULL COMMENT '入库日期（来自purchase_date）',
  notes TEXT COMMENT '备注',
  
  -- 审计字段
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by VARCHAR(36) NOT NULL COMMENT '创建人',
  
  FOREIGN KEY (purchase_id) REFERENCES purchases(id) ON DELETE RESTRICT,
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id) ON DELETE SET NULL,
  FOREIGN KEY (created_by) REFERENCES users(id),
  
  -- 索引设计
  INDEX idx_materials_code (material_code),
  INDEX idx_materials_name (material_name),
  INDEX idx_materials_type_quality (material_type, quality),
  INDEX idx_materials_purchase_id (purchase_id),
  INDEX idx_materials_supplier_id (supplier_id),
  INDEX idx_materials_stock_status (stock_status),
  INDEX idx_materials_remaining_quantity (remaining_quantity),
  INDEX idx_materials_date (material_date DESC),
  INDEX idx_materials_search (material_name, material_code),
  INDEX idx_materials_inventory_filter (material_type, quality, stock_status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 4.3 purchase到material数据转换规则

**转换逻辑SQL示例：**
```sql
-- 从purchase表创建material记录的转换逻辑
INSERT INTO materials (
  material_code, material_name, material_type, quality,
  bead_diameter, bracelet_inner_diameter, bracelet_bead_count,
  accessory_specification, finished_material_specification,
  original_quantity, inventory_unit, unit_cost, total_cost,
  min_stock_alert, purchase_id, supplier_id, photos, material_date, notes, created_by
)
SELECT 
  p.purchase_code as material_code,
  p.purchase_name as material_name,
  p.purchase_type as material_type,
  p.quality,
  p.bead_diameter,
  p.specification as bracelet_inner_diameter,  -- 手串内径
  p.beads_per_string as bracelet_bead_count,
  p.specification as accessory_specification,  -- 配件规格
  p.specification as finished_material_specification,  -- 成品规格
  
  -- 转换后的数量计算
  CASE 
    WHEN p.purchase_type = 'LOOSE_BEADS' THEN 
      CASE 
        WHEN p.bead_diameter = 4.0 THEN FLOOR(p.weight * 25)
        WHEN p.bead_diameter = 6.0 THEN FLOOR(p.weight * 11)
        WHEN p.bead_diameter = 8.0 THEN FLOOR(p.weight * 6)
        WHEN p.bead_diameter = 10.0 THEN FLOOR(p.weight * 4)
        WHEN p.bead_diameter = 12.0 THEN FLOOR(p.weight * 3)
        ELSE FLOOR(p.weight * 5)
      END
    WHEN p.purchase_type = 'BRACELET' THEN 
      COALESCE(p.total_beads, FLOOR(p.weight * 
        CASE 
          WHEN p.bead_diameter = 4.0 THEN 25
          WHEN p.bead_diameter = 6.0 THEN 11
          WHEN p.bead_diameter = 8.0 THEN 6
          WHEN p.bead_diameter = 10.0 THEN 4
          WHEN p.bead_diameter = 12.0 THEN 3
          ELSE 5
        END
      ))
    WHEN p.purchase_type = 'ACCESSORIES' THEN COALESCE(p.piece_count, 1)
    WHEN p.purchase_type = 'FINISHED_MATERIAL' THEN COALESCE(p.piece_count, 1)
    ELSE 1
  END as original_quantity,
  
  -- 库存单位
  CASE 
    WHEN p.purchase_type IN ('LOOSE_BEADS', 'BRACELET') THEN 'PIECES'
    WHEN p.purchase_type = 'ACCESSORIES' THEN 'SLICES'
    WHEN p.purchase_type = 'FINISHED_MATERIAL' THEN 'ITEMS'
    ELSE 'PIECES'
  END as inventory_unit,
  
  -- 单位成本计算
  CASE 
    WHEN p.purchase_type = 'LOOSE_BEADS' THEN 
      p.total_price / CASE 
        WHEN p.bead_diameter = 4.0 THEN FLOOR(p.weight * 25)
        WHEN p.bead_diameter = 6.0 THEN FLOOR(p.weight * 11)
        WHEN p.bead_diameter = 8.0 THEN FLOOR(p.weight * 6)
        WHEN p.bead_diameter = 10.0 THEN FLOOR(p.weight * 4)
        WHEN p.bead_diameter = 12.0 THEN FLOOR(p.weight * 3)
        ELSE FLOOR(p.weight * 5)
      END
    WHEN p.purchase_type = 'BRACELET' THEN 
      p.total_price / COALESCE(p.total_beads, FLOOR(p.weight * 
        CASE 
          WHEN p.bead_diameter = 4.0 THEN 25
          WHEN p.bead_diameter = 6.0 THEN 11
          WHEN p.bead_diameter = 8.0 THEN 6
          WHEN p.bead_diameter = 10.0 THEN 4
          WHEN p.bead_diameter = 12.0 THEN 3
          ELSE 5
        END
      ))
    ELSE p.total_price / COALESCE(p.piece_count, 1)
  END as unit_cost,
  
  p.total_price as total_cost,
  p.min_stock_alert,
  p.id as purchase_id,
  p.supplier_id,
  p.photos,
  DATE(p.purchase_date) as material_date,
  p.notes,
  p.user_id as created_by
FROM purchases p
WHERE p.status = 'ACTIVE';  -- 只转换ACTIVE状态的采购记录
```

### 4.4 material表库存管理规则

**库存数量管理：**
- **original_quantity**：转换单位后的原始数量（不可修改）
- **used_quantity**：已使用数量（通过material_usage表更新）
- **remaining_quantity**：剩余数量（计算字段：original_quantity - used_quantity）

**库存状态自动判断：**
```sql
stock_status = CASE 
  WHEN remaining_quantity <= 0 THEN 'OUT'
  WHEN min_stock_alert IS NOT NULL AND remaining_quantity <= min_stock_alert THEN 'LOW'
  ELSE 'SUFFICIENT'
END
```

**库存单位标准化：**
- **散珠/手串**：PIECES（颗）
- **配件**：SLICES（片）
- **成品原材料**：ITEMS（件）

### 4.5 数据同步机制

**purchase到material同步触发器：**
```sql
-- 采购记录创建时自动创建material记录
DELIMITER //
CREATE TRIGGER tr_purchase_insert_material
AFTER INSERT ON purchases
FOR EACH ROW
BEGIN
  IF NEW.status = 'ACTIVE' THEN
    INSERT INTO materials (
      material_code, material_name, material_type, quality,
      bead_diameter, accessory_specification, finished_material_specification,
      original_quantity, inventory_unit, unit_cost, total_cost,
      min_stock_alert, purchase_id, supplier_id, photos, material_date, notes, created_by
    ) VALUES (
      NEW.purchase_code, NEW.purchase_name, NEW.purchase_type, NEW.quality,
      NEW.bead_diameter, NEW.specification, NEW.specification,
      -- 数量转换逻辑（简化版）
      CASE 
        WHEN NEW.purchase_type = 'LOOSE_BEADS' THEN COALESCE(NEW.total_beads, NEW.piece_count, 1)
        WHEN NEW.purchase_type = 'BRACELET' THEN COALESCE(NEW.total_beads, NEW.piece_count, 1)
        ELSE COALESCE(NEW.piece_count, 1)
      END,
      CASE 
        WHEN NEW.purchase_type IN ('LOOSE_BEADS', 'BRACELET') THEN 'PIECES'
        WHEN NEW.purchase_type = 'ACCESSORIES' THEN 'SLICES'
        ELSE 'ITEMS'
      END,
      NEW.total_price / CASE 
        WHEN NEW.purchase_type = 'LOOSE_BEADS' THEN COALESCE(NEW.total_beads, NEW.piece_count, 1)
        WHEN NEW.purchase_type = 'BRACELET' THEN COALESCE(NEW.total_beads, NEW.piece_count, 1)
        ELSE COALESCE(NEW.piece_count, 1)
      END,
      NEW.total_price, NEW.min_stock_alert, NEW.id, NEW.supplier_id,
      NEW.photos, DATE(NEW.purchase_date), NEW.notes, NEW.user_id
    );
  END IF;
END//
DELIMITER ;

-- 采购记录更新时同步更新material记录
DELIMITER //
CREATE TRIGGER tr_purchase_update_material
AFTER UPDATE ON purchases
FOR EACH ROW
BEGIN
  IF NEW.status = 'ACTIVE' AND OLD.status = 'ACTIVE' THEN
    UPDATE materials SET
      material_name = NEW.purchase_name,
      quality = NEW.quality,
      bead_diameter = NEW.bead_diameter,
      min_stock_alert = NEW.min_stock_alert,
      photos = NEW.photos,
      notes = NEW.notes,
      updated_at = CURRENT_TIMESTAMP
    WHERE purchase_id = NEW.id;
  ELSEIF NEW.status = 'USED' AND OLD.status = 'ACTIVE' THEN
    -- purchase状态变为USED时，不删除material记录，保持库存数据完整性
    UPDATE materials SET
      notes = CONCAT(COALESCE(notes, ''), '\n[采购记录已标记为USED]'),
      updated_at = CURRENT_TIMESTAMP
    WHERE purchase_id = NEW.id;
  END IF;
END//
DELIMITER ;
```

### 4.6 material_usage表关联更新

**material_usage表结构调整：**
```sql
-- 更新material_usage表，关联material表而非purchase表
ALTER TABLE material_usage 
ADD COLUMN material_id VARCHAR(36) AFTER purchase_id,
ADD FOREIGN KEY (material_id) REFERENCES materials(id) ON DELETE RESTRICT;

-- 创建material使用量更新触发器
DELIMITER //
CREATE TRIGGER tr_material_usage_update_stock
AFTER INSERT ON material_usage
FOR EACH ROW
BEGIN
  UPDATE materials SET
    used_quantity = (
      SELECT COALESCE(SUM(quantity_used), 0)
      FROM material_usage
      WHERE material_id = NEW.material_id
    ),
    updated_at = CURRENT_TIMESTAMP
  WHERE id = NEW.material_id;
END//
DELIMITER ;

DELIMITER //
CREATE TRIGGER tr_material_usage_update_stock_after_update
AFTER UPDATE ON material_usage
FOR EACH ROW
BEGIN
  UPDATE materials SET
    used_quantity = (
      SELECT COALESCE(SUM(quantity_used), 0)
      FROM material_usage
      WHERE material_id = NEW.material_id
    ),
    updated_at = CURRENT_TIMESTAMP
  WHERE id = NEW.material_id;
END//
DELIMITER ;

DELIMITER //
CREATE TRIGGER tr_material_usage_update_stock_after_delete
AFTER DELETE ON material_usage
FOR EACH ROW
BEGIN
  UPDATE materials SET
    used_quantity = (
      SELECT COALESCE(SUM(quantity_used), 0)
      FROM material_usage
      WHERE material_id = OLD.material_id
    ),
    updated_at = CURRENT_TIMESTAMP
  WHERE id = OLD.material_id;
END//
DELIMITER ;
```

### 4.7 库存查询API重构

**新的库存查询逻辑：**
```sql
-- 库存列表查询（基于materials表）
SELECT 
  m.id as material_id,
  m.material_code,
  m.material_name,
  m.material_type,
  m.quality,
  m.bead_diameter,
  m.accessory_specification,
  m.finished_material_specification,
  m.original_quantity,
  m.used_quantity,
  m.remaining_quantity,
  m.inventory_unit,
  m.unit_cost,
  m.total_cost,
  m.stock_status,
  m.material_date,
  s.name as supplier_name,
  p.purchase_code as source_purchase_code,
  p.status as purchase_status
FROM materials m
LEFT JOIN suppliers s ON m.supplier_id = s.id
LEFT JOIN purchases p ON m.purchase_id = p.id
WHERE m.remaining_quantity > 0  -- 只显示有库存的原材料
ORDER BY m.material_date DESC, m.created_at DESC;
```

### 4.8 purchase表status字段说明

**status字段业务规则：**
- **ACTIVE**：采购记录正常状态，可以编辑和删除
- **USED**：采购记录已被使用，不允许删除，但不影响库存计算

**重要说明：**
1. purchase表的status字段只影响该条记录的删除权限
2. 库存计算完全基于materials表，与purchase.status无关
3. 即使purchase.status为USED，对应的material记录仍然有效
4. 这样设计确保了库存数据的完整性和一致性

## 五、数据库设计原则

### 5.1 命名规范原则
1. **全蛇形命名**：所有表名、字段名、索引名都使用snake_case
2. **语义明确**：字段名能清楚表达其含义
3. **统一性**：相同含义的字段在不同表中使用相同命名
4. **可扩展性**：预留扩展空间，避免频繁修改表结构

### 4.2 数据类型规范
1. **主键**：统一使用VARCHAR(36)存储cuid
2. **价格字段**：使用DECIMAL(10,2)或DECIMAL(10,4)确保精度
3. **时间字段**：使用TIMESTAMP类型
4. **JSON字段**：用于存储复杂数据结构（如photos、material_signature）
5. **枚举字段**：使用ENUM类型限制取值范围

### 5.3 库存查询优化索引（重要更新）

**原材料库存查询专用索引：**
```sql
-- 库存搜索优化索引
CREATE INDEX idx_inventory_search ON purchases(purchase_name, purchase_code);

-- 库存筛选优化索引
CREATE INDEX idx_inventory_filter ON purchases(purchase_type, quality, purchase_date);

-- 供应商筛选索引
CREATE INDEX idx_inventory_supplier ON purchases(supplier_id);

-- 价格范围筛选索引
CREATE INDEX idx_inventory_price_range ON purchases(price_per_gram, total_price);

-- 规格范围筛选索引
CREATE INDEX idx_inventory_spec_range ON purchases(bead_diameter, specification);

-- 库存排序优化索引
CREATE INDEX idx_inventory_sort ON purchases(purchase_date DESC, created_at DESC);

-- 库存状态查询索引
CREATE INDEX idx_inventory_status ON purchases(purchase_type, min_stock_alert);
```

**material_usage表优化索引：**
```sql
-- 使用量汇总查询优化
CREATE INDEX idx_material_usage_summary ON material_usage(purchase_id, quantity_used);

-- 成品关联查询优化
CREATE INDEX idx_material_usage_product ON material_usage(product_id, purchase_id);
```

### 5.4 索引设计原则
1. **主键索引**：每个表都有主键索引
2. **外键索引**：所有外键字段都建立索引
3. **查询索引**：根据常用查询条件建立复合索引
4. **唯一索引**：确保业务唯一性（如user_name、phone、purchase_code）
5. **全文索引**：支持文本搜索的字段建立FULLTEXT索引
6. **库存专用索引**：针对库存查询场景的专门优化

### 4.4 关系设计原则
1. **外键约束**：确保数据完整性
2. **级联操作**：合理设置ON DELETE和ON UPDATE规则
3. **软删除**：重要数据使用状态字段而非物理删除
4. **审计追踪**：重要操作记录到audit_logs表

## 五、数据完整性规则

### 5.1 必填字段验证
- 用户表：user_name、password、name、role
- 采购表：purchase_code、product_name、product_type、user_id
- 客户表：name、phone
- SKU表：sku_code、sku_name、material_signature、selling_price

### 5.2 唯一性约束
- users.user_name：用户名唯一
- users.email：邮箱唯一（如果提供）
- suppliers.name：供应商名称唯一
- purchases.purchase_code：采购编号唯一
- product_skus.sku_code：SKU编号唯一
- customers.phone：客户手机号唯一

### 5.3 数据范围约束
- 价格字段：必须大于等于0
- 数量字段：必须大于等于0
- 百分比字段：0-100之间
- 枚举字段：只能取预定义值

### 5.4 关联完整性
- 所有外键必须引用存在的记录
- 删除父记录时，子记录的处理策略明确
- 重要关联使用RESTRICT防止误删

## 六、性能优化建议

### 6.1 索引优化
1. **复合索引**：根据查询模式建立复合索引
2. **覆盖索引**：减少回表查询
3. **前缀索引**：对长字符串字段使用前缀索引
4. **索引维护**：定期分析索引使用情况

### 6.2 查询优化
1. **分页查询**：使用LIMIT和OFFSET
2. **条件过滤**：在WHERE子句中使用索引字段
3. **JOIN优化**：合理使用JOIN类型
4. **子查询优化**：避免相关子查询

### 6.3 存储优化
1. **数据类型选择**：选择合适的数据类型
2. **字段长度**：根据实际需要设置字段长度
3. **NULL值处理**：合理使用NULL和默认值
4. **分区策略**：对大表考虑分区

## 七、安全性考虑

### 7.1 数据访问控制
1. **用户权限**：基于角色的访问控制
2. **敏感数据**：密码加密存储
3. **审计日志**：记录所有重要操作
4. **数据脱敏**：敏感字段在非生产环境脱敏

### 7.2 数据备份策略
1. **定期备份**：每日全量备份
2. **增量备份**：实时或定时增量备份
3. **异地备份**：备份文件异地存储
4. **恢复测试**：定期测试备份恢复

### 7.3 数据加密
1. **传输加密**：使用SSL/TLS加密传输
2. **存储加密**：敏感字段加密存储
3. **密钥管理**：安全的密钥管理机制
4. **访问日志**：记录数据访问日志

## 八、维护和监控

### 8.1 数据库监控
1. **性能监控**：查询性能、连接数、锁等待
2. **空间监控**：表空间、索引空间使用情况
3. **错误监控**：数据库错误日志监控
4. **备份监控**：备份任务执行状态

### 8.2 数据质量监控
1. **数据一致性**：定期检查数据一致性
2. **数据完整性**：检查外键约束
3. **业务规则**：验证业务逻辑正确性
4. **异常数据**：识别和处理异常数据

### 8.3 版本管理
1. **Schema版本**：数据库结构版本管理
2. **迁移脚本**：结构变更的迁移脚本
3. **回滚策略**：变更失败的回滚方案
4. **测试验证**：变更前的充分测试

---

**注意：本文档严格遵循全蛇形命名规范（snake_case），所有字段名、表名都使用下划线分隔，与实际Prisma schema代码完全一致。**