# 文档 7：错误处理与测试规范文档（提取现有错误体系）

## 一、错误分类体系（提取自《错误处理文档》1 章）

### 1.1 错误类型枚举（水晶 ERP 特化）

```typescript
enum ErrorType {
  // 业务错误（4xx）
  VALIDATION_ERROR = 'VALIDATION_ERROR', // 参数验证失败
  INVALID_DIAMETER = 'INVALID_DIAMETER', // 珠子直径无效
  AI_RECOGNITION_FAILED = 'AI_RECOGNITION_FAILED', // AI识别失败
  INSUFFICIENT_STOCK = 'INSUFFICIENT_STOCK', // 库存不足
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS', // 权限不足
  CHAT_FAILED = 'CHAT_FAILED', // AI对话失败
  INSIGHTS_FAILED = 'INSIGHTS_FAILED', // 业务洞察失败
  PURCHASE_EDIT_FAILED = 'PURCHASE_EDIT_FAILED', // 采购记录编辑失败
  PURCHASE_NOT_FOUND = 'PURCHASE_NOT_FOUND', // 采购记录不存在
  PURCHASE_DELETE_FAILED = 'PURCHASE_DELETE_FAILED', // 采购记录删除失败
  BUSINESS_CONSTRAINT_VIOLATION = 'BUSINESS_CONSTRAINT_VIOLATION', // 业务约束冲突
  NO_CHANGES_DETECTED = 'NO_CHANGES_DETECTED', // 未检测到变更
  
  // 网络错误（4xx/5xx）
  NETWORK_ERROR = 'NETWORK_ERROR', // 网络连接错误
  TIMEOUT_ERROR = 'TIMEOUT_ERROR', // 请求超时
  API_UNAVAILABLE = 'API_UNAVAILABLE', // API服务不可用
  
  // 系统错误（5xx）
  DATABASE_ERROR = 'DATABASE_ERROR', // 数据库错误
  EXTERNAL_SERVICE_ERROR = 'EXTERNAL_SERVICE_ERROR', // 外部服务错误（如OSS）
  ASSISTANT_ERROR = 'ASSISTANT_ERROR', // AI助理服务异常
}
```

### 1.2 错误响应示例（统一现有格式）

```json
// 珠子直径无效错误（雇员录入时）
{
  "success": false,
  "message": "珠子直径无效",
  "error": {
    "code": "INVALID_DIAMETER",
    "details": {
      "field": "bead_diameter",
      "value": 3.5,
      "validRange": "4-20mm"
    }
  }
}

// AI服务不可用错误
{
  "success": false,
  "message": "AI识别服务暂时不可用",
  "error": {
    "code": "AI_RECOGNITION_FAILED",
    "details": {
      "service": "doubao-ai",
      "reason": "service_timeout",
      "retryAfter": 30
    }
  }
}

// 网络连接错误
{
  "success": false,
  "message": "网络连接失败，正在尝试切换服务器",
  "error": {
    "code": "NETWORK_ERROR",
    "details": {
      "currentIP": "192.168.1.100",
      "fallbackIP": "localhost",
      "retryCount": 1
    }
  }
}

// 采购记录编辑权限不足错误
{
  "success": false,
  "message": "权限不足，仅老板可编辑采购记录",
  "error": {
    "code": "INSUFFICIENT_PERMISSIONS",
    "details": {
      "requiredRole": "BOSS",
      "currentRole": "EMPLOYEE",
      "operation": "purchase_edit"
    }
  }
}

// 采购记录不存在错误
{
  "success": false,
  "message": "采购记录不存在",
  "error": {
    "code": "PURCHASE_NOT_FOUND",
    "details": {
      "purchaseId": "purchase_123",
      "requestedBy": "user_456"
    }
  }
}

// 未检测到变更错误
{
  "success": false,
  "message": "没有检测到任何变化",
  "error": {
    "code": "NO_CHANGES_DETECTED",
    "details": {
      "submittedFields": ["product_name", "total_price"],
      "unchangedFields": ["product_name", "total_price"]
    }
  }
}

// 采购记录编辑验证失败错误
{
  "success": false,
  "message": "数据验证失败",
  "error": {
    "code": "VALIDATION_ERROR",
    "details": {
      "field": "total_price",
      "value": -100,
      "rule": "must_be_positive",
      "message": "总价必须大于0"
    }
  }
}

// 采购记录删除业务约束冲突错误
{
  "success": false,
  "message": "无法删除该采购记录，因为以下成品正在使用其珠子：南红老型珠（销售成品）#1、南红老型珠（销售成品）#2。请先将这些成品拆散，使珠子回退到库存后再删除。",
  "error": {
    "code": "BUSINESS_CONSTRAINT_VIOLATION",
    "details": {
      "constraintType": "material_usage",
      "affectedProducts": [
        {
          "productId": "product_uuid_1",
          "productName": "南红老型珠（销售成品）#1",
          "quantityUsed": 108
        },
        {
          "productId": "product_uuid_2",
          "productName": "南红老型珠（销售成品）#2",
          "quantityUsed": 216
        }
      ]
    }
  }
}

// 采购记录删除权限不足错误
{
  "success": false,
  "message": "只有老板可以删除采购记录",
  "error": {
    "code": "INSUFFICIENT_PERMISSIONS",
    "details": {
      "requiredRole": "BOSS",
      "currentRole": "EMPLOYEE",
      "operation": "purchase_delete"
    }
  }
}
```

## 二、前端错误处理（提取自《错误处理文档》2 章）

### 2.1 Axios 拦截器（现有逻辑）

```typescript
// 请求拦截器：添加Token
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('erp_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器：统一错误处理
axios.interceptors.response.use(
  response => response,
  error => {
    const errorMsg = error.response?.data?.message || '操作失败，请重试';
    // 权限不足：跳转登录
    if (error.response?.status === 401) {
      localStorage.removeItem('erp_token');
      window.location.href = '/login';
    }
    // 显示错误提示（使用useNotification）
    showErrorMessage(errorMsg);
    return Promise.reject(error);
  }
);

// 避免重复错误提示的处理机制
// 在组件的错误处理中，应该避免重复显示toast提示
// 因为axios拦截器已经处理了API错误并显示了提示
const handleApiError = (error: any) => {
  console.error('API调用失败:', error);
  
  // 注意：errorHandler已经自动处理了API错误并显示了toast提示
  // 这里只处理非API错误的情况，避免重复显示错误提示
  if (!error.response) {
    // 只有在非HTTP响应错误时才显示额外的错误提示（如网络连接问题）
    toast.error('网络连接失败，请检查网络后重试');
  }
  // 如果是HTTP响应错误，errorHandler已经处理了，不需要再次显示toast
};
```

## 三、后端错误处理规范

### 3.1 统一错误响应格式

```typescript
interface ErrorResponse {
  success: false;
  message: string;
  error: {
    code: string;
    details?: any;
  };
}
```

### 3.2 错误分类与处理

| 错误类型   | HTTP状态码 | 错误码前缀        | 处理方式       |
| ------ | ------- | ------------ | ---------- |
| 参数验证错误 | 400     | VALIDATION\_ | 返回具体字段错误信息 |
| 权限错误   | 403     | PERMISSION\_ | 记录访问日志     |
| 资源不存在  | 404     | NOT\_FOUND\_ | 检查资源ID有效性  |
| 业务逻辑错误 | 400     | BUSINESS\_   | 返回业务规则说明   |
| 系统错误   | 500     | SYSTEM\_     | 记录详细错误日志   |

### 3.3 范围筛选功能调试规范

**调试日志规范：**

```typescript
// 规格筛选调试日志示例
console.log('规格筛选参数:', {
  specificationMin: req.query.specificationMin,
  specificationMax: req.query.specificationMax,
  convertedMin: convertedMin,
  convertedMax: convertedMax
});

console.log('构建的查询条件:', {
  beadDiameterCondition: beadDiameterCondition,
  specificationCondition: specificationCondition,
  finalCondition: finalCondition
});

console.log('查询结果统计:', {
  totalCount: results.length,
  byProductType: groupByProductType(results)
});
```

**数据类型验证规范：**

```typescript
// 范围筛选参数验证
const validateRangeParams = (min?: string, max?: string) => {
  const errors: string[] = [];
  
  if (min !== undefined) {
    const minNum = parseFloat(min);
    if (isNaN(minNum) || minNum < 0) {
      errors.push('最小值必须是非负数字');
    }
  }
  
  if (max !== undefined) {
    const maxNum = parseFloat(max);
    if (isNaN(maxNum) || maxNum < 0) {
      errors.push('最大值必须是非负数字');
    }
  }
  
  if (min !== undefined && max !== undefined) {
    const minNum = parseFloat(min);
    const maxNum = parseFloat(max);
    if (minNum > maxNum) {
      errors.push('最小值不能大于最大值');
    }
  }
  
  return errors;
};
```

**查询结果验证规范：**

```typescript
// 查询结果验证和调试
const validateQueryResults = (results: any[], filters: any) => {
  // 验证规格筛选结果的正确性
  if (filters.specificationMin || filters.specificationMax) {
    const invalidResults = results.filter(item => {
      const spec = item.specification || item.bead_diameter;
      if (!spec) return false;
      
      if (filters.specificationMin && spec < filters.specificationMin) return true;
      if (filters.specificationMax && spec > filters.specificationMax) return true;
      
      return false;
    });
    
    if (invalidResults.length > 0) {
      console.warn('发现不符合规格筛选条件的结果:', invalidResults);
    }
  }
  
  return results;
};
```

## 四、测试规范（基于现有功能）

### 4.1 单元测试重点（提取自《错误处理文档》6 章）

| 测试模块               | 测试点                | 工具                           | 来源文档              |
| ------------------ | ------------------ | ---------------------------- | ----------------- |
| usePermission Hook | 敏感字段过滤逻辑（老板/雇员）    | Jest + React Testing Library | 《React 组件规范文档》4.2 |
| 采购表单验证             | 直径验证（4-20mm）、必填项验证 | React Testing Library        | 《React 组件规范文档》4.1 |
| AI 识别服务            | 置信度判断（≥0.6）、失败重试   | Jest                         | 《系统架构文档》2.3.1     |
| 库存计算               | 成品销毁后库存回滚逻辑        | Supertest（接口测试）              | 《业务流程文档》6.3       |
| 网络检测服务             | IP连通性测试、自动切换逻辑     | Jest + Mock Fetch            | 《API接口规范文档》5.5    |
| 智能重试机制             | 重试次数限制、间隔递增策略      | Jest + Sinon                 | 《API接口规范文档》5.6    |
| AI助理服务             | 对话失败处理、权限验证        | Jest + Mock API              | 《API接口规范文档》2.4    |

### 4.2 测试策略与实施

#### 4.2.1 单元测试

* 工具函数测试

* 组件逻辑测试

* API接口测试

#### 4.2.2 集成测试

* 前后端接口联调

* 数据库操作测试

* 权限验证测试

#### 4.2.3 端到端测试

* 用户操作流程测试

* 跨页面功能测试

* 移动端适配测试

#### 4.2.4 供应商功能测试验证

**BOSS角色测试：**

* ✅ 可以正常访问供应商功能

* ✅ 可以查看完整的供应商列表（30个）

* ✅ 可以正常选择和创建供应商

* ✅ 调试功能正常工作

**EMPLOYEE角色测试：**

* ✅ 无法访问供应商功能

* ✅ 显示权限不足提示

* ✅ API调用返回403错误

* ✅ 前端优雅处理权限异常

**数据一致性测试：**

* ✅ 供应商数量从9个增加到30个

* ✅ 去重逻辑正确处理ID和名称绑定关系

* ✅ 数据库统计与前端显示一致

* ✅ 调试端点返回正确的统计信息

**UI交互测试：**

* ✅ 供应商下拉框可以正常选择

* ✅ 防抖搜索功能正常

* ✅ 事件冲突问题已解决

* ✅ 下拉框层级显示正确

### 4.2 调试工具

#### 4.2.1 前端调试工具

* 网络请求监控

* 状态变化追踪

* 错误日志收集

#### 4.2.2 后端调试工具

* API响应时间监控

* 数据库查询日志

* 错误堆栈追踪

#### 4.2.3 供应商调试端点

```typescript
// 调试端点：查询供应商统计
router.get('/debug/count', authenticateToken, asyncHandler(async (req, res) => {
  const totalSuppliers = await prisma.supplier.count();
  const activeSuppliers = await prisma.supplier.count({ where: { isActive: true } });
  const allActiveSuppliers = await prisma.supplier.findMany({
    where: { isActive: true },
    select: { id: true, name: true, isActive: true, createdAt: true },
    orderBy: { name: 'asc' }
  });
  
  res.json({
    success: true,
    data: { totalSuppliers, activeSuppliers, allActiveSuppliers }
  });
}));

// 调试端点：检查重复供应商
router.get('/debug/duplicates', authenticateToken, asyncHandler(async (req, res) => {
  const duplicates = await prisma.supplier.groupBy({
    by: ['name'],
    having: {
      name: {
        _count: {
          gt: 1
        }
      }
    }
  });
  
  res.json({
    success: true,
    data: { duplicates }
  });
}));
```

## 五、批量转换安全规范

### 5.1 批量转换教训总结

**历史问题回顾（2024年1月）：**

* JavaScript内置方法被错误转换：`localStorage.removeItem` → `localStorage.remove_item`

* React组件属性被错误转换：`onClick` → `on_click`

* CSS属性名被错误转换：`backgroundColor` → `background_color`

* 造成68个文件编译错误，耗费30分钟修复时间

**根本原因：**

* 缺乏明确的转换边界定义

* 工具设计过于激进，采用一刀切策略

* 未建立完善的排除规则和白名单机制

### 5.2 绝对禁止转换清单

**JavaScript内置方法：**

```javascript
// ❌ 绝对禁止转换
localStorage.getItem    // 不能转换为 get_item
localStorage.setItem    // 不能转换为 set_item
localStorage.removeItem // 不能转换为 remove_item
document.getElementById  // 不能转换为 get_element_by_id
Array.forEach          // 不能转换为 for_each
```

**React相关属性：**

```jsx
// ❌ 绝对禁止转换
<Button onClick={handler} />     // 不能转换为 on_click
<div className="btn" />         // 不能转换为 class_name
useState, useEffect, useContext // 不能转换Hook名称
```

**CSS属性名：**

```javascript
// ❌ 绝对禁止转换
const styles = {
  backgroundColor: '#fff',  // 不能转换为 background_color
  fontSize: '14px',        // 不能转换为 font_size
  marginTop: '10px'        // 不能转换为 margin_top
};
```

### 5.3 安全转换流程

**转换前必须检查：**

1. 代码备份：`git add . && git commit -m "转换前备份"`
2. 预览模式：`node scripts/convert-camel-to-snake.cjs --preview`
3. 小范围测试：先在单个文件测试
4. 分批转换：按目录逐步转换

**转换后验证：**

1. 编译检查：`npm run build`
2. 类型检查：`npx tsc --noEmit`
3. 功能测试：启动服务验证核心功能
4. 回滚准备：`git reset --hard HEAD~1`（如有问题）

### 5.4 智能识别机制

**保护模式规则：**

```javascript
const PROTECTED_PATTERNS = [
  /\b(localStorage|sessionStorage)\.(\w+)/g,
  /\b(document|window|console)\.(\w+)/g,
  /\bon[A-Z]\w+/g,  // onClick, onChange等
  /\buse[A-Z]\w+/g, // useState, useEffect等
  /\b(className|htmlFor|tabIndex)/g,
  /\b(backgroundColor|fontSize|marginTop)/g
];
```

**安全检查函数：**

```javascript
function safetyCheck(content, filePath) {
  const warnings = [];
  PROTECTED_PATTERNS.forEach(pattern => {
    if (pattern.test(content)) {
      warnings.push(`文件 ${filePath} 包含受保护的模式`);
    }
  });
  return warnings;
}
```

```
```

