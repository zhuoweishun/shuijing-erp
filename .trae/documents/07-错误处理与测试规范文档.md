# 文档 7：错误处理与测试规范文档（基于materials表架构）

## 一、错误分类与处理策略

### 1.1 materials表相关错误处理

#### 1.1.1 字段映射错误处理

**常见问题：**
- 前端访问purchase_code字段报错
- 原因：后端已映射为material_code
- 解决：前端兼容处理，优先使用mapped字段

**兼容处理代码：**
```typescript
// 字段兼容访问
const get_material_code = (item: any): string => {
  return item.material_code || item.purchase_code || ''
}

const get_material_name = (item: any): string => {
  return item.material_name || item.purchase_name || ''
}

// 批量字段兼容处理
const normalize_material_fields = (data: any): any => {
  if (Array.isArray(data)) {
    return data.map(normalize_material_fields)
  }
  
  if (data && typeof data === 'object') {
    return {
      ...data,
      material_code: data.material_code || data.purchase_code,
      material_name: data.material_name || data.purchase_name,
      material_type: data.material_type || data.purchase_type,
      material_date: data.material_date || data.purchase_date
    }
  }
  
  return data
}
```

#### 1.1.2 数据类型错误处理

**问题：数值显示为字符串拼接结果**
- 现象："161"而不是"17"
- 原因：后端计算时未进行类型转换
- 解决：后端和前端双重Number()转换

**错误处理策略：**
```typescript
// 后端数据类型安全处理
const safe_reduce_calculation = (data: any[], field: string): number => {
  return data.reduce((sum, item) => {
    const value = Number(item[field]) || 0
    return sum + value
  }, 0)
}

// 前端数据类型验证
const validate_number_field = (value: any, field_name: string): number => {
  const num = Number(value)
  if (isNaN(num)) {
    console.warn(`字段 ${field_name} 不是有效数字:`, value)
    return 0
  }
  return num
}

// API响应数据验证
const validate_api_response = (response: any): any => {
  if (response.data && response.data.total_consumption) {
    response.data.total_consumption = validate_number_field(
      response.data.total_consumption, 
      'total_consumption'
    )
  }
  return response
}
```

#### 1.1.3 库存计算错误处理

**问题：剩余数量计算错误**
- 原因：不同产品类型的数量字段不统一
- 解决：使用CASE语句统一数量计算逻辑

**SQL错误处理：**
```sql
-- 安全的数量计算
SELECT 
  CASE 
    WHEN m.material_type = 'LOOSE_BEADS' THEN COALESCE(m.original_quantity, 0)
    WHEN m.material_type = 'BRACELET' THEN COALESCE(m.original_quantity, 0)
    WHEN m.material_type = 'ACCESSORIES' THEN COALESCE(m.original_quantity, 0)
    WHEN m.material_type = 'FINISHED_MATERIAL' THEN COALESCE(m.original_quantity, 0)
    ELSE 0
  END as safe_original_quantity,
  COALESCE(m.used_quantity, 0) as safe_used_quantity,
  GREATEST(
    CASE 
      WHEN m.material_type = 'LOOSE_BEADS' THEN COALESCE(m.original_quantity, 0)
      WHEN m.material_type = 'BRACELET' THEN COALESCE(m.original_quantity, 0)
      WHEN m.material_type = 'ACCESSORIES' THEN COALESCE(m.original_quantity, 0)
      WHEN m.material_type = 'FINISHED_MATERIAL' THEN COALESCE(m.original_quantity, 0)
      ELSE 0
    END - COALESCE(m.used_quantity, 0),
    0
  ) as safe_remaining_quantity
FROM materials m
```

### 1.2 错误分类体系（materials表架构优化）

### 1.1 错误类型枚举（materials表特化）

```typescript
enum ErrorType {
  // 业务错误（4xx）
  VALIDATION_ERROR = 'VALIDATION_ERROR', // 参数验证失败
  INVALID_DIAMETER = 'INVALID_DIAMETER', // 珠子直径无效
  AI_RECOGNITION_FAILED = 'AI_RECOGNITION_FAILED', // AI识别失败
  INSUFFICIENT_STOCK = 'INSUFFICIENT_STOCK', // 库存不足
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS', // 权限不足
  CHAT_FAILED = 'CHAT_FAILED', // AI对话失败
  INSIGHTS_FAILED = 'INSIGHTS_FAILED', // 业务洞察失败
  PURCHASE_EDIT_FAILED = 'PURCHASE_EDIT_FAILED', // 采购记录编辑失败
  PURCHASE_NOT_FOUND = 'PURCHASE_NOT_FOUND', // 采购记录不存在
  PURCHASE_DELETE_FAILED = 'PURCHASE_DELETE_FAILED', // 采购记录删除失败
  BUSINESS_CONSTRAINT_VIOLATION = 'BUSINESS_CONSTRAINT_VIOLATION', // 业务约束冲突
  NO_CHANGES_DETECTED = 'NO_CHANGES_DETECTED', // 未检测到变更
  
  // 图片处理错误
  IMAGE_UPLOAD_FAILED = 'IMAGE_UPLOAD_FAILED', // 图片上传失败
  IMAGE_CORRUPTED = 'IMAGE_CORRUPTED', // 图片文件损坏
  IMAGE_FORMAT_INVALID = 'IMAGE_FORMAT_INVALID', // 图片格式无效
  IMAGE_SIZE_EXCEEDED = 'IMAGE_SIZE_EXCEEDED', // 图片大小超限
  IMAGE_INTEGRITY_CHECK_FAILED = 'IMAGE_INTEGRITY_CHECK_FAILED', // 图片完整性检查失败
  IMAGE_CORS_ERROR = 'IMAGE_CORS_ERROR', // 图片跨域访问错误
  IMAGE_URL_CONVERSION_FAILED = 'IMAGE_URL_CONVERSION_FAILED', // 图片URL转换失败
  
  // materials表相关错误
  MATERIAL_NOT_FOUND = 'MATERIAL_NOT_FOUND', // 原材料记录不存在
  MATERIAL_SYNC_FAILED = 'MATERIAL_SYNC_FAILED', // 原材料同步失败
  MATERIAL_STOCK_INSUFFICIENT = 'MATERIAL_STOCK_INSUFFICIENT', // 原材料库存不足
  MATERIAL_STATUS_INVALID = 'MATERIAL_STATUS_INVALID', // 原材料状态无效
  MATERIAL_TRIGGER_ERROR = 'MATERIAL_TRIGGER_ERROR', // 触发器执行错误
  MATERIAL_CALCULATION_ERROR = 'MATERIAL_CALCULATION_ERROR', // 库存计算错误
  
  // 库存弹窗相关错误（基于materials表）
  INVENTORY_MODAL_DATA_ERROR = 'INVENTORY_MODAL_DATA_ERROR', // 库存弹窗数据错误
  MATERIAL_CODE_MISSING = 'MATERIAL_CODE_MISSING', // 原材料编号缺失
  BATCH_INFO_INCOMPLETE = 'BATCH_INFO_INCOMPLETE', // 批次信息不完整
  MODAL_RENDER_ERROR = 'MODAL_RENDER_ERROR', // 弹窗渲染错误
  PRICE_DISPLAY_ERROR = 'PRICE_DISPLAY_ERROR', // 价格显示错误
  
  // 网络错误（4xx/5xx）
  NETWORK_ERROR = 'NETWORK_ERROR', // 网络连接错误
  TIMEOUT_ERROR = 'TIMEOUT_ERROR', // 请求超时
  API_UNAVAILABLE = 'API_UNAVAILABLE', // API服务不可用
  
  // 系统错误（5xx）
  DATABASE_ERROR = 'DATABASE_ERROR', // 数据库错误
  EXTERNAL_SERVICE_ERROR = 'EXTERNAL_SERVICE_ERROR', // 外部服务错误（如OSS）
  ASSISTANT_ERROR = 'ASSISTANT_ERROR', // AI助理服务异常
}
```

### 1.2 错误响应示例（统一现有格式）

```json
// 珠子直径无效错误（雇员录入时）
{
  "success": false,
  "message": "珠子直径无效",
  "error": {
    "code": "INVALID_DIAMETER",
    "details": {
      "field": "bead_diameter",
      "value": 3.5,
      "validRange": "4-20mm"
    }
  }
}

// AI服务不可用错误
{
  "success": false,
  "message": "AI识别服务暂时不可用",
  "error": {
    "code": "AI_RECOGNITION_FAILED",
    "details": {
      "service": "doubao-ai",
      "reason": "service_timeout",
      "retryAfter": 30
    }
  }
}

// 网络连接错误
{
  "success": false,
  "message": "网络连接失败，正在尝试切换服务器",
  "error": {
    "code": "NETWORK_ERROR",
    "details": {
      "currentIP": "192.168.1.100",
      "fallbackIP": "localhost",
      "retryCount": 1
    }
  }
}

// 采购记录编辑权限不足错误
{
  "success": false,
  "message": "权限不足，仅老板可编辑采购记录",
  "error": {
    "code": "INSUFFICIENT_PERMISSIONS",
    "details": {
      "requiredRole": "BOSS",
      "currentRole": "EMPLOYEE",
      "operation": "purchase_edit"
    }
  }
}

// 采购记录不存在错误
{
  "success": false,
  "message": "采购记录不存在",
  "error": {
    "code": "PURCHASE_NOT_FOUND",
    "details": {
      "purchaseId": "purchase_123",
      "requestedBy": "user_456"
    }
  }
}

// 未检测到变更错误
{
  "success": false,
  "message": "没有检测到任何变化",
  "error": {
    "code": "NO_CHANGES_DETECTED",
    "details": {
      "submittedFields": ["product_name", "total_price"],
      "unchangedFields": ["product_name", "total_price"]
    }
  }
}

// 采购记录编辑验证失败错误
{
  "success": false,
  "message": "数据验证失败",
  "error": {
    "code": "VALIDATION_ERROR",
    "details": {
      "field": "total_price",
      "value": -100,
      "rule": "must_be_positive",
      "message": "总价必须大于0"
    }
  }
}

// 采购记录删除业务约束冲突错误
{
  "success": false,
  "message": "无法删除该采购记录，因为以下成品正在使用其珠子：南红老型珠（销售成品）#1、南红老型珠（销售成品）#2。请先将这些成品拆散，使珠子回退到库存后再删除。",
  "error": {
    "code": "BUSINESS_CONSTRAINT_VIOLATION",
    "details": {
      "constraintType": "material_usage",
      "affectedProducts": [
        {
          "productId": "product_uuid_1",
          "productName": "南红老型珠（销售成品）#1",
          "quantityUsed": 108
        },
        {
          "productId": "product_uuid_2",
          "productName": "南红老型珠（销售成品）#2",
          "quantityUsed": 216
        }
      ]
    }
  }
}

// 采购记录删除权限不足错误
{
  "success": false,
  "message": "只有老板可以删除采购记录",
  "error": {
    "code": "INSUFFICIENT_PERMISSIONS",
    "details": {
      "requiredRole": "BOSS",
      "currentRole": "EMPLOYEE",
      "operation": "purchase_delete"
    }
  }
}

// 图片上传失败错误
{
  "success": false,
  "message": "图片上传失败",
  "error": {
    "code": "IMAGE_UPLOAD_FAILED",
    "details": {
      "filename": "photo.jpg",
      "fileSize": "5.2MB",
      "reason": "file_too_large",
      "maxSize": "2MB"
    }
  }
}

// 图片文件损坏错误
{
  "success": false,
  "message": "图片文件已损坏，无法显示",
  "error": {
    "code": "IMAGE_CORRUPTED",
    "details": {
      "filename": "product_image.jpg",
      "url": "https://example.com/image.jpg",
      "reason": "file_corrupted"
    }
  }
}

// 库存弹窗数据错误
{
  "success": false,
  "message": "库存弹窗数据加载失败",
  "error": {
    "code": "INVENTORY_MODAL_DATA_ERROR",
    "details": {
      "productId": "product_123",
      "missingFields": ["purchase_code", "supplier_name"],
      "reason": "incomplete_data"
    }
  }
}

// CG编号缺失错误
{
  "success": false,
  "message": "CG编号信息缺失，无法显示完整批次信息",
  "error": {
    "code": "CG_CODE_MISSING",
    "details": {
      "productId": "product_123",
      "fallbackUsed": "batch_number",
      "displayValue": "暂无编号"
    }
  }
}

// 弹窗渲染错误
{
  "success": false,
  "message": "弹窗组件渲染失败",
  "error": {
    "code": "MODAL_RENDER_ERROR",
    "details": {
      "component": "InventoryModal",
      "reason": "data_type_mismatch",
      "field": "unit_price",
      "expectedType": "number",
      "actualType": "string"
    }
  }
}

// 价格显示权限错误
{
  "success": false,
  "message": "权限不足，无法查看价格信息",
  "error": {
    "code": "PRICE_DISPLAY_ERROR",
    "details": {
      "userRole": "EMPLOYEE",
      "requiredRole": "BOSS",
      "hiddenFields": ["unit_price", "total_price"]
    }
  }
}
  "error": {
    "code": "IMAGE_CORRUPTED",
    "details": {
      "filename": "1756102840000_47.jpg",
      "corruptionType": "invalid_jpeg_footer",
      "autoFixed": true,
      "newUrl": "http://api.dorblecapital.com/uploads/purchases/1756227752158_158.png"
    }
  }
}

// 图片格式无效错误
{
  "success": false,
  "message": "不支持的图片格式",
  "error": {
    "code": "IMAGE_FORMAT_INVALID",
    "details": {
      "filename": "document.pdf",
      "detectedFormat": "application/pdf",
      "supportedFormats": ["image/jpeg", "image/png", "image/webp"]
    }
  }
}

// 图片完整性检查失败错误
{
  "success": false,
  "message": "图片完整性检查失败",
  "error": {
    "code": "IMAGE_INTEGRITY_CHECK_FAILED",
    "details": {
      "filename": "1756102840000_47.jpg",
      "checkType": "jpeg_header_footer",
      "failedChecks": ["footer_validation"],
      "recommendAction": "replace_with_valid_image"
    }
  }
}

// 图片CORS跨域访问错误
{
  "success": false,
  "message": "图片跨域访问被阻止",
  "error": {
    "code": "IMAGE_CORS_ERROR",
    "details": {
      "originalUrl": "http://api.dorblecapital.com/uploads/purchases/1756200427567_720.jpeg",
      "currentEnvironment": "development",
      "currentHostname": "localhost",
      "errorType": "net::ERR_BLOCKED_BY_RESPONSE.NotSameOrigin",
      "solution": "URL已自动转换为本地地址",
      "convertedUrl": "http://localhost:3001/uploads/purchases/1756200427567_720.jpeg"
    }
  }
}

// 图片URL转换失败错误
{
  "success": false,
  "message": "图片URL转换失败",
  "error": {
    "code": "IMAGE_URL_CONVERSION_FAILED",
    "details": {
      "originalUrl": "http://api.dorblecapital.com/uploads/purchases/invalid_image.jpg",
      "conversionType": "production_to_local",
      "reason": "target_server_unreachable",
      "fallbackAction": "display_placeholder_image"
    }
  }
}
```

## 二、前端错误处理（提取自《错误处理文档》2 章）

### 2.1 Axios 拦截器（现有逻辑）

```typescript
// 请求拦截器：添加Token
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('erp_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器：统一错误处理
axios.interceptors.response.use(
  response => response,
  error => {
    const errorMsg = error.response?.data?.message || '操作失败，请重试';
    // 权限不足：跳转登录
    if (error.response?.status === 401) {
      localStorage.removeItem('erp_token');
      window.location.href = '/login';
    }
    // 显示错误提示（使用useNotification）
    showErrorMessage(errorMsg);
    return Promise.reject(error);
  }
);

// 避免重复错误提示的处理机制
// 在组件的错误处理中，应该避免重复显示toast提示
// 因为axios拦截器已经处理了API错误并显示了提示
const handleApiError = (error: any) => {
  console.error('API调用失败:', error);
  
  // 注意：errorHandler已经自动处理了API错误并显示了toast提示
  // 这里只处理非API错误的情况，避免重复显示错误提示
  if (!error.response) {
    // 只有在非HTTP响应错误时才显示额外的错误提示（如网络连接问题）
    toast.error('网络连接失败，请检查网络后重试');
  }
  // 如果是HTTP响应错误，errorHandler已经处理了，不需要再次显示toast
};

// 图片CORS错误处理机制
const handleImageCorsError = (imageElement: HTMLImageElement, originalUrl: string) => {
  console.warn('图片CORS错误，尝试URL转换:', originalUrl);
  
  // 使用fixImageUrl函数进行URL转换
  const convertedUrl = fixImageUrl(originalUrl);
  
  if (convertedUrl !== originalUrl) {
    console.log('图片URL已转换:', { originalUrl, convertedUrl });
    imageElement.src = convertedUrl;
  } else {
    console.error('图片URL转换失败，显示占位图片');
    imageElement.src = '/placeholder-image.png';
    imageElement.alt = '图片加载失败';
  }
};

// 图片组件中的错误处理示例
const ImageWithErrorHandling = ({ src, alt, ...props }) => {
  const handleImageError = (e: React.SyntheticEvent<HTMLImageElement>) => {
    const target = e.target as HTMLImageElement;
    
    // 检查是否是CORS错误
    if (src.includes('api.dorblecapital.com') && window.location.hostname === 'localhost') {
      handleImageCorsError(target, src);
    } else {
      // 其他错误，显示占位图片
      target.src = '/placeholder-image.png';
      target.alt = '图片加载失败';
    }
  };
  
  return (
    <img
      src={fixImageUrl(src)}
      alt={alt}
      onError={handleImageError}
      {...props}
    />
  );
};
```

## 三、后端错误处理规范

### 3.1 统一错误响应格式

```typescript
interface ErrorResponse {
  success: false;
  message: string;
  error: {
    code: string;
    details?: any;
  };
}
```

### 3.2 错误分类与处理

| 错误类型   | HTTP状态码 | 错误码前缀        | 处理方式       |
| ------ | ------- | ------------ | ---------- |
| 参数验证错误 | 400     | VALIDATION\_ | 返回具体字段错误信息 |
| 权限错误   | 403     | PERMISSION\_ | 记录访问日志     |
| 资源不存在  | 404     | NOT\_FOUND\_ | 检查资源ID有效性  |
| 业务逻辑错误 | 400     | BUSINESS\_   | 返回业务规则说明   |
| 系统错误   | 500     | SYSTEM\_     | 记录详细错误日志   |

### 3.3 范围筛选功能调试规范

**调试日志规范：**

```typescript
// 规格筛选调试日志示例
console.log('规格筛选参数:', {
  specificationMin: req.query.specificationMin,
  specificationMax: req.query.specificationMax,
  convertedMin: convertedMin,
  convertedMax: convertedMax
});

console.log('构建的查询条件:', {
  beadDiameterCondition: beadDiameterCondition,
  specificationCondition: specificationCondition,
  finalCondition: finalCondition
});

console.log('查询结果统计:', {
  totalCount: results.length,
  byProductType: groupByProductType(results)
});
```

**数据类型验证规范：**

```typescript
// 范围筛选参数验证
const validateRangeParams = (min?: string, max?: string) => {
  const errors: string[] = [];
  
  if (min !== undefined) {
    const minNum = parseFloat(min);
    if (isNaN(minNum) || minNum < 0) {
      errors.push('最小值必须是非负数字');
    }
  }
  
  if (max !== undefined) {
    const maxNum = parseFloat(max);
    if (isNaN(maxNum) || maxNum < 0) {
      errors.push('最大值必须是非负数字');
    }
  }
  
  if (min !== undefined && max !== undefined) {
    const minNum = parseFloat(min);
    const maxNum = parseFloat(max);
    if (minNum > maxNum) {
      errors.push('最小值不能大于最大值');
    }
  }
  
  return errors;
};
```

**查询结果验证规范：**

```typescript
// 查询结果验证和调试
const validateQueryResults = (results: any[], filters: any) => {
  // 验证规格筛选结果的正确性
  if (filters.specificationMin || filters.specificationMax) {
    const invalidResults = results.filter(item => {
      const spec = item.specification || item.bead_diameter;
      if (!spec) return false;
      
      if (filters.specificationMin && spec < filters.specificationMin) return true;
      if (filters.specificationMax && spec > filters.specificationMax) return true;
      
      return false;
    });
    
    if (invalidResults.length > 0) {
      console.warn('发现不符合规格筛选条件的结果:', invalidResults);
    }
  }
  
  return results;
};
```

## 四、测试规范（基于现有功能）

### 4.1 单元测试重点（提取自《错误处理文档》6 章）

| 测试模块               | 测试点                | 工具                           | 来源文档              |
| ------------------ | ------------------ | ---------------------------- | ----------------- |
| usePermission Hook | 敏感字段过滤逻辑（老板/雇员）    | Jest + React Testing Library | 《React 组件规范文档》4.2 |
| 采购表单验证             | 直径验证（4-20mm）、必填项验证 | React Testing Library        | 《React 组件规范文档》4.1 |
| AI 识别服务            | 置信度判断（≥0.6）、失败重试   | Jest                         | 《系统架构文档》2.3.1     |
| 库存计算               | 成品销毁后库存回滚逻辑        | Supertest（接口测试）              | 《业务流程文档》6.3       |
| 网络检测服务             | IP连通性测试、自动切换逻辑     | Jest + Mock Fetch            | 《API接口规范文档》5.5    |
| 智能重试机制             | 重试次数限制、间隔递增策略      | Jest + Sinon                 | 《API接口规范文档》5.6    |
| AI助理服务             | 对话失败处理、权限验证        | Jest + Mock API              | 《API接口规范文档》2.4    |
| 库存弹窗组件             | CG编号显示逻辑、数据容错处理   | React Testing Library        | 《UI设计规范文档》5.1     |
| 弹窗交互优化             | 点击空白关闭、事件冒泡阻止     | Jest + User Events           | 《前端开发规范文档》4.8   |
| 批次信息显示             | 字段优先级、默认值处理        | Jest                         | 《数据库设计文档》1.1.3   |
| 价格权限控制             | BOSS/EMPLOYEE权限验证     | React Testing Library        | 《权限安全规范文档》3.2   |

### 4.2 测试策略与实施

#### 4.2.1 单元测试

* 工具函数测试

* 组件逻辑测试

* API接口测试

#### 4.2.2 集成测试

* 前后端接口联调

* 数据库操作测试

* 权限验证测试

#### 4.2.3 端到端测试

* 用户操作流程测试

* 跨页面功能测试

* 移动端适配测试

#### 4.2.4 供应商功能测试验证

**BOSS角色测试：**

* ✅ 可以正常访问供应商功能

* ✅ 可以查看完整的供应商列表（30个）

* ✅ 可以正常选择和创建供应商

* ✅ 调试功能正常工作

**EMPLOYEE角色测试：**

* ✅ 无法访问供应商功能

* ✅ 显示权限不足提示

* ✅ API调用返回403错误

* ✅ 前端优雅处理权限异常

**数据一致性测试：**

* ✅ 供应商数量从9个增加到30个

* ✅ 去重逻辑正确处理ID和名称绑定关系

* ✅ 数据库统计与前端显示一致

* ✅ 调试端点返回正确的统计信息

**UI交互测试：**

* ✅ 供应商下拉框可以正常选择

* ✅ 防抖搜索功能正常

* ✅ 事件冲突问题已解决

* ✅ 下拉框层级显示正确

### 4.2 调试工具

#### 4.2.1 前端调试工具

* 网络请求监控

* 状态变化追踪

* 错误日志收集

#### 4.2.2 后端调试工具

* API响应时间监控

* 数据库查询日志

* 错误堆栈追踪

#### 4.2.3 供应商调试端点

```typescript
// 调试端点：查询供应商统计
router.get('/debug/count', authenticateToken, asyncHandler(async (req, res) => {
  const totalSuppliers = await prisma.supplier.count();
  const activeSuppliers = await prisma.supplier.count({ where: { isActive: true } });
  const allActiveSuppliers = await prisma.supplier.findMany({
    where: { isActive: true },
    select: { id: true, name: true, isActive: true, createdAt: true },
    orderBy: { name: 'asc' }
  });
  
  res.json({
    success: true,
    data: { totalSuppliers, activeSuppliers, allActiveSuppliers }
  });
}));

// 调试端点：检查重复供应商
router.get('/debug/duplicates', authenticateToken, asyncHandler(async (req, res) => {
  const duplicates = await prisma.supplier.groupBy({
    by: ['name'],
    having: {
      name: {
        _count: {
          gt: 1
        }
      }
    }
  });
  
  res.json({
    success: true,
    data: { duplicates }
  });
}));
```

## 五、批量转换安全规范

### 5.1 批量转换教训总结

**历史问题回顾（2024年1月）：**

* JavaScript内置方法被错误转换：`localStorage.removeItem` → `localStorage.remove_item`

* React组件属性被错误转换：`onClick` → `on_click`

* CSS属性名被错误转换：`backgroundColor` → `background_color`

* 造成68个文件编译错误，耗费30分钟修复时间

**根本原因：**

* 缺乏明确的转换边界定义

* 工具设计过于激进，采用一刀切策略

* 未建立完善的排除规则和白名单机制

### 5.2 绝对禁止转换清单

**JavaScript内置方法：**

```javascript
// ❌ 绝对禁止转换
localStorage.getItem    // 不能转换为 get_item
localStorage.setItem    // 不能转换为 set_item
localStorage.removeItem // 不能转换为 remove_item
document.getElementById  // 不能转换为 get_element_by_id
Array.forEach          // 不能转换为 for_each
```

**React相关属性：**

```jsx
// ❌ 绝对禁止转换
<Button onClick={handler} />     // 不能转换为 on_click
<div className="btn" />         // 不能转换为 class_name
useState, useEffect, useContext // 不能转换Hook名称
```

**CSS属性名：**

```javascript
// ❌ 绝对禁止转换
const styles = {
  backgroundColor: '#fff',  // 不能转换为 background_color
  fontSize: '14px',        // 不能转换为 font_size
  marginTop: '10px'        // 不能转换为 margin_top
};
```

### 5.3 安全转换流程

**转换前必须检查：**

1. 代码备份：`git add . && git commit -m "转换前备份"`
2. 预览模式：`node scripts/convert-camel-to-snake.cjs --preview`
3. 小范围测试：先在单个文件测试
4. 分批转换：按目录逐步转换

**转换后验证：**

1. 编译检查：`npm run build`
2. 类型检查：`npx tsc --noEmit`
3. 功能测试：启动服务验证核心功能
4. 回滚准备：`git reset --hard HEAD~1`（如有问题）

### 5.4 智能识别机制

**保护模式规则：**

```javascript
const PROTECTED_PATTERNS = [
  /\b(localStorage|sessionStorage)\.(\w+)/g,
  /\b(document|window|console)\.(\w+)/g,
  /\bon[A-Z]\w+/g,  // onClick, onChange等
  /\buse[A-Z]\w+/g, // useState, useEffect等
  /\b(className|htmlFor|tabIndex)/g,
  /\b(backgroundColor|fontSize|marginTop)/g
];
```

**安全检查函数：**

```javascript
function safetyCheck(content, filePath) {
  const warnings = [];
  PROTECTED_PATTERNS.forEach(pattern => {
    if (pattern.test(content)) {
      warnings.push(`文件 ${filePath} 包含受保护的模式`);
    }
  });
  return warnings;
}
```

```
// ... existing code ...

## 6. SKU系统错误处理规范

### 6.1 SKU API错误处理

#### 6.1.1 SKU列表查询错误

**错误类型：**
- 网络连接错误
- 服务器内部错误
- 权限验证失败
- 参数验证错误

**错误处理策略：**
```typescript
// SKU列表查询错误处理
const handleSkuListError = (error: any) => {
  if (error.response?.status === 401) {
    // 认证失败
    toast.error('登录已过期，请重新登录');
    router.push('/login');
  } else if (error.response?.status === 403) {
    // 权限不足
    toast.error('权限不足，无法访问SKU数据');
  } else if (error.response?.status === 422) {
    // 参数验证错误
    const message = error.response.data?.message || '请求参数错误';
    toast.error(message);
  } else if (error.response?.status >= 500) {
    // 服务器错误
    toast.error('服务器暂时不可用，请稍后重试');
  } else if (error.code === 'NETWORK_ERROR') {
    // 网络错误
    toast.error('网络连接失败，请检查网络设置');
  } else {
    // 未知错误
    toast.error('获取SKU列表失败，请重试');
  }
};
```

#### 6.1.2 SKU库存调整错误

**业务错误类型：**
- `INSUFFICIENT_STOCK`：库存不足
- `INVALID_QUANTITY`：数量无效
- `SKU_NOT_FOUND`：SKU不存在
- `OPERATION_CONFLICT`：操作冲突

**错误处理实现：**
```typescript
// SKU库存调整错误处理
const handleInventoryAdjustError = (error: any) => {
  const errorCode = error.response?.data?.error?.code;
  const errorDetails = error.response?.data?.error?.details;
  
  switch (errorCode) {
    case 'INSUFFICIENT_STOCK':
      toast.error(`库存不足，当前可售：${errorDetails.available_quantity}件`);
      break;
    case 'INVALID_QUANTITY':
      toast.error('调整数量无效，请输入正确的数量');
      break;
    case 'SKU_NOT_FOUND':
      toast.error('SKU不存在，请刷新页面后重试');
      // 自动刷新SKU列表
      refreshSkuList();
      break;
    case 'OPERATION_CONFLICT':
      toast.error('操作冲突，请稍后重试');
      break;
    default:
      toast.error(error.response?.data?.message || '库存调整失败');
  }
};
```

#### 6.1.3 SKU销售记录错误

**销售错误场景：**
- 库存不足无法销售
- SKU状态不允许销售
- 销售数量超出限制
- 并发销售冲突

**错误处理逻辑：**
```typescript
// SKU销售错误处理
const handleSkuSaleError = (error: any) => {
  const errorCode = error.response?.data?.error?.code;
  const errorDetails = error.response?.data?.error?.details;
  
  if (errorCode === 'INSUFFICIENT_STOCK') {
    // 库存不足错误
    const availableQuantity = errorDetails.available_quantity;
    const requestedQuantity = errorDetails.requested_quantity;
    
    toast.error(
      `库存不足！当前可售：${availableQuantity}件，请求：${requestedQuantity}件`,
      { duration: 5000 }
    );
    
    // 自动调整销售数量为可用数量
    if (availableQuantity > 0) {
      setSaleQuantity(availableQuantity);
      toast.info(`已自动调整销售数量为${availableQuantity}件`);
    }
  } else if (errorCode === 'SKU_INACTIVE') {
    toast.error('该SKU已停用，无法销售');
  } else if (errorCode === 'CONCURRENT_SALE') {
    toast.error('检测到并发销售，请刷新后重试');
    refreshSkuList();
  } else {
    toast.error('销售记录失败，请重试');
  }
};
```

### 6.2 SKU数据验证错误

#### 6.2.1 前端表单验证

**验证规则：**
```typescript
// SKU表单验证规则
const skuValidationRules = {
  quantity: {
    required: true,
    min: 1,
    max: 9999,
    integer: true,
    message: '数量必须是1-9999之间的整数'
  },
  notes: {
    maxLength: 500,
    message: '备注不能超过500个字符'
  },
  price: {
    min: 0,
    max: 999999.99,
    decimal: 2,
    message: '价格必须是0-999999.99之间的数值'
  }
};

// 表单验证函数
const validateSkuForm = (formData: any) => {
  const errors: string[] = [];
  
  // 数量验证
  if (!formData.quantity || formData.quantity < 1 || formData.quantity > 9999) {
    errors.push(skuValidationRules.quantity.message);
  }
  
  // 备注长度验证
  if (formData.notes && formData.notes.length > 500) {
    errors.push(skuValidationRules.notes.message);
  }
  
  // 价格验证
  if (formData.price !== undefined && (formData.price < 0 || formData.price > 999999.99)) {
    errors.push(skuValidationRules.price.message);
  }
  
  return errors;
};
```

#### 6.2.2 后端数据验证错误

**Zod验证错误处理：**
```typescript
// 后端验证错误格式化
const formatValidationError = (zodError: ZodError) => {
  const errors = zodError.errors.map(error => {
    const field = error.path.join('.');
    const message = error.message;
    
    // 自定义错误消息
    switch (error.code) {
      case 'too_small':
        return `${field}：数值过小，最小值为${error.minimum}`;
      case 'too_big':
        return `${field}：数值过大，最大值为${error.maximum}`;
      case 'invalid_type':
        return `${field}：数据类型错误，期望${error.expected}，实际${error.received}`;
      default:
        return `${field}：${message}`;
    }
  });
  
  return {
    code: 'VALIDATION_ERROR',
    message: '数据验证失败',
    details: errors
  };
};
```

### 6.3 SKU权限错误处理

#### 6.3.1 角色权限验证

**权限错误类型：**
- 未登录用户访问
- EMPLOYEE角色访问敏感数据
- 无效的JWT Token
- Token过期

**权限错误处理：**
```typescript
// 权限错误统一处理
const handlePermissionError = (error: any) => {
  const status = error.response?.status;
  const errorCode = error.response?.data?.error?.code;
  
  if (status === 401) {
    if (errorCode === 'TOKEN_EXPIRED') {
      toast.error('登录已过期，请重新登录');
      // 清除本地存储的认证信息
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      // 重定向到登录页
      window.location.href = '/login';
    } else {
      toast.error('请先登录系统');
      router.push('/login');
    }
  } else if (status === 403) {
    if (errorCode === 'INSUFFICIENT_ROLE') {
      toast.error('权限不足，该功能仅限管理员使用');
    } else {
      toast.error('权限不足，无法执行此操作');
    }
  }
};
```

#### 6.3.2 敏感数据过滤错误

**数据过滤失败处理：**
```typescript
// 敏感数据过滤错误处理
const handleDataFilterError = (data: any, userRole: string) => {
  try {
    // 根据用户角色过滤敏感字段
    if (userRole === 'EMPLOYEE') {
      const filteredData = data.map((item: any) => {
        const { materialCost, laborCost, craftCost, totalCost, profitMargin, ...publicFields } = item;
        return publicFields;
      });
      return filteredData;
    }
    return data;
  } catch (error) {
    console.error('数据过滤失败:', error);
    // 返回空数组，确保不泄露敏感信息
    return [];
  }
};
```

### 6.4 SKU并发操作错误

#### 6.4.1 乐观锁冲突

**并发冲突检测：**
```typescript
// 乐观锁冲突处理
const handleOptimisticLockError = (error: any) => {
  if (error.response?.data?.error?.code === 'OPTIMISTIC_LOCK_CONFLICT') {
    toast.warning('数据已被其他用户修改，正在刷新最新数据...');
    
    // 自动刷新数据
    setTimeout(() => {
      refreshSkuList();
      toast.info('数据已刷新，请重新操作');
    }, 1000);
  }
};
```

#### 6.4.2 库存并发修改

**库存冲突处理：**
```typescript
// 库存并发修改错误处理
const handleInventoryConflict = (error: any) => {
  const errorCode = error.response?.data?.error?.code;
  const errorDetails = error.response?.data?.error?.details;
  
  if (errorCode === 'INVENTORY_CONFLICT') {
    const currentQuantity = errorDetails.current_quantity;
    const attemptedQuantity = errorDetails.attempted_quantity;
    
    toast.error(
      `库存冲突！当前库存：${currentQuantity}，尝试操作：${attemptedQuantity}`,
      { duration: 6000 }
    );
    
    // 提供解决方案
    toast.info('建议：刷新页面获取最新库存数据后重试');
  }
};
```

### 6.5 SKU系统错误监控

#### 6.5.1 错误日志记录

**前端错误监控：**
```typescript
// SKU错误监控服务
class SkuErrorMonitor {
  private static instance: SkuErrorMonitor;
  
  static getInstance() {
    if (!this.instance) {
      this.instance = new SkuErrorMonitor();
    }
    return this.instance;
  }
  
  // 记录SKU操作错误
  logSkuError(operation: string, error: any, context?: any) {
    const errorLog = {
      timestamp: new Date().toISOString(),
      operation,
      error: {
        message: error.message,
        status: error.response?.status,
        code: error.response?.data?.error?.code,
        details: error.response?.data?.error?.details
      },
      context,
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    // 发送到监控服务
    this.sendToMonitoring(errorLog);
    
    // 本地存储（用于离线分析）
    this.storeLocally(errorLog);
  }
  
  private sendToMonitoring(errorLog: any) {
    // 发送到错误监控服务（如Sentry）
    try {
      fetch('/api/v1/monitoring/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorLog)
      }).catch(err => {
        console.warn('错误监控服务不可用:', err);
      });
    } catch (error) {
      console.warn('发送错误日志失败:', error);
    }
  }
  
  private storeLocally(errorLog: any) {
    try {
      const logs = JSON.parse(localStorage.getItem('sku_error_logs') || '[]');
      logs.push(errorLog);
      
      // 只保留最近100条错误日志
      if (logs.length > 100) {
        logs.splice(0, logs.length - 100);
      }
      
      localStorage.setItem('sku_error_logs', JSON.stringify(logs));
    } catch (error) {
      console.warn('本地存储错误日志失败:', error);
    }
  }
}
```

#### 6.5.2 错误恢复策略

**自动重试机制：**
```typescript
// SKU操作自动重试
class SkuRetryHandler {
  private maxRetries = 3;
  private retryDelay = 1000; // 1秒
  
  async executeWithRetry<T>(
    operation: () => Promise<T>,
    operationName: string,
    context?: any
  ): Promise<T> {
    let lastError: any;
    
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        // 记录重试日志
        console.warn(`SKU操作失败，第${attempt}次重试:`, {
          operation: operationName,
          attempt,
          error: error.message
        });
        
        // 判断是否应该重试
        if (!this.shouldRetry(error) || attempt === this.maxRetries) {
          break;
        }
        
        // 等待后重试
        await this.delay(this.retryDelay * attempt);
      }
    }
    
    // 记录最终失败
    SkuErrorMonitor.getInstance().logSkuError(operationName, lastError, {
      ...context,
      retryAttempts: this.maxRetries
    });
    
    throw lastError;
  }
  
  private shouldRetry(error: any): boolean {
    const status = error.response?.status;
    const errorCode = error.response?.data?.error?.code;
    
    // 不重试的错误类型
    const nonRetryableErrors = [
      'VALIDATION_ERROR',
      'INSUFFICIENT_STOCK',
      'SKU_NOT_FOUND',
      'PERMISSION_DENIED'
    ];
    
    // 不重试的HTTP状态码
    const nonRetryableStatus = [400, 401, 403, 404, 422];
    
    if (nonRetryableStatus.includes(status) || nonRetryableErrors.includes(errorCode)) {
      return false;
    }
    
    // 网络错误和服务器错误可以重试
    return status >= 500 || error.code === 'NETWORK_ERROR';
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 6.6 SKU错误处理测试

#### 6.6.1 错误场景测试用例

**测试用例定义：**
```typescript
// SKU错误处理测试用例
describe('SKU错误处理测试', () => {
  describe('库存调整错误', () => {
    it('应该正确处理库存不足错误', async () => {
      // 模拟库存不足错误
      const mockError = {
        response: {
          status: 400,
          data: {
            error: {
              code: 'INSUFFICIENT_STOCK',
              details: { available_quantity: 3, requested_quantity: 5 }
            }
          }
        }
      };
      
      const toastSpy = jest.spyOn(toast, 'error');
      handleInventoryAdjustError(mockError);
      
      expect(toastSpy).toHaveBeenCalledWith(
        '库存不足，当前可售：3件'
      );
    });
    
    it('应该正确处理SKU不存在错误', async () => {
      const mockError = {
        response: {
          status: 404,
          data: {
            error: { code: 'SKU_NOT_FOUND' }
          }
        }
      };
      
      const refreshSpy = jest.spyOn(window, 'refreshSkuList');
      handleInventoryAdjustError(mockError);
      
      expect(refreshSpy).toHaveBeenCalled();
    });
  });
  
  describe('权限错误处理', () => {
    it('应该正确处理Token过期错误', () => {
      const mockError = {
        response: {
          status: 401,
          data: {
            error: { code: 'TOKEN_EXPIRED' }
          }
        }
      };
      
      const localStorageSpy = jest.spyOn(localStorage, 'removeItem');
      handlePermissionError(mockError);
      
      expect(localStorageSpy).toHaveBeenCalledWith('token');
      expect(localStorageSpy).toHaveBeenCalledWith('user');
    });
  });
  
  describe('并发操作错误', () => {
    it('应该正确处理乐观锁冲突', () => {
      const mockError = {
        response: {
          data: {
            error: { code: 'OPTIMISTIC_LOCK_CONFLICT' }
          }
        }
      };
      
      const refreshSpy = jest.spyOn(window, 'refreshSkuList');
      handleOptimisticLockError(mockError);
      
      // 验证延迟刷新
      setTimeout(() => {
        expect(refreshSpy).toHaveBeenCalled();
      }, 1100);
    });
  });
});
```

#### 6.6.2 错误恢复测试

**重试机制测试：**
```typescript
// 重试机制测试
describe('SKU重试机制测试', () => {
  let retryHandler: SkuRetryHandler;
  
  beforeEach(() => {
    retryHandler = new SkuRetryHandler();
  });
  
  it('应该在网络错误时自动重试', async () => {
    let callCount = 0;
    const mockOperation = jest.fn().mockImplementation(() => {
      callCount++;
      if (callCount < 3) {
        throw { code: 'NETWORK_ERROR', message: '网络连接失败' };
      }
      return Promise.resolve('success');
    });
    
    const result = await retryHandler.executeWithRetry(
      mockOperation,
      'test_operation'
    );
    
    expect(result).toBe('success');
    expect(mockOperation).toHaveBeenCalledTimes(3);
  });
  
  it('不应该重试业务逻辑错误', async () => {
    const mockOperation = jest.fn().mockRejectedValue({
      response: {
        status: 400,
        data: { error: { code: 'VALIDATION_ERROR' } }
      }
    });
    
    await expect(
      retryHandler.executeWithRetry(mockOperation, 'test_operation')
    ).rejects.toThrow();
    
    expect(mockOperation).toHaveBeenCalledTimes(1);
  });
});
```

### 6.7 SKU错误处理最佳实践

#### 6.7.1 用户友好的错误提示

**错误提示原则：**
1. **明确性**：清楚说明发生了什么错误
2. **可操作性**：提供用户可以采取的解决方案
3. **及时性**：错误发生后立即显示提示
4. **一致性**：相同错误使用相同的提示文案

**错误提示示例：**
```typescript
// 用户友好的错误提示
const userFriendlyErrors = {
  INSUFFICIENT_STOCK: (details: any) => ({
    title: '库存不足',
    message: `当前可售数量：${details.available_quantity}件，无法满足销售需求`,
    action: '调整销售数量或补充库存',
    type: 'warning'
  }),
  
  NETWORK_ERROR: () => ({
    title: '网络连接失败',
    message: '请检查网络连接后重试',
    action: '点击重试按钮或刷新页面',
    type: 'error'
  }),
  
  PERMISSION_DENIED: () => ({
    title: '权限不足',
    message: '您没有执行此操作的权限',
    action: '请联系管理员获取相应权限',
    type: 'warning'
  })
};
```

#### 6.7.2 错误预防策略

**前端预防措施：**
```typescript
// SKU操作前置检查
const preCheckSkuOperation = (sku: any, operation: string, quantity?: number) => {
  const checks = [];
  
  // 检查SKU状态
  if (sku.status !== 'ACTIVE') {
    checks.push({
      type: 'error',
      message: 'SKU已停用，无法执行操作'
    });
  }
  
  // 检查库存充足性
  if (operation === 'SELL' && quantity && quantity > sku.available_quantity) {
    checks.push({
      type: 'warning',
      message: `库存不足，当前可售：${sku.available_quantity}件`
    });
  }
  
  // 检查数量合理性
  if (quantity && (quantity <= 0 || quantity > 9999)) {
    checks.push({
      type: 'error',
      message: '数量必须在1-9999之间'
    });
  }
  
  return checks;
};
```

## 七、客户管理错误处理规范（2025年1月修复版）

### 7.1 客户管理错误类型定义

**客户管理特有错误类型：**
```typescript
enum CustomerErrorType {
  // 客户相关错误
  CUSTOMER_NOT_FOUND = 'CUSTOMER_NOT_FOUND', // 客户不存在
  CUSTOMER_PHONE_EXISTS = 'CUSTOMER_PHONE_EXISTS', // 客户手机号已存在
  CUSTOMER_HAS_PURCHASES = 'CUSTOMER_HAS_PURCHASES', // 客户有销售记录，无法删除
  INVALID_CUSTOMER_DATA = 'INVALID_CUSTOMER_DATA', // 客户数据无效
  
  // 销售记录相关错误
  PURCHASE_NOT_FOUND = 'PURCHASE_NOT_FOUND', // 销售记录不存在
  PURCHASE_ALREADY_REFUNDED = 'PURCHASE_ALREADY_REFUNDED', // 销售记录已退货
  REFUND_FAILED = 'REFUND_FAILED', // 退货处理失败
  INVALID_REFUND_REASON = 'INVALID_REFUND_REASON', // 无效的退货原因
  
  // 权限相关错误
  INSUFFICIENT_PERMISSION = 'INSUFFICIENT_PERMISSION', // 权限不足
  COST_DATA_ACCESS_DENIED = 'COST_DATA_ACCESS_DENIED', // 成本数据访问被拒绝
  
  // 认证相关错误
  AUTH_STATE_LOADING = 'AUTH_STATE_LOADING', // 认证状态加载中
  AUTH_TOKEN_EXPIRED = 'AUTH_TOKEN_EXPIRED', // 认证令牌过期
  AUTH_INITIALIZATION_FAILED = 'AUTH_INITIALIZATION_FAILED', // 认证初始化失败
  
  // 数据计算错误
  ANALYTICS_CALCULATION_ERROR = 'ANALYTICS_CALCULATION_ERROR', // 分析数据计算错误
  PROFIT_MARGIN_CALCULATION_ERROR = 'PROFIT_MARGIN_CALCULATION_ERROR', // 毛利率计算错误
  ORDER_VALUE_CALCULATION_ERROR = 'ORDER_VALUE_CALCULATION_ERROR', // 订单价值计算错误
  
  // SKU相关错误
  SKU_OUT_OF_STOCK = 'SKU_OUT_OF_STOCK', // SKU库存不足
  SKU_NOT_AVAILABLE = 'SKU_NOT_AVAILABLE', // SKU不可用
  SKU_PRICE_INVALID = 'SKU_PRICE_INVALID', // SKU价格无效
}
```

### 7.2 认证状态错误处理

**认证状态管理错误处理：**
```typescript
// 认证状态错误处理器
class CustomerAuthErrorHandler {
  private static instance: CustomerAuthErrorHandler;
  
  static getInstance(): CustomerAuthErrorHandler {
    if (!this.instance) {
      this.instance = new CustomerAuthErrorHandler();
    }
    return this.instance;
  }
  
  handleAuthError(error: any, context: string): void {
    console.error(`客户管理认证错误 [${context}]:`, error);
    
    if (error.response?.status === 401) {
      this.handleTokenExpired();
    } else if (error.code === 'AUTH_STATE_LOADING') {
      this.handleAuthStateLoading();
    } else if (error.code === 'AUTH_INITIALIZATION_FAILED') {
      this.handleAuthInitializationFailed();
    } else {
      this.handleGenericAuthError(error);
    }
  }
  
  private handleTokenExpired(): void {
    toast.error('登录已过期，请重新登录');
    localStorage.removeItem('token');
    localStorage.removeItem('user');
    window.location.href = '/login';
  }
  
  private handleAuthStateLoading(): void {
    // 认证状态加载中，显示加载状态
    console.log('认证状态加载中，等待初始化完成...');
  }
  
  private handleAuthInitializationFailed(): void {
    toast.error('认证初始化失败，请刷新页面重试');
    setTimeout(() => {
      window.location.reload();
    }, 2000);
  }
  
  private handleGenericAuthError(error: any): void {
    toast.error('认证错误，请重新登录');
    console.error('未知认证错误:', error);
  }
}

// 使用示例
const authErrorHandler = CustomerAuthErrorHandler.getInstance();

// 在客户管理组件中使用
useEffect(() => {
  if (authLoading) {
    // 认证状态还在加载中，等待
    return;
  }
  
  if (!isAuthenticated || !user) {
    // 认证失败，处理错误
    authErrorHandler.handleAuthError(
      { code: 'AUTH_TOKEN_EXPIRED' },
      'CustomerManagement'
    );
    return;
  }
  
  // 认证成功，加载客户数据
  loadCustomerData().catch(error => {
    authErrorHandler.handleAuthError(error, 'loadCustomerData');
  });
}, [isAuthenticated, user, authLoading]);
```

### 7.3 客户数据错误处理

**客户数据操作错误处理：**
```typescript
// 客户数据错误处理器
class CustomerDataErrorHandler {
  static handleCustomerListError(error: any): void {
    console.error('客户列表加载失败:', error);
    
    if (error.response?.status === 403) {
      toast.error('您没有权限查看客户列表');
    } else if (error.response?.status === 500) {
      toast.error('服务器错误，请稍后重试');
    } else if (error.code === 'NETWORK_ERROR') {
      toast.error('网络连接失败，请检查网络后重试');
    } else {
      toast.error('加载客户列表失败，请重试');
    }
  }
  
  static handleCustomerDetailError(error: any, customerId: string): void {
    console.error(`客户详情加载失败 [${customerId}]:`, error);
    
    if (error.response?.status === 404) {
      toast.error('客户不存在或已被删除');
    } else if (error.response?.status === 403) {
      toast.error('您没有权限查看客户详情');
    } else {
      toast.error('加载客户详情失败，请重试');
    }
  }
  
  static handleCustomerCreateError(error: any): void {
    console.error('客户创建失败:', error);
    
    const errorCode = error.response?.data?.error?.code;
    
    switch (errorCode) {
      case 'CUSTOMER_PHONE_EXISTS':
        toast.error('该手机号已存在，请使用其他手机号');
        break;
      case 'INVALID_CUSTOMER_DATA':
        toast.error('客户信息格式不正确，请检查后重试');
        break;
      case 'VALIDATION_ERROR':
        const details = error.response?.data?.error?.details;
        if (details?.field === 'customer_phone') {
          toast.error('请输入正确的手机号格式');
        } else if (details?.field === 'customer_name') {
          toast.error('客户姓名不能为空');
        } else {
          toast.error('客户信息验证失败，请检查输入');
        }
        break;
      default:
        toast.error('创建客户失败，请重试');
    }
  }
  
  static handleCustomerUpdateError(error: any): void {
    console.error('客户更新失败:', error);
    
    const errorCode = error.response?.data?.error?.code;
    
    switch (errorCode) {
      case 'CUSTOMER_NOT_FOUND':
        toast.error('客户不存在，可能已被删除');
        break;
      case 'CUSTOMER_PHONE_EXISTS':
        toast.error('该手机号已被其他客户使用');
        break;
      case 'INSUFFICIENT_PERMISSION':
        toast.error('您没有权限修改客户信息');
        break;
      default:
        toast.error('更新客户信息失败，请重试');
    }
  }
  
  static handleCustomerDeleteError(error: any): void {
    console.error('客户删除失败:', error);
    
    const errorCode = error.response?.data?.error?.code;
    
    switch (errorCode) {
      case 'CUSTOMER_HAS_PURCHASES':
        toast.error('该客户有销售记录，无法删除');
        break;
      case 'INSUFFICIENT_PERMISSION':
        toast.error('您没有权限删除客户');
        break;
      case 'CUSTOMER_NOT_FOUND':
        toast.error('客户不存在，可能已被删除');
        break;
      default:
        toast.error('删除客户失败，请重试');
    }
  }
}
```

### 7.4 销售记录错误处理

**销售记录操作错误处理：**
```typescript
// 销售记录错误处理器
class CustomerSaleErrorHandler {
  static handleSaleCreateError(error: any): void {
    console.error('销售记录创建失败:', error);
    
    const errorCode = error.response?.data?.error?.code;
    const details = error.response?.data?.error?.details;
    
    switch (errorCode) {
      case 'SKU_OUT_OF_STOCK':
        const available = details?.available_quantity || 0;
        toast.error(`库存不足，当前可用库存：${available}`);
        break;
      case 'SKU_NOT_AVAILABLE':
        toast.error('所选SKU不可用，请选择其他产品');
        break;
      case 'SKU_PRICE_INVALID':
        toast.error('销售价格无效，请输入正确的价格');
        break;
      case 'CUSTOMER_NOT_FOUND':
        toast.error('客户不存在，请刷新页面后重试');
        break;
      case 'VALIDATION_ERROR':
        if (details?.field === 'quantity') {
          toast.error('销售数量必须大于0');
        } else if (details?.field === 'selling_price') {
          toast.error('销售价格必须大于0');
        } else {
          toast.error('销售信息验证失败，请检查输入');
        }
        break;
      default:
        toast.error('创建销售记录失败，请重试');
    }
  }
  
  static handleRefundError(error: any): void {
    console.error('退货处理失败:', error);
    
    const errorCode = error.response?.data?.error?.code;
    
    switch (errorCode) {
      case 'PURCHASE_NOT_FOUND':
        toast.error('销售记录不存在，可能已被删除');
        break;
      case 'PURCHASE_ALREADY_REFUNDED':
        toast.error('该销售记录已经退货，无法重复操作');
        break;
      case 'INVALID_REFUND_REASON':
        toast.error('请选择有效的退货原因');
        break;
      case 'INSUFFICIENT_PERMISSION':
        toast.error('您没有权限处理退货');
        break;
      case 'REFUND_FAILED':
        toast.error('退货处理失败，请联系管理员');
        break;
      default:
        toast.error('退货处理失败，请重试');
    }
  }
}
```

### 7.5 客户分析数据错误处理

**分析数据计算错误处理：**
```typescript
// 客户分析错误处理器
class CustomerAnalyticsErrorHandler {
  static handleAnalyticsError(error: any): void {
    console.error('客户分析数据加载失败:', error);
    
    const errorCode = error.response?.data?.error?.code;
    
    switch (errorCode) {
      case 'ANALYTICS_CALCULATION_ERROR':
        toast.error('分析数据计算错误，请联系技术支持');
        break;
      case 'PROFIT_MARGIN_CALCULATION_ERROR':
        toast.error('毛利率计算错误，成本数据可能异常');
        break;
      case 'ORDER_VALUE_CALCULATION_ERROR':
        toast.error('订单价值计算错误，请检查销售数据');
        break;
      case 'COST_DATA_ACCESS_DENIED':
        toast.error('您没有权限查看成本相关数据');
        break;
      default:
        toast.error('加载分析数据失败，请重试');
    }
  }
  
  // 数据计算安全处理
  static safeCalculateAnalytics(data: any): CustomerAnalytics {
    try {
      const analytics: CustomerAnalytics = {
        total_customers: this.safeNumber(data.total_customers),
        new_customers: this.safeNumber(data.new_customers),
        repeat_customers: this.safeNumber(data.repeat_customers),
        vip_customers: this.safeNumber(data.vip_customers),
        active_customers: this.safeNumber(data.active_customers),
        average_order_value: this.safeNumber(data.average_order_value),
        average_profit_margin: this.safeNumber(data.average_profit_margin),
        refund_rate: this.safeNumber(data.refund_rate),
        total_revenue: this.safeNumber(data.total_revenue),
        total_orders: this.safeNumber(data.total_orders)
      };
      
      // 数据合理性检查
      this.validateAnalyticsData(analytics);
      
      return analytics;
    } catch (error) {
      console.error('分析数据处理失败:', error);
      throw new Error('ANALYTICS_CALCULATION_ERROR');
    }
  }
  
  private static safeNumber(value: any): number {
    const num = Number(value);
    return isNaN(num) ? 0 : num;
  }
  
  private static validateAnalyticsData(analytics: CustomerAnalytics): void {
    // 检查数据合理性
    if (analytics.average_profit_margin > 100) {
      console.warn('毛利率超过100%，数据可能异常:', analytics.average_profit_margin);
    }
    
    if (analytics.refund_rate > 100) {
      console.warn('退货率超过100%，数据可能异常:', analytics.refund_rate);
    }
    
    if (analytics.new_customers + analytics.repeat_customers > analytics.total_customers) {
      console.warn('客户分类统计数据异常');
    }
  }
}
```

### 7.6 权限控制错误处理

**权限验证错误处理：**
```typescript
// 权限错误处理器
class CustomerPermissionErrorHandler {
  static handlePermissionError(error: any, operation: string): void {
    console.error(`权限错误 [${operation}]:`, error);
    
    const errorCode = error.response?.data?.error?.code;
    
    switch (errorCode) {
      case 'INSUFFICIENT_PERMISSION':
        this.handleInsufficientPermission(operation);
        break;
      case 'COST_DATA_ACCESS_DENIED':
        toast.error('您没有权限查看成本数据');
        break;
      case 'AUTH_TOKEN_EXPIRED':
        this.handleTokenExpired();
        break;
      default:
        toast.error('权限验证失败，请重新登录');
    }
  }
  
  private static handleInsufficientPermission(operation: string): void {
    const operationMessages = {
      'view_cost_data': '您没有权限查看成本数据',
      'process_refund': '您没有权限处理退货',
      'edit_customer': '您没有权限修改客户信息',
      'delete_customer': '您没有权限删除客户',
      'create_sale': '您没有权限创建销售记录'
    };
    
    const message = operationMessages[operation] || '您没有权限执行此操作';
    toast.error(message);
  }
  
  private static handleTokenExpired(): void {
    toast.error('登录已过期，请重新登录');
    localStorage.removeItem('token');
    localStorage.removeItem('user');
    setTimeout(() => {
      window.location.href = '/login';
    }, 1000);
  }
  
  // 权限预检查
  static preCheckPermission(userRole: string, operation: string): boolean {
    const permissions = {
      'view_customers': ['BOSS', 'MANAGER', 'EMPLOYEE'],
      'view_cost_data': ['BOSS'],
      'process_refund': ['BOSS', 'MANAGER'],
      'edit_customer': ['BOSS', 'MANAGER'],
      'delete_customer': ['BOSS'],
      'create_sale': ['BOSS', 'MANAGER', 'EMPLOYEE']
    };
    
    const allowedRoles = permissions[operation];
    if (!allowedRoles) {
      console.warn(`未知操作权限: ${operation}`);
      return false;
    }
    
    return allowedRoles.includes(userRole);
  }
}
```

### 7.7 客户管理错误处理最佳实践

**统一错误处理入口：**
```typescript
// 客户管理统一错误处理器
class CustomerErrorHandler {
  static handle(error: any, context: string, operation?: string): void {
    console.error(`客户管理错误 [${context}]:`, error);
    
    // 记录错误日志
    this.logError(error, context, operation);
    
    // 根据错误类型分发处理
    if (this.isAuthError(error)) {
      CustomerAuthErrorHandler.getInstance().handleAuthError(error, context);
    } else if (this.isPermissionError(error)) {
      CustomerPermissionErrorHandler.handlePermissionError(error, operation || 'unknown');
    } else if (this.isDataError(error)) {
      CustomerDataErrorHandler.handleCustomerListError(error);
    } else if (this.isSaleError(error)) {
      CustomerSaleErrorHandler.handleSaleCreateError(error);
    } else if (this.isAnalyticsError(error)) {
      CustomerAnalyticsErrorHandler.handleAnalyticsError(error);
    } else {
      this.handleGenericError(error, context);
    }
  }
  
  private static isAuthError(error: any): boolean {
    return error.response?.status === 401 || 
           ['AUTH_STATE_LOADING', 'AUTH_TOKEN_EXPIRED', 'AUTH_INITIALIZATION_FAILED'].includes(error.code);
  }
  
  private static isPermissionError(error: any): boolean {
    return error.response?.status === 403 || 
           ['INSUFFICIENT_PERMISSION', 'COST_DATA_ACCESS_DENIED'].includes(error.response?.data?.error?.code);
  }
  
  private static isDataError(error: any): boolean {
    const errorCode = error.response?.data?.error?.code;
    return ['CUSTOMER_NOT_FOUND', 'CUSTOMER_PHONE_EXISTS', 'INVALID_CUSTOMER_DATA'].includes(errorCode);
  }
  
  private static isSaleError(error: any): boolean {
    const errorCode = error.response?.data?.error?.code;
    return ['SKU_OUT_OF_STOCK', 'PURCHASE_NOT_FOUND', 'REFUND_FAILED'].includes(errorCode);
  }
  
  private static isAnalyticsError(error: any): boolean {
    const errorCode = error.response?.data?.error?.code;
    return ['ANALYTICS_CALCULATION_ERROR', 'PROFIT_MARGIN_CALCULATION_ERROR'].includes(errorCode);
  }
  
  private static handleGenericError(error: any, context: string): void {
    if (error.response?.status >= 500) {
      toast.error('服务器错误，请稍后重试');
    } else if (error.code === 'NETWORK_ERROR') {
      toast.error('网络连接失败，请检查网络后重试');
    } else {
      toast.error(`操作失败，请重试 (${context})`);
    }
  }
  
  private static logError(error: any, context: string, operation?: string): void {
    const errorLog = {
      timestamp: new Date().toISOString(),
      context,
      operation,
      error: {
        message: error.message,
        code: error.response?.data?.error?.code || error.code,
        status: error.response?.status,
        details: error.response?.data?.error?.details
      },
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    // 发送错误日志到监控系统
    console.error('客户管理错误日志:', errorLog);
    
    // 可以集成第三方错误监控服务
    // Sentry.captureException(error, { extra: errorLog });
  }
}

// 使用示例
try {
  await customer_api.getCustomers();
} catch (error) {
  CustomerErrorHandler.handle(error, 'CustomerManagement.loadCustomers', 'view_customers');
}

try {
  await customer_api.createSale(saleData);
} catch (error) {
  CustomerErrorHandler.handle(error, 'CustomerManagement.createSale', 'create_sale');
}
```

### 7.8 客户管理错误恢复策略

**自动恢复机制：**
```typescript
// 客户管理错误恢复器
class CustomerErrorRecovery {
  private static retryAttempts = new Map<string, number>();
  private static readonly MAX_RETRY_ATTEMPTS = 3;
  private static readonly RETRY_DELAY = 1000; // 1秒
  
  static async executeWithRetry<T>(
    operation: () => Promise<T>,
    operationId: string,
    context: string
  ): Promise<T> {
    const attempts = this.retryAttempts.get(operationId) || 0;
    
    try {
      const result = await operation();
      // 成功后重置重试次数
      this.retryAttempts.delete(operationId);
      return result;
    } catch (error) {
      console.error(`操作失败 [${operationId}], 尝试次数: ${attempts + 1}`, error);
      
      // 检查是否应该重试
      if (this.shouldRetry(error) && attempts < this.MAX_RETRY_ATTEMPTS) {
        this.retryAttempts.set(operationId, attempts + 1);
        
        // 延迟后重试
        await this.delay(this.RETRY_DELAY * (attempts + 1));
        return this.executeWithRetry(operation, operationId, context);
      } else {
        // 重试次数用尽或不应重试，清除计数并抛出错误
        this.retryAttempts.delete(operationId);
        CustomerErrorHandler.handle(error, context);
        throw error;
      }
    }
  }
  
  private static shouldRetry(error: any): boolean {
    // 网络错误和服务器错误可以重试
    return error.code === 'NETWORK_ERROR' || 
           error.response?.status >= 500 ||
           error.code === 'TIMEOUT_ERROR';
  }
  
  private static delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // 数据恢复机制
  static async recoverCustomerData(): Promise<void> {
    try {
      // 尝试从本地存储恢复数据
      const cachedData = localStorage.getItem('customer_cache');
      if (cachedData) {
        const parsedData = JSON.parse(cachedData);
        // 验证缓存数据的有效性
        if (this.isValidCacheData(parsedData)) {
          toast.info('已从缓存恢复客户数据');
          return parsedData;
        }
      }
      
      // 缓存无效，尝试重新加载
      toast.info('正在重新加载客户数据...');
      await this.executeWithRetry(
        () => customer_api.getCustomers(),
        'recover_customer_data',
        'CustomerErrorRecovery.recoverCustomerData'
      );
    } catch (error) {
      toast.error('数据恢复失败，请刷新页面');
      throw error;
    }
  }
  
  private static isValidCacheData(data: any): boolean {
    return data && 
           Array.isArray(data.customers) && 
           data.timestamp && 
           (Date.now() - data.timestamp) < 5 * 60 * 1000; // 5分钟内的缓存有效
  }
}

// 使用示例
const loadCustomerData = async () => {
  try {
    const data = await CustomerErrorRecovery.executeWithRetry(
      () => customer_api.getCustomers(),
      'load_customer_list',
      'CustomerManagement.loadCustomerData'
    );
    setCustomers(data.customers);
  } catch (error) {
    // 错误已在 executeWithRetry 中处理
    console.error('加载客户数据最终失败:', error);
  }
};
```
```